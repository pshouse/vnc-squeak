'From Squeak5.0 of 20 July 2015 [latest update: #15110] on 20 July 2015 at 4:14:07 pm'!ReleaseBuilder prepareNewRelease!----QUIT----{20 July 2015 . 4:14:16 pm} Squeak5.0-15110.image priorSource: 0!----STARTUP----{23 July 2015 . 4:29:16 am} as /home/pi/Downloads/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 4:29:25 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{23 July 2015 . 4:35:21 am} as /home/pi/Downloads/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 4:35:54 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{23 July 2015 . 10:39:38 pm} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT/NOSAVE----{23 July 2015 . 10:39:42 pm} Squeak5.0-15110.image priorSource: 123!----STARTUP----{24 July 2015 . 10:37:42 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!SystemOrganization addCategory: #UserObjects!----QUIT----{24 July 2015 . 10:39:02 am} Squeak5.0-15110.image priorSource: 123!----STARTUP----{24 July 2015 . 10:39:16 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!FileList initialize!----QUIT----{24 July 2015 . 10:39:36 am} Squeak5.0-15110.image priorSource: 1160!----STARTUP----{24 July 2015 . 10:39:44 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!MCFileBasedRepository flushAllCaches.!----QUIT----{24 July 2015 . 10:39:56 am} Squeak5.0-15110.image priorSource: 1430!----STARTUP----{24 July 2015 . 10:46:41 am} as /home/cmm/Chris/dev/Squeak/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15110.image!----QUIT----{24 July 2015 . 10:48 am} Squeak5.0-15110.image priorSource: 1719!----STARTUP----{24 July 2015 . 1:16:20 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{24 July 2015 . 3:04:34 pm} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{28 July 2015 . 2:21:53 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{28 July 2015 . 2:21:59 pm} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{2 August 2015 . 10:17:39 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!----QUIT/NOSAVE----{3 August 2015 . 1:31:21 am} Squeak5.0-15110.image priorSource: 1968!----STARTUP----{5 August 2015 . 4:08:17 pm} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!	Display extent!----STARTUP----{6 August 2015 . 10:23:48 am} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15110.image!!CompiledMethod methodsFor: '*Kernel-tool support' stamp: 'cmm 8/5/2015 19:59' prior: 31510441!hasBreakpoint	^ self class environment		at: #BreakpointManager		ifPresent: [:bpm | bpm methodHasBreakpoint: self]		ifAbsent: [false]! !"Kernel"!!CompiledMethod methodsFor: '*Kernel-tool support' stamp: 'cmm 8/5/2015 19:59' prior: 33557358!hasBreakpoint	^ self class environment		at: #BreakpointManager		ifPresent: [:bpm | bpm methodHasBreakpoint: self]		ifAbsent: [false]! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 7/24/2015 09:54' prior: 52285267!prepareNewBuild: anMCRepository 	"ReleaseBuilderTrunk prepareNewBuild"	"Prepare everything that should be done for a new image build"	MCMcmUpdater updateMissingPackages: true.	MCMcmUpdater enableUpdatesForAllPackages.	TTCFont registerAll.	FileList initialize.	RealEstateAgent standardSize: 600 @ 400.	SystemVersion newVersion: self versionString.	SMLoaderPlus setDefaultFilters: (OrderedCollection with: #filterSafelyAvailable)."	Preferences outOfTheBox."  "<-- uncomment after #defaultValueTableForCurrentRelease is fixed up."	self		 setDisplayExtent: 800 @ 600 ;		 switchToNewRepository: anMCRepository ;		 setPreferences ;  "<-- remove this after defaultValueTableForCurrentRelease is fixed up."		 checkForDirtyPackages ;		 configureDesktop.	Smalltalk cleanUp: true.	MCFileBasedRepository flushAllCaches.	MCHttpRepository clearCredentials.	Utilities setAuthorInitials: String empty.	Environment allInstancesDo: [ : env | env purgeUndeclared ].	Undeclared removeUnreferencedKeys.	Smalltalk garbageCollect.	[ self loadWellKnownPackages "<-- 4.5 is not ready for unloaded / reloaded packages" ].	Compiler recompileAll.	self		setProjectBackground: Color darkGray ;		openWelcomeWorkspaces! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 1/26/2014 22:12' prior: 52287084!prepareNewRelease	"This method is run at time of release to transfer the top trunk versions into my releaseRepository, and produce a release image."	self		transferCurrentPackagesAsUser: Utilities authorInitials		password: (UIManager default requestPassword: 'Enter password for ' , self projectUrl).	self prepareNewBuild: self releaseRepository! !!ReleaseBuilder class methodsFor: 'scripts' stamp: 'cmm 8/5/2015 19:41' prior: 52288115!prepareNextVersionAlpha	"Prepare the first alpha image for next release."	SystemVersion		newVersion: ((UIManager default request: 'Please specify the name of the\new version of Squeak.' withCRs initialAnswer: SystemVersion current version)				ifEmpty: [^ self inform: 'Aborted.']).	MCFileBasedRepository flushAllCaches.	MCHttpRepository clearCredentials.	Utilities setAuthorInitials: String empty.	self switchToNewRepository: self buildRepository! !!ReleaseBuilder class methodsFor: 'preferences' stamp: 'cmm 7/24/2015 10:27' prior: 52305451!setPreferences	"Preferences class defaultValueTableForCurrentRelease"	self setProjectBackground: Color darkGray.	"General User interaction"	Preferences		enable: #generalizedYellowButtonMenu ;		disable: #mouseOverForKeyboardFocus ;		enable: #swapMouseButtons.	Morph indicateKeyboardFocus: true.	SearchBar useScratchPad: false.			"Text input."	TextEditor		 autoEnclose: true ;		 autoIndent: true ;		 destructiveBackWord: false ;		 blinkingCursor: true ;		 dumbbellCursor: false.	Preferences		 insertionPointColor: Color red.	PluggableTextMorph simpleFrameAdornments: false.		"Windows"	Preferences installUniformWindowColors.	SystemWindow reuseWindows: false.	Model windowActiveOnFirstClick: false. "Not good for 800x600"	Preferences		disable: #showSplitterHandles;		enable: #fastDragWindowForMorphic.		CornerGripMorph drawCornerResizeHandles: false.	ProportionalSplitterMorph		 smartHorizontalSplitters: false ;		 smartVerticalSplitters: false.	"Scroll bars."	Preferences		enable: #scrollBarsNarrow;		enable: #scrollBarsOnRight;		disable: #alwaysHideHScrollbar;		disable: #alwaysShowHScrollbar;		disable: #alwaysShowVScrollbar.	ScrollBar		scrollBarsWithoutArrowButtons: true;		scrollBarsWithoutMenuButton: true.	ScrollPane		useRetractableScrollBars: false.	"Rounded corners."	Morph preferredCornerRadius: 6.	Preferences disable: #roundedWindowCorners.	PluggableButtonMorph roundedButtonCorners: false.	FillInTheBlankMorph roundedDialogCorners: false.	MenuMorph roundedMenuCorners: false.	ScrollBar roundedScrollBarLook: false.		"Gradients."	Preferences disable: #gradientScrollBars.	SystemWindow gradientWindow: false.	MenuMorph gradientMenu: false.	PluggableButtonMorph gradientButton: false.	"Shadows"	Preferences enable: #menuAppearance3d.	MenuMorph		menuBorderWidth: 1;		menuBorderColor: Color lightGray;		menuLineColor: Color lightGray.	Morph useSoftDropShadow: true..		"Lists and Trees"	PluggableListMorph		filterableLists: true;		clearFilterAutomatically: false;		highlightHoveredRow: true;		menuRequestUpdatesSelection: true.	PluggableTreeMorph		filterByLabelsOnly: false;		maximumSearchDepth: 1.	LazyListMorph		listSelectionTextColor: Color black;		listSelectionColor: (Color r: 0.72 g: 0.72 b: 0.9).		"Standard Tools"	BalloonMorph setBalloonColorTo:		(TranslucentColor r: 0.92 g: 0.92 b: 0.706 alpha: 0.75).	Workspace shouldStyle: false.	Browser		listClassesHierarchically: true;		showClassIcons: true;		showMessageIcons: true;		sortMessageCategoriesAlphabetically: true.	Preferences enable: #annotationPanes;		 enable: #optionalButtons;		 enable: #diffsWithPrettyPrint;		 enable: #traceMessages;		 enable: #alternativeBrowseIt;		 enable: #menuWithIcons;		 enable: #visualExplorer.	SystemNavigation thoroughSenders: true.		"Halo"	Preferences		enable: #showBoundsInHalo ;		disable: #alternateHandlesLook.	"System"	NetNameResolver enableIPv6: false.	Scanner		allowUnderscoreAsAssignment: true;		prefAllowUnderscoreSelectors: true.	"that's all, folks"! !"ReleaseBuilder"!"Kernel"!----SNAPSHOT----{6 August 2015 . 10:24:41 am} Squeak5.0-15113.image priorSource: 1968!----STARTUP----{6 August 2015 . 10:46:02 am} as /home/cmm/Chris/dev/Squeak/Squeak5.0-15113.image!"Morphic"!SystemOrganization removeSystemCategory: 'Morphic-UserObjects'!SystemOrganization removeSystemCategory: 'EToy-UserObjects'!SystemOrganization removeSystemCategory: 'Morphic-Imported'!ReleaseBuilder prepareNewRelease!----QUIT----{6 August 2015 . 10:50:45 am} Squeak5.0-15113.image priorSource: 8807!----STARTUP----{9 August 2015 . 10:50:30 am} as /Users/craig/Downloads/squeak release/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!----QUIT/NOSAVE----{9 August 2015 . 10:50:39 am} Squeak5.0-15113.image priorSource: 9231!----STARTUP----{9 August 2015 . 10:51:22 am} as /Users/craig/Downloads/squeak release/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!----QUIT/NOSAVE----{9 August 2015 . 10:51:47 am} Squeak5.0-15113.image priorSource: 9231!----STARTUP----{12 August 2015 . 1:01:08 am} as /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!!Number methodsFor: 'mathematical functions' stamp: 'ul 5/24/2015 06:22' prior: 56799868!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue: [		"Do the special case of integer power"		^ self raisedToInteger: aNumber].	aNumber isFraction ifTrue: [		"Special case for fraction power"		^ (self nthRoot: aNumber denominator) raisedToInteger: aNumber numerator ].	self negative ifTrue: [		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].	aNumber isZero ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	self isZero ifTrue: [				"Special case of self = 0"		aNumber negative			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Integer class methodsFor: 'prime numbers' stamp: 'ul 7/20/2015 01:08' prior: 18814397!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require one *GIGA*byte).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| n limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit increments incrementIndex |	limit := max asInteger - 1.	indexLimit := max asInteger sqrtFloor + 1.	"Create the array of flags."	flags := ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 := self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex := Array new: 2310.	bitIndex := -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex := bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex := bitIndex + 1).	index := 1.	[ index <= 5 ] whileTrue: [		aBlock value: (primesUpTo2310 at: index).		index := index + 1 ].		n := 2.	[ n <= 2309 ] whileTrue: [		[(primesUpTo2310 at: index) < n] 			whileTrue:[index := index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1)].		].		n := n + 1 ].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by iterating through increments, which enables us to only check about 20.77% of all numbers."	n := 13.	increments := #[4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4 6 8 4 2 4 2 4 14 4 6 2 10 2 6 6 4 2 4 6 2 10 2 4 2 12 10 2 4 2 4 6 2 6 4 6 6 6 2 6 4 2 6 4 6 8 4 2 4 6 8 6 10 2 4 6 2 6 6 4 2 4 6 2 6 4 2 6 10 2 10 2 4 2 4 6 8 4 2 4 12 2 6 4 2 6 4 6 12 2 4 2 4 8 6 4 6 2 4 6 2 6 10 2 4 6 2 6 4 2 4 2 10 2 10 2 4 6 6 2 6 6 4 6 6 2 6 4 2 6 4 6 8 4 2 6 4 8 6 4 6 2 4 6 8 6 4 2 10 2 6 4 2 4 2 10 2 10 2 4 2 4 8 6 4 2 4 6 6 2 6 4 8 4 6 8 4 2 4 2 4 8 6 4 6 6 6 2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10 2 6 4 6 2 6 4 2 4 6 6 8 4 2 6 10 8 4 2 4 2 4 8 10 6 2 4 8 6 6 4 2 4 6 2 6 4 6 2 10 2 10 2 4 2 4 6 2 6 4 2 4 6 6 2 6 6 6 4 6 8 4 2 4 2 4 8 6 4 8 4 6 2 6 6 4 2 4 6 8 4 2 4 2 10 2 10 2 4 2 4 6 2 10 2 4 6 8 6 4 2 6 4 6 8 4 6 2 4 8 6 4 6 2 4 6 2 6 6 4 6 6 2 6 6 4 2 10 2 10 2 4 2 4 6 2 6 4 2 10 6 2 6 4 2 6 4 6 8 4 2 4 2 12 6 4 6 2 4 6 2 12 4 2 4 8 6 4 2 4 2 10 2 10 6 2 4 6 2 6 4 2 4 6 6 2 6 4 2 10 6 8 6 4 2 4 8 6 4 6 2 4 6 2 6 6 6 4 6 2 6 4 2 4 2 10 12 2 4 2 10 2 6 4 2 4 6 6 2 10 2 6 4 14 4 2 4 2 4 8 6 4 6 2 4 6 2 6 6 4 2 4 6 2 6 4 2 4 12 2 12].	incrementIndex := 1.	[ n <= limit ] whileTrue: [		(maskBit := maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex := n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex := 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * n to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index := n * n.					[index <= limit] whileTrue:[						(maskBit := maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex := (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit := 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index := index + n + n ].				].			].		].		n := n + (increments at: incrementIndex).		incrementIndex := incrementIndex + 1.		incrementIndex > increments size ifTrue: [ incrementIndex := 1 ] ]! !!Integer class methodsFor: 'prime numbers' stamp: 'ul 7/17/2015 01:01' prior: 18819189!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| index sieve increment limit limitSqrtFloor |	limit := max asInteger.	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 2/77th of the amount we need here and is almost as fast."	limit <= 100000 ifFalse: [ ^self largePrimesUpTo: limit do: aBlock ].	limit := limit - 1. "upTo:"	limit <= 1 ifTrue: [ ^self ].	aBlock value: 2.	limit <= 2 ifTrue: [ ^self ].	aBlock value: 3.	sieve := ByteArray new: limit withAll: 1. "1 = prime, 0 = not prime"	sieve at: 1 put: 0.	"Filter multiples of 2."	index := 4.	[ index <= limit ] whileTrue: [		sieve at: index put: 0.		index := index + 2 ].	"Filter multiples of 3."	index := 9.	[ index <= limit ] whileTrue: [		sieve at: index put: 0.		index := index + 3 ].	"Filter the rest of the primes."	limitSqrtFloor := limit sqrtFloor.	index := 5.	increment := 2.	[ index <= limitSqrtFloor ] whileTrue: [		(sieve at: index) = 1 ifTrue: [			| originalIndex originalIncrement |			aBlock value: index.			originalIndex := index.			originalIncrement := increment.			increment := index + index.			index := index * index.			[ index <= limit ] whileTrue: [				sieve at: index put: 0.				index := index + increment ].			index := originalIndex.			increment := originalIncrement ].		index := index + increment.		increment := 6 - increment ].	"No more new primes here."	[ index <= limit ] whileTrue: [		(sieve at: index) = 1 ifTrue: [			aBlock value: index ].		index := index + increment.		increment := 6 - increment ]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'eem 8/11/2015 18:17' prior: 25331665!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self methodDict keys select:					[:sel | (self compiledMethodAt: sel) fileIndex > 1].	changes isEmpty ifTrue:		[^self].	newFile cr; cr; command: 'H3'; nextChunkPut: self definition; command: '/H3'; cr.	self		fileOutChangedMessages: changes		on: newFile		moveSource: #historically		toFile: 2! !!Magnitude methodsFor: 'sorting' stamp: 'ul 5/24/2015 05:11' prior: 19080421!<=> anotherObject	"Return a collation order of -1, 0, or 1, indicating whether I should be collated before the receiver, am equal, or after.	See also:  http://en.wikipedia.org/wiki/Spaceship_operator"	self = anotherObject ifTrue: [ ^0 ].	self < anotherObject ifTrue: [ ^-1 ].	^1! !"Kernel"!!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 7/9/2015 20:59' prior: 50519990!sharedPools	| d |	d := Set new.	classDefinition poolDictionaries do:[:each |		d add: (Smalltalk at: each asSymbol ifAbsent:[nil]) ].	^d! !!SHTextStylerST80 methodsFor: 'private' stamp: 'ul 5/18/2015 03:40' prior: 24153879!setAttributesIn: aText fromRanges: ranges	| defaultAttributes newRuns newValues lastAttributes oldRuns nextIndex lastCount | 			oldRuns := aText runs.	defaultAttributes := self attributesFor: #default.	newRuns := OrderedCollection new: ranges size * 2 + 1.	newValues := OrderedCollection new: ranges size * 2 + 1.	lastAttributes := nil.	nextIndex := 1.	lastCount := 0.	ranges do: [ :range |		| attributes |		nextIndex < range start ifTrue: [ 			lastAttributes == defaultAttributes 				ifTrue: [					lastCount := lastCount + range start - nextIndex.					newRuns at: newRuns size put: lastCount ]				ifFalse: [					lastCount := range start - nextIndex.					newRuns addLast: lastCount. 					lastAttributes := defaultAttributes.					newValues addLast: lastAttributes ].			nextIndex := range start ].		attributes := (self attributesFor: range type) ifNil: [ defaultAttributes ].		lastAttributes == attributes			ifTrue: [ 				lastCount := lastCount + range end - nextIndex + 1.				newRuns at: newRuns size put: lastCount ]			ifFalse: [				lastCount := range end - nextIndex + 1.				newRuns addLast: lastCount.				lastAttributes := attributes.				newValues addLast: lastAttributes ].		nextIndex := range end + 1 ].	nextIndex <= aText size ifTrue: [		lastAttributes == defaultAttributes 				ifTrue: [					lastCount := lastCount + aText size - nextIndex + 1.					newRuns at: newRuns size put: lastCount ]				ifFalse: [					lastCount := aText size - nextIndex + 1.					newRuns addLast: lastCount.					lastAttributes := defaultAttributes.					newValues addLast: lastAttributes ] ].	aText runs: (RunArray runs: newRuns values: newValues).	oldRuns withStartStopAndValueDo: [ :start :stop :attribs |		(attribs anySatisfy: [ :each | each shoutShouldPreserve ]) ifTrue: [			attribs do: [ :each | aText addAttribute: each from: start to: stop ] ] ].	! !!PseudoClass methodsFor: '*ShoutCore' stamp: 'ul 7/26/2015 22:43'!shoutParserClass	^SHParserST80! !"ShoutCore"!----SNAPSHOT----{12 August 2015 . 11:53:57 pm} Squeak5.0-15113.image priorSource: 9231!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:35'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:35'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:35'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:35'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:35'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:35'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:35'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:35'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:35'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:35'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:35'!bar ^self blah! !CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!CompilerExceptionsTest organization removeCategory: #generated!| fontFile locale |fontFile := 'uJapaneseFont.out'.locale := Locale isoLanguage: 'ja'.StrikeFontSet installExternalFontOn: (self zip member: fontFile) contentStream forLocale: locale.!----End fileIn of a stream----!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-One'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Two'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-One'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Two'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Default'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Default'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!Object subclass: #ClassForTestToBeDeleted3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-One'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!Object subclass: #ClassForTestToBeDeleted5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Two'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-One'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Two'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: 'a b c'	classVariableNames: 'X Y'	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Default'!SystemOrganization addCategory: #'CategoryForTestToBeDeleted-Default'!Object subclass: #ClassForTestToBeDeleted1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CategoryForTestToBeDeleted-Default'!SystemOrganization removeSystemCategory: #'CategoryForTestToBeDeleted-Default'!SystemOrganization removeSystemCategory: #'SCFTCategory-Znurwqtixmhfjsavkdlegpyboc'!SystemOrganization addCategory: #'SCFTCategory-Znurwqtixmhfjsavkdlegpyboc'!SystemOrganization addCategory: #'SCFTCategory-Znurwqtixmhfjsavkdlegpyboc'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTgojarembzkcpvixqsnfduwytlh.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Znurwqtixmhfjsavkdlegpyboc'!SystemOrganization removeSystemCategory: #'SCFTCategory-Fqukhjomrxvndalcsybgzitpew'!SystemOrganization addCategory: #'SCFTCategory-Fqukhjomrxvndalcsybgzitpew'!SystemOrganization addCategory: #'SCFTCategory-Fqukhjomrxvndalcsybgzitpew'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTtpkdylnazsrfhcxvjiewgumboq.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Fqukhjomrxvndalcsybgzitpew'!SystemOrganization addCategory: #'SCFTCategory-Pfkuswvtrxaqnoedyblgjihczm'!SystemOrganization addCategory: #'SCFTCategory-Pfkuswvtrxaqnoedyblgjihczm'!SystemOrganization removeSystemCategory: #'SCFTCategory-Pfkuswvtrxaqnoedyblgjihczm'!SystemOrganization removeSystemCategory: #'SCFTCategory-Pfkuswvtrxaqnoedyblgjihczm'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTqliteudxafkgjrbonhswcmvyzp.changes----!SystemOrganization addCategory: #'SCFTCategory-Uxtgkpfdlqwseyomijchrnbzav'!SystemOrganization removeSystemCategory: #'SCFTCategory-Paduetjnqwcfmbhgozyvrksixl'!SystemOrganization addCategory: #'SCFTCategory-Uxtgkpfdlqwseyomijchrnbzav'!SystemOrganization renameCategory: #'SCFTCategory-Uxtgkpfdlqwseyomijchrnbzav' toBe: #'SCFTCategory-Paduetjnqwcfmbhgozyvrksixl'!SystemOrganization renameCategory: #'SCFTCategory-Uxtgkpfdlqwseyomijchrnbzav' toBe: #'SCFTCategory-Paduetjnqwcfmbhgozyvrksixl'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTzlfpnoeymubvcgdjtkiwqxrhsa.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Paduetjnqwcfmbhgozyvrksixl'!Smalltalk removeClassNamed: #SCFTClassTyiemxzghjquavbdkpwrnfoslc!SystemOrganization removeSystemCategory: #'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!SystemOrganization addCategory: #'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!SystemOrganization addCategory: #'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!Object subclass: #SCFTClassTyiemxzghjquavbdkpwrnfoslc	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!Object subclass: #SCFTClassTyiemxzghjquavbdkpwrnfoslc	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTswrcbatfmovkxqejngzdlupiyh.changes----!Smalltalk removeClassNamed: #SCFTClassTyiemxzghjquavbdkpwrnfoslc!SystemOrganization removeSystemCategory: #'SCFTCategory-Jvapgnbouckylshtifdxmerqwz'!SystemOrganization addCategory: #'SCFTCategory-Xnvmheulcqwbazgpkditfrsyoj'!Object subclass: #SCFTClassRxtqjcpoygevufzhkwiamlnsdb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Xnvmheulcqwbazgpkditfrsyoj'!Smalltalk removeClassNamed: #SCFTClassRxtqjcpoygevufzhkwiamlnsdb!SystemOrganization removeSystemCategory: #'SCFTCategory-Xnvmheulcqwbazgpkditfrsyoj'!SystemOrganization addCategory: #'SCFTCategory-Kfxpqdosuvtbhleijmrzygwacn'!Object subclass: #SCFTClassRxtqjcpoygevufzhkwiamlnsdb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Kfxpqdosuvtbhleijmrzygwacn'!SCFTClassRxtqjcpoygevufzhkwiamlnsdb commentStamp: '<historical>' prior: 0!!SCFTClassRxtqjcpoygevufzhkwiamlnsdb commentStamp: '<historical>' prior: 0!iscvlzuyjeoptbagwdqnkfhrxm!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTnyspzxdlvqabekwoctjimhfugr.changes----!Smalltalk removeClassNamed: #SCFTClassRxtqjcpoygevufzhkwiamlnsdb!SystemOrganization removeSystemCategory: #'SCFTCategory-Kfxpqdosuvtbhleijmrzygwacn'!SystemOrganization addCategory: #'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!Object subclass: #SCFTClassAmpvnqxkojuhyercdigsltzfwb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!Smalltalk removeClassNamed: #SCFTClassAmpvnqxkojuhyercdigsltzfwb!SystemOrganization removeSystemCategory: #'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!SystemOrganization addCategory: #'SCFTCategory-Dcimjouqfzenhxbvyplwkrgast'!Object subclass: #SCFTClassAmpvnqxkojuhyercdigsltzfwb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Dcimjouqfzenhxbvyplwkrgast'!SystemOrganization addCategory: #'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!SystemOrganization classify: #SCFTClassAmpvnqxkojuhyercdigsltzfwb under: 'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!Object subclass: #SCFTClassAmpvnqxkojuhyercdigsltzfwb	instanceVariableNames: 'scftInstVarIpbuzcgnsltjwoexhfdqvmyrak'	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTdoulgfmxvitnkcjwsrbeyqzhpa.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Dcimjouqfzenhxbvyplwkrgast'!Smalltalk removeClassNamed: #SCFTClassAmpvnqxkojuhyercdigsltzfwb!SystemOrganization removeSystemCategory: #'SCFTCategory-Bjckvaqowtdeuripzlyfxnsmgh'!SystemOrganization addCategory: #'SCFTCategory-Vpfamnrwzqoidbkychxsgujlet'!Object subclass: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Vpfamnrwzqoidbkychxsgujlet'!SystemOrganization addCategory: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!SystemOrganization removeSystemCategory: #'SCFTCategory-Vpfamnrwzqoidbkychxsgujlet'!Smalltalk removeClassNamed: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb!SystemOrganization removeSystemCategory: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!SystemOrganization addCategory: #'SCFTCategory-Mhcizvbpfealtyswxondujrkqg'!Object subclass: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Mhcizvbpfealtyswxondujrkqg'!SystemOrganization addCategory: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!SystemOrganization classify: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb under: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!SystemOrganization classify: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb under: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTuwamifgbzpsjtqhvcyolkerdnx.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Mhcizvbpfealtyswxondujrkqg'!Smalltalk removeClassNamed: #SCFTClassOmcgpfzdlsqrthiujxaknvyewb!SystemOrganization removeSystemCategory: #'SCFTCategory-Piwveocfygqzxradknuthlbmjs'!SystemOrganization addCategory: #'SCFTCategory-Aimrukxzjyhbwdcsqtnpolvegf'!Object subclass: #SCFTClassXjnhwoufczvqprtdkgbeimyasl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Aimrukxzjyhbwdcsqtnpolvegf'!SystemOrganization removeSystemCategory: #'SCFTCategory-Aimrukxzjyhbwdcsqtnpolvegf'!SystemOrganization addCategory: #'SCFTCategory-Rbkasqycixemhgwodjvunzfltp'!Object subclass: #SCFTClassXjnhwoufczvqprtdkgbeimyasl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Rbkasqycixemhgwodjvunzfltp'!Smalltalk removeClassNamed: #SCFTClassXjnhwoufczvqprtdkgbeimyasl!Smalltalk removeClassNamed: #SCFTClassXjnhwoufczvqprtdkgbeimyasl!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTzaqsbcnmfluygwjhtorkedpxiv.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Rbkasqycixemhgwodjvunzfltp'!SystemOrganization addCategory: #'SCFTCategory-Jfrqhgnmaseouwlktybpcdzvxi'!Object subclass: #SCFTClassLmsezuixnkagjptqhoyfbcwdvr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Jfrqhgnmaseouwlktybpcdzvxi'!Smalltalk removeClassNamed: #SCFTClassAnfvwpgoqytmubjehdsxlckrzi!SystemOrganization removeSystemCategory: #'SCFTCategory-Jfrqhgnmaseouwlktybpcdzvxi'!SystemOrganization addCategory: #'SCFTCategory-Kwmcpotqalezbyudrsfghnixvj'!Object subclass: #SCFTClassLmsezuixnkagjptqhoyfbcwdvr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Kwmcpotqalezbyudrsfghnixvj'!Smalltalk renameClassNamed: #SCFTClassLmsezuixnkagjptqhoyfbcwdvr as: #SCFTClassAnfvwpgoqytmubjehdsxlckrzi!Smalltalk renameClassNamed: #SCFTClassLmsezuixnkagjptqhoyfbcwdvr as: #SCFTClassAnfvwpgoqytmubjehdsxlckrzi!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTwkourfnhgvcjyamspdxezqtilb.changes----!Smalltalk removeClassNamed: #SCFTClassAnfvwpgoqytmubjehdsxlckrzi!SystemOrganization removeSystemCategory: #'SCFTCategory-Kwmcpotqalezbyudrsfghnixvj'!SystemOrganization addCategory: #'SCFTCategory-Msrqbfutgzevahxjnckolidpwy'!Object subclass: #SCFTClassMisohueqjlbkrwfvzptgacydxn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Msrqbfutgzevahxjnckolidpwy'!SystemOrganization removeSystemCategory: #'SCFTCategory-Msrqbfutgzevahxjnckolidpwy'!SystemOrganization addCategory: #'SCFTCategory-Knxagbiqsutyzlrcemfpvjowdh'!Object subclass: #SCFTClassMisohueqjlbkrwfvzptgacydxn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Knxagbiqsutyzlrcemfpvjowdh'!Smalltalk removeClassNamed: #SCFTClassMisohueqjlbkrwfvzptgacydxn!Smalltalk removeClassNamed: #SCFTClassMisohueqjlbkrwfvzptgacydxn!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTrjvucqdgnfohmkxstzelpbwayi.changes----!SystemOrganization removeSystemCategory: #'SCFTCategory-Knxagbiqsutyzlrcemfpvjowdh'!SystemOrganization addCategory: #'SCFTCategory-Btlhjycxdqrosaimkvenzpgfwu'!Object subclass: #SCFTClassTedocqypxnuszhfvagijmkrwlb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Btlhjycxdqrosaimkvenzpgfwu'!Smalltalk removeClassNamed: #SCFTClassTedocqypxnuszhfvagijmkrwlb!SystemOrganization removeSystemCategory: #'SCFTCategory-Btlhjycxdqrosaimkvenzpgfwu'!SystemOrganization addCategory: #'SCFTCategory-Mcfsaybgdouhqwtjzlpxvnkeri'!Object subclass: #SCFTClassTedocqypxnuszhfvagijmkrwlb	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Mcfsaybgdouhqwtjzlpxvnkeri'!SCFTClassTedocqypxnuszhfvagijmkrwlb methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!!SCFTClassTedocqypxnuszhfvagijmkrwlb methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorYpbktrhsfdoicluxejqzvwagnm! !----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFThlzdecugaxopvnfbiqjmrysktw.changes----!Smalltalk removeClassNamed: #SCFTClassTedocqypxnuszhfvagijmkrwlb!SystemOrganization removeSystemCategory: #'SCFTCategory-Mcfsaybgdouhqwtjzlpxvnkeri'!SystemOrganization addCategory: #'SCFTCategory-Gbxeqctvwipuomhnjlfzdarksy'!Object subclass: #SCFTClassWbokxysrmtpjenvqfuhcdigzal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Gbxeqctvwipuomhnjlfzdarksy'!!SCFTClassWbokxysrmtpjenvqfuhcdigzal methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorAljsikxpqfmbtdonrywzhcvuge 'ajwbvsdylqfzprxutginemhock'! !Smalltalk removeClassNamed: #SCFTClassWbokxysrmtpjenvqfuhcdigzal!SystemOrganization removeSystemCategory: #'SCFTCategory-Gbxeqctvwipuomhnjlfzdarksy'!SystemOrganization addCategory: #'SCFTCategory-Hdkwatpgxljzyvfmirouecqnsb'!Object subclass: #SCFTClassWbokxysrmtpjenvqfuhcdigzal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Hdkwatpgxljzyvfmirouecqnsb'!!SCFTClassWbokxysrmtpjenvqfuhcdigzal methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorAljsikxpqfmbtdonrywzhcvuge 'krutpsfnqdjgbxcyezhlamvoiw'! !SCFTClassWbokxysrmtpjenvqfuhcdigzal methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35' prior: 33598062!!SCFTClassWbokxysrmtpjenvqfuhcdigzal methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35' prior: 33598646!scftSelectorAljsikxpqfmbtdonrywzhcvuge 'dnjgzwofqsatymrcpehivlkuxb'! !----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTdvkqznemgjrpfbtaywuxlcohsi.changes----!Smalltalk removeClassNamed: #SCFTClassWbokxysrmtpjenvqfuhcdigzal!SystemOrganization removeSystemCategory: #'SCFTCategory-Hdkwatpgxljzyvfmirouecqnsb'!SystemOrganization addCategory: #'SCFTCategory-Rglstcfdvhpaokqinjyxwmubze'!Object subclass: #SCFTClassWdqohkigtzvxmfurpbnjcsyela	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Rglstcfdvhpaokqinjyxwmubze'!!SCFTClassWdqohkigtzvxmfurpbnjcsyela methodsFor: 'scft protocol vwtgxyrzdiasqnuomeckjbfplh' stamp: 'pls 8/13/2015 00:35'!scftSelectorAcmdtqjepksxbvzungliofrwhy! !Smalltalk removeClassNamed: #SCFTClassWdqohkigtzvxmfurpbnjcsyela!SystemOrganization removeSystemCategory: #'SCFTCategory-Rglstcfdvhpaokqinjyxwmubze'!SystemOrganization addCategory: #'SCFTCategory-Hqguyfplbdvoskcjmwnzrxiate'!Object subclass: #SCFTClassWdqohkigtzvxmfurpbnjcsyela	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Hqguyfplbdvoskcjmwnzrxiate'!!SCFTClassWdqohkigtzvxmfurpbnjcsyela methodsFor: 'scft protocol vwtgxyrzdiasqnuomeckjbfplh' stamp: 'pls 8/13/2015 00:35'!scftSelectorAcmdtqjepksxbvzungliofrwhy! !SCFTClassWdqohkigtzvxmfurpbnjcsyela organization classify: #scftSelectorAcmdtqjepksxbvzungliofrwhy under: #'scft protocol epmvbxslqjifnwkadouchgryzt'!SCFTClassWdqohkigtzvxmfurpbnjcsyela organization classify: #scftSelectorAcmdtqjepksxbvzungliofrwhy under: #'scft protocol epmvbxslqjifnwkadouchgryzt'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTvnixpzewjolycqftrkgusbadmh.changes----!Smalltalk removeClassNamed: #SCFTClassWdqohkigtzvxmfurpbnjcsyela!SystemOrganization removeSystemCategory: #'SCFTCategory-Hqguyfplbdvoskcjmwnzrxiate'!SystemOrganization addCategory: #'SCFTCategory-Qfgruphvclyjxtobnziamdweks'!Object subclass: #SCFTClassJcvlduriepozmyfxwaqskbhgtn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Qfgruphvclyjxtobnziamdweks'!!SCFTClassJcvlduriepozmyfxwaqskbhgtn methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorPsgrieczljtxqybadhunvfmokw! !Smalltalk removeClassNamed: #SCFTClassJcvlduriepozmyfxwaqskbhgtn!SystemOrganization removeSystemCategory: #'SCFTCategory-Qfgruphvclyjxtobnziamdweks'!SystemOrganization addCategory: #'SCFTCategory-Fcesyiangrjdhlbokxqtwmvupz'!Object subclass: #SCFTClassJcvlduriepozmyfxwaqskbhgtn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Fcesyiangrjdhlbokxqtwmvupz'!!SCFTClassJcvlduriepozmyfxwaqskbhgtn methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorPsgrieczljtxqybadhunvfmokw! !SCFTClassJcvlduriepozmyfxwaqskbhgtn removeSelector: #scftSelectorPsgrieczljtxqybadhunvfmokw!SCFTClassJcvlduriepozmyfxwaqskbhgtn removeSelector: #scftSelectorPsgrieczljtxqybadhunvfmokw!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTgvniubehtqmoxryldfwapkzscj.changes----!Smalltalk removeClassNamed: #SCFTClassJcvlduriepozmyfxwaqskbhgtn!SystemOrganization removeSystemCategory: #'SCFTCategory-Fcesyiangrjdhlbokxqtwmvupz'!SystemOrganization addCategory: #'SCFTCategory-Xymjtfkzgrvbwoahnsecqdluip'!Object subclass: #SCFTClassIphcnflszmrkutyxwgqjvboead	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Xymjtfkzgrvbwoahnsecqdluip'!Smalltalk removeClassNamed: #SCFTClassIphcnflszmrkutyxwgqjvboead!SystemOrganization removeSystemCategory: #'SCFTCategory-Xymjtfkzgrvbwoahnsecqdluip'!SystemOrganization addCategory: #'SCFTCategory-Ecbjdonzlkafupimyxrgtqhwsv'!Object subclass: #SCFTClassIphcnflszmrkutyxwgqjvboead	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Ecbjdonzlkafupimyxrgtqhwsv'!SCFTClassIphcnflszmrkutyxwgqjvboead organization addCategory: #'scft protocol alvodsmqjkgunthcrxiwybfzep'!SCFTClassIphcnflszmrkutyxwgqjvboead organization addCategory: #'scft protocol alvodsmqjkgunthcrxiwybfzep'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTsnjhcgzlyqbfawvdxtouermipk.changes----!Smalltalk removeClassNamed: #SCFTClassIphcnflszmrkutyxwgqjvboead!SystemOrganization removeSystemCategory: #'SCFTCategory-Ecbjdonzlkafupimyxrgtqhwsv'!SystemOrganization addCategory: #'SCFTCategory-Qwysbhpceuvkdojzimarxftngl'!Object subclass: #SCFTClassXbqznotmsjafduylphrkvciegw	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Qwysbhpceuvkdojzimarxftngl'!Smalltalk removeClassNamed: #SCFTClassXbqznotmsjafduylphrkvciegw!SystemOrganization removeSystemCategory: #'SCFTCategory-Qwysbhpceuvkdojzimarxftngl'!SystemOrganization addCategory: #'SCFTCategory-Jlvmqiacdfotkghxzwrbypuesn'!Object subclass: #SCFTClassXbqznotmsjafduylphrkvciegw	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Jlvmqiacdfotkghxzwrbypuesn'!SCFTClassXbqznotmsjafduylphrkvciegw methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!!SCFTClassXbqznotmsjafduylphrkvciegw methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!scftSelectorLbnpzuohwdxyrvgfcksjeqitam! !----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTydotpxerjkachzbuwfgsivlnqm.changes----!Smalltalk removeClassNamed: #SCFTClassXbqznotmsjafduylphrkvciegw!SystemOrganization removeSystemCategory: #'SCFTCategory-Jlvmqiacdfotkghxzwrbypuesn'!SystemOrganization addCategory: #'SCFTCategory-Mqixkjcnutdylhfrvewpabgzos'!Object subclass: #SCFTClassUmgrsxnithdcbawfqekpjyzlov	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Mqixkjcnutdylhfrvewpabgzos'!SCFTClassUmgrsxnithdcbawfqekpjyzlov organization addCategory: #'scft protocol losqyijgwbhfuctmkzpxendrav'!Smalltalk removeClassNamed: #SCFTClassUmgrsxnithdcbawfqekpjyzlov!SystemOrganization removeSystemCategory: #'SCFTCategory-Mqixkjcnutdylhfrvewpabgzos'!SystemOrganization addCategory: #'SCFTCategory-Jvpiwslretzgubkahcnxmydqof'!Object subclass: #SCFTClassUmgrsxnithdcbawfqekpjyzlov	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Jvpiwslretzgubkahcnxmydqof'!SCFTClassUmgrsxnithdcbawfqekpjyzlov organization addCategory: #'scft protocol losqyijgwbhfuctmkzpxendrav'!SCFTClassUmgrsxnithdcbawfqekpjyzlov organization removeCategory: #'scft protocol losqyijgwbhfuctmkzpxendrav'!SCFTClassUmgrsxnithdcbawfqekpjyzlov organization removeCategory: #'scft protocol losqyijgwbhfuctmkzpxendrav'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTfsijzxkmqyglbauecvrpndtwoh.changes----!Smalltalk removeClassNamed: #SCFTClassUmgrsxnithdcbawfqekpjyzlov!SystemOrganization removeSystemCategory: #'SCFTCategory-Jvpiwslretzgubkahcnxmydqof'!SystemOrganization addCategory: #'SCFTCategory-Cyvsfotmhpjbgdkwnxlieuazqr'!Object subclass: #SCFTClassXhbqzvycgftsaonrwiukpjeldm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Cyvsfotmhpjbgdkwnxlieuazqr'!SCFTClassXhbqzvycgftsaonrwiukpjeldm organization addCategory: #'scft protocol kiwvnqphmtzbauylefdgxsorcj'!Smalltalk removeClassNamed: #SCFTClassXhbqzvycgftsaonrwiukpjeldm!SystemOrganization removeSystemCategory: #'SCFTCategory-Cyvsfotmhpjbgdkwnxlieuazqr'!SystemOrganization addCategory: #'SCFTCategory-Kfxzmbwsqaydhgtecvijpuolnr'!Object subclass: #SCFTClassXhbqzvycgftsaonrwiukpjeldm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SCFTCategory-Kfxzmbwsqaydhgtecvijpuolnr'!SCFTClassXhbqzvycgftsaonrwiukpjeldm organization addCategory: #'scft protocol kiwvnqphmtzbauylefdgxsorcj'!SCFTClassXhbqzvycgftsaonrwiukpjeldm organization renameCategory: #'scft protocol kiwvnqphmtzbauylefdgxsorcj' toBe: #'scft protocol ztkhljvqiwdnubpsyrofacexgm'!SCFTClassXhbqzvycgftsaonrwiukpjeldm organization renameCategory: #'scft protocol kiwvnqphmtzbauylefdgxsorcj' toBe: #'scft protocol ztkhljvqiwdnubpsyrofacexgm'!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/SCFTvbdrofexwhulztmsjgqkaicpyn.changes----!Smalltalk removeClassNamed: #SCFTClassXhbqzvycgftsaonrwiukpjeldm!SystemOrganization removeSystemCategory: #'SCFTCategory-Kfxzmbwsqaydhgtecvijpuolnr'!Player subclass: #Player66	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!Player subclass: #Player67	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!Player subclass: #Player68	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!Player subclass: #UnscriptedPlayer	instanceVariableNames: 'patch'	classVariableNames: ''	poolDictionaries: ''	category: 'Etoys-Scripting'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges commentStamp: '<historical>' prior: 0!Added this comment as part of the unit test in SystemChangeTest>>testClassCommentedBasicEvents. You should never see this, unless you are debugging the system somewhere in between the tests.!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassWhileTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!SystemOrganization classify: #AutoGeneratedClassForTestingSystemChanges under: 'Collections-Abstract'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!SystemOrganization classify: #AutoGeneratedClassForTestingSystemChanges under: #'Collections-Abstract'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Smalltalk renameClassNamed: #AutoGeneratedClassForTestingSystemChanges as: #AutoRenamedClassForTestingSystemChanges!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Model subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!1 + 2!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!testCreation	^1! !Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges methodsFor: 'testing' stamp: 'pls 8/13/2015 00:35'!testCreation	^1! !Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges methodsFor: 'testing' stamp: 'pls 8/13/2015 00:35'!testCreation	^1! !AutoGeneratedClassForTestingSystemChanges organization classify: #testCreation under: #newCategory!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!testCreation	^1! !AutoGeneratedClassForTestingSystemChanges removeSelector: #testCreation!Object subclass: #AutoGeneratedClassForTestingSystemChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #AutoGeneratedClassXForTestingSystemChanges	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!AutoGeneratedClassForTestingSystemChanges methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:35'!testCreation	^1! !AutoGeneratedClassForTestingSystemChanges removeSelector: #testCreation!!Behavior method!thisIsATest  ^ 2! !MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!!MCMockClassB commentStamp: '' prior: 0!This comment has a bang!! Bang!! Bang!!!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21' prior: 17798376!mockClassExtension! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 55330773!variables	^ x + Y + MCMockClassA! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 55331015!variables2	^ ivar + CVar! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 66076104!cVar	^ CVar! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 66076501!initialize	CVar := #initialized! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 66076732!one	^ 1! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32' prior: 66077116!touchCVar	CVar := #touched! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 66075069!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 66075253!b	^ 'b'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 66075437!c	^ 'c'! !!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 66074200!d	^ 'd'! !!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49' prior: 66074385!falsehood	^ false! !!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21' prior: 66074575!moreTruth	^ true! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 66075609!one	^ 1! !!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14' prior: 66074891!q! !!MCMockClassA methodsFor: 'boolean' stamp: '' prior: 66074706!truth	^ true! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 66075783!two	^ 2! !!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21' prior: 84318208!one	^ 1! !!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22' prior: 22736639!two	^ 2! !!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21' prior: 31641018!two	^ 2! !Smalltalk removeClassNamed: #MCMockASubclass!Smalltalk removeClassNamed: #MCMockClassA!Smalltalk removeClassNamed: #MCMockClassB!Smalltalk removeClassNamed: #MCMockClassD!Smalltalk removeClassNamed: #MCMockClassE!Smalltalk removeClassNamed: #MCMockClassF!Smalltalk removeClassNamed: #MCMockClassG!Smalltalk removeClassNamed: #MCMockClassH!Smalltalk removeClassNamed: #MCMockClassI!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!b	^ 'b'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!c	^ 'c'! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 0!two	^ 2! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!c	^ 'c'! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!b	^ 'b'! !!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 0!d	^ 'd'! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33622662!a	^ 'a1'! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33622858!b	^ 'b1'! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33622730!c	^ 'c1'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33622936!d	^ 'd1'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!b	^ 'b'! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33623223!c	^ 'c'! !!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 33623299!d	^ 'd'! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!a	^ 'a'! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33623784!a	^ 'a1'! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33623879!a	^ 'a'! !"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33624101!one	^ 2! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 33624196!one	^ 1! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 0!two	^ 2! !"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33624475!one	^ 2! !!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33624562!two	^ 3! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !!MCMockClassA methodsFor: 'boolean' stamp: '' prior: 0!truth	^ true! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 33624752!two	^ 2! !"MonticelloMocks"!"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 0!two	^ 2! !"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !"MonticelloMocks"!"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33625384!one	^ 2! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 33625499!one	^ 1! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 0!two	^ 2! !"MonticelloMocks"!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !"MonticelloMocks"!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:06 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:06 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:06 am'!ObjectScanner new initialize!----End fileIn of a stream----!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object variableByteSubclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass variableByteSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableByteSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Object variableSubclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: 'TestVar'	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: 'TestVar'	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: 'TestVar'	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!!DummyClassBuilderFormatTestSubClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!subGet ^var! !!DummyClassBuilderFormatTestSubClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!subSet: v var := v! !Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!!DummyClassBuilderFormatTestSuperClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!superGet ^var! !!DummyClassBuilderFormatTestSuperClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!superSet: v var := v! !DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!!DummyClassBuilderFormatTestSuperClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!superGet ^var! !!DummyClassBuilderFormatTestSuperClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!superSet: v var := v! !DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!!DummyClassBuilderFormatTestSubClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!subGet ^var! !!DummyClassBuilderFormatTestSubClass methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!subSet: v var := v! !DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass removeSelector: #superGet!DummyClassBuilderFormatTestSuperClass removeSelector: #superSet:!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var3 var4'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableByteSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableWordSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object subclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: 'var1 var2'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass subclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var3 var4'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object variableSubclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var3 var4'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object weakSubclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: 'var3 var4'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass weakSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization addCategory: #'Dummy-Tests-ClassBuilder'!Object variableWordSubclass: #DummyClassBuilderFormatTestSuperClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!DummyClassBuilderFormatTestSuperClass variableWordSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!DummyClassBuilderFormatTestSuperClass variableWordSubclass: #DummyClassBuilderFormatTestSubClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-ClassBuilder'!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSubClass!Smalltalk removeClassNamed: #DummyClassBuilderFormatTestSuperClass!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!SystemOrganization removeSystemCategory: 'Dummy-Tests-ClassBuilder'!Object subclass: #Victim	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 1! !!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar ^ 1! !Object subclass: #Victim	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 1! !!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar ^ 1! !Victim removeSelector: #bar!Object subclass: #Victim	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 1! !!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33641765!foo ^ 2! !!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33641864!foo ^ 1! !Object subclass: #Victim	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Victim methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 1! !Victim removeSelector: #foo!SystemOrganization addCategory: #ReferencedClassRemoveTest!Object subclass: #ClassToBeRemoved	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ReferencedClassRemoveTest'!Smalltalk removeClassNamed: #ClassToBeRemoved!SystemOrganization removeSystemCategory: 'ReferencedClassRemoveTest'!SystemOrganization addCategory: #ReferencedClassRemoveTest!Object subclass: #ClassToBeRemoved	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ReferencedClassRemoveTest'!Object subclass: #ReferringClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ReferencedClassRemoveTest'!!ReferringClass methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^ClassToBeRemoved! !Smalltalk removeClassNamed: #ClassToBeRemoved!Object subclass: #ClassToBeRemoved	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ReferencedClassRemoveTest'!Smalltalk removeClassNamed: #ClassToBeRemoved!Smalltalk removeClassNamed: #ReferringClass!SystemOrganization removeSystemCategory: 'ReferencedClassRemoveTest'!!Trait method!m11 ^11! !T2 organization classify: #m11 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !T2 organization classify: #m13 under: #cat3!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!aliasM11 ^11! !T2 organization classify: #aliasM11 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!aliasM11 ^11! !T4 organization classify: #aliasM11 under: #'as yet unclassified'!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!aliasM11 ^11! !T5 organization classify: #aliasM11 under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!aliasM11 ^11! !C2 organization classify: #aliasM11 under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!aliasM11 ^11! !T6 organization classify: #aliasM11 under: #'as yet unclassified'!!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m12 ^12! !T2 organization classify: #m12 under: #cat2!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!= anObject! !!Trait method!m11 ^11! !!Trait method!= anObject! !T2 organization classify: #= under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!= anObject! !T4 organization classify: #= under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !T5 organization classify: #= under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!= anObject! !C2 organization classify: #= under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !T6 organization classify: #= under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!aliasM11 ^11! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!aliasM11 ^11! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!m12 ^12! !!Trait method!equals: anObject! !T2 organization classify: #equals: under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!equals: anObject! !T4 organization classify: #equals: under: #'as yet unclassified'!!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!equals: anObject! !T5 organization classify: #equals: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!equals: anObject! !C2 organization classify: #equals: under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!equals: anObject! !T6 organization classify: #equals: under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !T2 removeSelector: #aliasM11!!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T4 removeSelector: #aliasM11!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #aliasM11!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 removeSelector: #aliasM11!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T6 removeSelector: #aliasM11!!Trait method!m2ClassSide: a ^a! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!% anObject! !T2 organization classify: #% under: #'as yet unclassified'!!Trait method!% anObject! !T4 organization classify: #% under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!% anObject! !T5 organization classify: #% under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!% anObject! !C2 organization classify: #% under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!% anObject! !T6 organization classify: #% under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !T2 removeSelector: #equals:!!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T4 removeSelector: #equals:!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #equals:!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 removeSelector: #equals:!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T6 removeSelector: #equals:!!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!x: a y: b z: c! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!% anObject! !!Trait method!m12 ^12! !!Trait method!x: a y: b z: c! !T2 organization classify: #x:y:z: under: #'as yet unclassified'!!Trait method!x: a y: b z: c! !T4 organization classify: #x:y:z: under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !T5 organization classify: #x:y:z: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!x: a y: b z: c! !C2 organization classify: #x:y:z: under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !T6 organization classify: #x:y:z: under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!% anObject! !!Trait method!m12 ^12! !!Trait method!x: a y: b z: c! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m13 ^self m12! !!Trait method!myX: a y: b z: c! !T2 organization classify: #myX:y:z: under: #'as yet unclassified'!!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!myX: a y: b z: c! !T4 organization classify: #myX:y:z: under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!myX: a y: b z: c! !T5 organization classify: #myX:y:z: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!myX: a y: b z: c! !C2 organization classify: #myX:y:z: under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!myX: a y: b z: c! !T6 organization classify: #myX:y:z: under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m12 ^12! !!Trait method!x: a y: b z: c! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !T2 removeSelector: #%!!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !T4 removeSelector: #%!!Trait method!m2ClassSide: a ^a! !!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #%!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 removeSelector: #%!!Trait method!x: a y: b z: c! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!= anObject! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !T6 removeSelector: #%!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !SystemOrganization classify: #TraitsTestTraitWithConflict under: #'TraitsTests-Kernel'!!Trait method!m13 ^self m12! !TraitsTestTraitWithConflict organization classify: #m13 under: #cat3!!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !TraitsTestTraitWithConflict organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !TraitsTestTraitWithConflict organization classify: #m22 under: #cat2!!Trait method!m21 ^21! !TraitsTestTraitWithConflict organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !TraitsTestTraitWithConflict organization classify: #m12 under: #cat2!!Trait method!m42 ^42! !TraitsTestTraitWithConflict organization classify: #m42 under: #cat2!!Trait method!m2ClassSide: a ^a! !TraitsTestTraitWithConflict classTrait organization classify: #m2ClassSide: under: #'as yet unclassified'!Trait named: #TraitsTestTraitWithConflict	uses: T1 + T4	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #TraitsTestTraitWithConflict!SystemOrganization addCategory: #'Dummy-Tests-Class'!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar self foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!baz self bar! !Object subclass: #TUTU	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!Object subclass: #TUTU	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!SystemOrganization removeSystemCategory: 'Dummy-Tests-Class'!SystemOrganization addCategory: #'Dummy-Tests-Class'!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar self foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!baz self bar! !SystemOrganization removeSystemCategory: 'Dummy-Tests-Class'!SystemOrganization addCategory: #'Dummy-Tests-Class'!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar self foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!baz self bar! !SystemOrganization removeSystemCategory: 'Dummy-Tests-Class'!SystemOrganization addCategory: #'Dummy-Tests-Class'!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar self foo! !!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!baz self bar! !!TUTU class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!dummyMeth! !Smalltalk renameClassNamed: #TUTU as: #RenamedTUTU!SystemOrganization removeSystemCategory: 'Dummy-Tests-Class'!!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!array ^ #(nil true false)! !ArrayLiteralTest removeSelector: #array!!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!array ^ #(#nil #true #false #'nil' #'true' #'false')! !ArrayLiteralTest removeSelector: #array!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!plonk ^ Plonk! !Smalltalk removeClassNamed: #Griffle!Smalltalk removeClassNamed: #Plonk!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Smalltalk renameClassNamed: #Griffle as: #Plonk!Smalltalk removeClassNamed: #Plonk!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Smalltalk renameClassNamed: #Griffle as: #Plonk!Smalltalk removeClassNamed: #Plonk!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!doStore	| expr result | 	expr := Object new.  	result := Plonk := expr. 	^ { expr. result }! !Smalltalk removeClassNamed: #Griffle!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!doStore	| expr result | 	expr := Object new.  	result := Plonk := expr. 	^ { expr. result }! !Smalltalk removeClassNamed: #Griffle!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33678215!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33678305!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33678394!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33678476!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33678614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33679095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33679201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33679306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33679404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33679614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33680095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33680201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33680306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33680404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33680614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33681095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33681201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33681306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33681404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33681614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33682095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33682201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33682306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33682404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33682614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33683095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33683201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33683306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33683404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33683614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33684095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33684201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33684306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33684404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33684614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33685095!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33685201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33685306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33685404!foo ^ 2! !Trait named: #TGriffle	uses: #()	category: 'nil'!SystemOrganization classify: #TGriffle under: #Traits!!TGriffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33685614!baz ^ Griffle new foo + Plonk new bar! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!SystemOrganization renameCategory: #'Tests-Monticello-Mocks' toBe: 'Renamed-Tests-Monticello-Mocks'!SystemOrganization renameCategory: 'Renamed-Tests-Monticello-Mocks' toBe: 'Tests-Monticello-Mocks'!SystemOrganization renameCategory: #'Tests-Monticello-Mocks' toBe: 'Tests-Monticello-Mocks-Renamed'!SystemOrganization renameCategory: 'Tests-Monticello-Mocks-Renamed' toBe: 'Tests-Monticello-Mocks'!!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 56492675!cFailedCall	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'CFailModule'>"	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 33687272!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 56490621!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 56491110!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33687674!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33687865!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 33687491!cFailedCall	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'CFailModule'>"	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 33688400!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33688229!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33688076!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33689013!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33688802!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 33688619!cFailedCall	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'CFailModule'>"	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:48' prior: 33689528!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33689204!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33689357!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33690121!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33689930!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33690505!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33690332!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33690658!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33690849!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691213!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691060!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691386!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691597!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691961!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33691788!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33692114!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33692305!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33692669!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33692516!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33692842!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693053!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693417!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693244!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693570!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693761!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33694125!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33693972!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33694298!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33694509!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33694873!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695026!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695217!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695370!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695561!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33694700!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695714!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33695905!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696116!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696269!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696442!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696633!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:49' prior: 56493722!cRealExternalCallOrPrimitiveFailed	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'LargeIntegers'>"	self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 20:49' prior: 33697168!cRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'>	self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696844!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33696997!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33697630!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33697821!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698032!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698358!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698549!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698185!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698893!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33698702!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33699104!cExternalCall2		"{prim disabled by PCCByCompilation} <primitive:'prim2'module:'CPCCT'>"		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33699277!cExternalCall1	"{prim disabled by PCCByCompilation} <primitive: 'prim1' module: 'CPCCT'>"! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33699430!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'sr 6/15/2004 20:49' prior: 33699641!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !SystemOrganization addCategory: #'Dummy-Tests-Class'!Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !Object subclass: #ClassVarScopeParent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeParent subclass: #ClassVarScopeChild	instanceVariableNames: ''	classVariableNames: 'ClassVarScopeFoo'	poolDictionaries: ''	category: 'Dummy-Tests-Class'!ClassVarScopeChild subclass: #ClassVarScopeGrandchild	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Dummy-Tests-Class'!!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentGetFoo	^ClassVarScopeFoo! !!ClassVarScopeParent class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!parentSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childGetFoo	^ClassVarScopeFoo! !!ClassVarScopeChild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!childSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildGetFoo	^ClassVarScopeFoo! !!ClassVarScopeGrandchild class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!grandchildSetFoo: anObject	ClassVarScopeFoo := anObject! !SystemOrganization addCategory: 'Tests-MonticelloMocks'!SystemOrganization addCategory: 'Tests-MonticelloMocks'!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21' prior: 33619673!mockClassExtension! !MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 66073963!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33619790!variables	^ x + Y + MCMockClassA! !MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33619922!variables2	^ ivar + CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33620051!cVar	^ CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33620167!initialize	CVar := #initialized! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33620301!one	^ 1! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32' prior: 33620414!touchCVar	CVar := #touched! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33623975!a	^ 'a'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!b	^ 'b'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33623511!c	^ 'c'! !MCMockClassA methodsFor: 'as yet classified' stamp: ''!!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 33623596!d	^ 'd'! !MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49' prior: 33620837!falsehood	^ false! !MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21' prior: 33620939!moreTruth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14' prior: 33621142!q! !MCMockClassA methodsFor: 'boolean' stamp: ''!!MCMockClassA methodsFor: 'boolean' stamp: '' prior: 33624906!truth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 33625679!two	^ 2! !MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB commentStamp: '' prior: 0!!MCMockClassB commentStamp: '' prior: 31640817!This comment has a bang!! Bang!! Bang!!!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21' prior: 33621617!two	^ 2! !Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21' prior: 33621414!one	^ 1! !Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22' prior: 33621525!two	^ 2! !Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA initialize!----End fileIn of a ReadStream----!SystemOrganization addCategory: 'Tests-MonticelloMocks'!SystemOrganization addCategory: 'Tests-MonticelloMocks'!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21' prior: 33721431!mockClassExtension! !MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 33721880!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33722472!variables	^ x + Y + MCMockClassA! !MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33722683!variables2	^ ivar + CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33722896!cVar	^ CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33723096!initialize	CVar := #initialized! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33723312!one	^ 1! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32' prior: 33723509!touchCVar	CVar := #touched! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33723650!a	^ 'a'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33723765!b	^ 'b'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33723887!c	^ 'c'! !MCMockClassA methodsFor: 'as yet classified' stamp: ''!!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 33724029!d	^ 'd'! !MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49' prior: 33724189!falsehood	^ false! !MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21' prior: 33724355!moreTruth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14' prior: 33724688!q! !MCMockClassA methodsFor: 'boolean' stamp: ''!!MCMockClassA methodsFor: 'boolean' stamp: '' prior: 33724803!truth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 33724968!two	^ 2! !MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB commentStamp: '' prior: 0!!MCMockClassB commentStamp: '' prior: 33725466!This comment has a bang!! Bang!! Bang!!!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21' prior: 33725704!two	^ 2! !Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21' prior: 33726171!one	^ 1! !Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22' prior: 33726665!two	^ 2! !Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA initialize!----End fileIn of a ReadStream----!MCMockClassB removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassB!Smalltalk removeClassNamed: #MCMockClassI!Smalltalk removeClassNamed: #MCMockClassH!Smalltalk removeClassNamed: #MCMockClassG!Smalltalk removeClassNamed: #MCMockClassF!MCMockClassE class removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassE!MCMockClassD removeSelector: #one!Smalltalk removeClassNamed: #MCMockClassD!MCMockClassA removeSelector: #two!MCMockClassA removeSelector: #truth!MCMockClassA removeSelector: #q!MCMockClassA removeSelector: #one!MCMockClassA removeSelector: #moreTruth!MCMockClassA removeSelector: #falsehood!MCMockClassA removeSelector: #d!MCMockClassA removeSelector: #c!MCMockClassA removeSelector: #b!MCMockClassA removeSelector: #a!MCMockClassA class removeSelector: #touchCVar!MCMockClassA class removeSelector: #one!MCMockClassA class removeSelector: #initialize!MCMockClassA class removeSelector: #cVar!MCMockASubclass removeSelector: #variables2!MCMockASubclass removeSelector: #variables!Smalltalk removeClassNamed: #MCMockASubclass!Smalltalk removeClassNamed: #MCMockClassA!MCSnapshotTest removeSelector: #mockClassExtension!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!!MCMockClassB commentStamp: '' prior: 0!This comment has a bang!! Bang!! Bang!!!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!mockClassExtension! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables	^ x + Y + MCMockClassA! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables2	^ ivar + CVar! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!cVar	^ CVar! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!initialize	CVar := #initialized! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!one	^ 1! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!touchCVar	CVar := #touched! !!MCMockClassA methodsFor: 'numeric'!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric'!b	^ 'b'! !!MCMockClassA methodsFor: 'numeric'!c	^ 'c'! !!MCMockClassA methodsFor: 'as yet classified'!d	^ 'd'! !!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!falsehood	^ false! !!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!moreTruth	^ true! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!one	^ 1! !!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!q! !!MCMockClassA methodsFor: 'boolean'!truth	^ true! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!two	^ 2! !!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!one	^ 1! !!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!two	^ 2! !!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!two	^ 2! !!T1 classTrait methodsFor: 'mycategory' stamp: 'pls 8/13/2015 00:36'!m1ClassSide ^17! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !T4 classTrait organization classify: #m1ClassSide under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !T5 classTrait organization classify: #m1ClassSide under: #'as yet unclassified'!!Trait method!m1ClassSide ^17! !C2 class organization classify: #m1ClassSide under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !T6 classTrait organization classify: #m1ClassSide under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide ^17! !!T2 classTrait methodsFor: 'mycategory' stamp: 'pls 8/13/2015 00:36'!m1ClassSide! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !T4 classTrait organization classify: #m1ClassSide under: #'conflict methods'!T4 classTrait organization removeCategory: #mycategory!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !T5 classTrait organization classify: #m1ClassSide under: #'conflict methods'!!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !T5 classTrait organization removeCategory: #mycategory!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !T6 classTrait organization classify: #m1ClassSide under: #'conflict methods'!T6 classTrait organization removeCategory: #mycategory!!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m1ClassSide	"This method has a trait conflict"	^self traitConflict! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 classTrait methodsFor: 'mycategory' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: x ^99! !!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !T4 classTrait organization classify: #m2ClassSide: under: #'conflict methods'!!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !T5 classTrait organization classify: #m2ClassSide: under: #'conflict methods'!!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !T6 classTrait organization classify: #m2ClassSide: under: #'conflict methods'!!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: x ^99! !T5 classTrait organization classify: #m2ClassSide: under: #mycategory!!Trait method!m2ClassSide: x ^99! !C2 class organization classify: #m2ClassSide: under: #mycategory!!Trait method!m2ClassSideAlias1: x ^99! !T5 classTrait organization classify: #m2ClassSideAlias1: under: #mycategory!!Trait method!m2ClassSideAlias1: x ^99! !C2 class organization classify: #m2ClassSideAlias1: under: #'as yet unclassified'!!Trait method!m2ClassSideAlias2: a ^a! !T5 classTrait organization classify: #m2ClassSideAlias2: under: #'as yet unclassified'!!Trait method!m2ClassSideAlias2: a ^a! !C2 class organization classify: #m2ClassSideAlias2: under: #'as yet unclassified'!T5 classTrait organization removeCategory: #'conflict methods'!T5 classTrait	uses: T1 classTrait @ {#m2ClassSideAlias1:->#m2ClassSide:} + T2 classTrait @ {#m2ClassSideAlias2:->#m2ClassSide:} - {#m2ClassSide:}!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !C2 organization classify: #m11 under: #cat1!!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !C2 removeSelector: #m12!C2 removeSelector: #m53!C2 removeSelector: #m11!C2 removeSelector: #m13!C2 organization removeCategory: #cat3!C2 removeSelector: #m51!C2 removeSelector: #m52!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.extSeg----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.ref----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.extSeg----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.ref----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.extSeg----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.ref----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.extSeg----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:23 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:24 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:24 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.ref----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:24 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.extSeg----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:24 am'!ObjectScanner new initialize!----End fileIn of a stream----!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:36:24 am'!ObjectScanner new initialize!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/bitmapStreamTest.ref----!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T4 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T5 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !C2 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T6 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork1: myArgument zork2: somethingElse ^false! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T4 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33763840!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33766084!zork1: somethingElse zork2: myArgument ^false! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !T2 organization classify: #m22 under: #catX!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !T4 organization classify: #m22 under: #catX!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !T5 organization classify: #m22 under: #catX!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 organization classify: #m22 under: #catX!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !T6 organization classify: #m22 under: #catX!!Trait method!m22Alias ^22! !T6 organization classify: #m22Alias under: #catX!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !T6 organization classify: #m22 under: #catY!T6 organization classify: #m22Alias under: #catY!T2 organization classify: #m22 under: #catZ!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !T4 organization classify: #m22 under: #catZ!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !T5 organization classify: #m22 under: #catZ!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 organization classify: #m22 under: #catZ!C2 organization removeCategory: #catX!!Trait method!m12 ^12! !!Trait method!m21 ^21! !T5 organization removeCategory: #catX!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !T6 organization classify: #m22 under: #catZ!!Trait method!m22Alias ^22! !T6 organization classify: #m22Alias under: #catZ!!Trait method!m21 ^21! !!Trait method!m12 ^12! !T6 organization removeCategory: #catY!!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'catA' stamp: 'pls 8/13/2015 00:36'!mA! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!mA! !T4 organization classify: #mA under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!mA! !T5 organization classify: #mA under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!mA! !C2 organization classify: #mA under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!mA! !T6 organization classify: #mA under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!mA! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!mA! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!mA! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !T1 organization classify: #mA under: #cat1!!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!mA! !T4 organization classify: #mA under: #cat1!T4 organization removeCategory: #catA!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!mA! !T5 organization classify: #mA under: #cat1!!Trait method!m51 ^super foo! !C2 organization classify: #mA under: #cat1!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 organization removeCategory: #catA!!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !T5 organization removeCategory: #catA!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!mA! !T6 organization classify: #mA under: #cat1!!Trait method!m21 ^21! !T6 organization removeCategory: #catA!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m12 ^false! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !T4 organization classify: #m12 under: #'conflict methods'!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #m12 under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #m12 under: #'conflict methods'!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!@ myArgument ^true! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ myArgument ^true! !T4 organization classify: #@ under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ myArgument ^true! !T5 organization classify: #@ under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!@ myArgument ^true! !C2 organization classify: #@ under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!@ myArgument ^true! !T6 organization classify: #@ under: #'as yet unclassified'!!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ myArgument ^true! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ myArgument ^true! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!@ myArgument ^true! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!@myArgument ^false! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !T4 organization classify: #@ under: #'conflict methods'!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #@ under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #@ under: #'conflict methods'!!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork: myArgument		^true! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: myArgument		^true! !T4 organization classify: #zork: under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: myArgument		^true! !T5 organization classify: #zork: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!zork: myArgument		^true! !C2 organization classify: #zork: under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: myArgument		^true! !T6 organization classify: #zork: under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: myArgument		^true! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: myArgument		^true! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: myArgument		^true! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork: myArgument ^false! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !T4 organization classify: #zork: under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #zork: under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #zork: under: #'conflict methods'!!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33793611!zork:myArgument ^true! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33796453!zork:myArgument ^false! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T4 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T5 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !C2 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !T6 organization classify: #zork1:zork2: under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: myArgument zork2: mySecondArgument ^true! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork1: anObject zork2: anotherObject ^false! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T4 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #zork1:zork2: under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork: arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!m11 ^11! !!Trait method!@ arg1	"This method has a trait conflict"	^self traitConflict! !!Trait method!zork1: arg1 zork2: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T2 methodsFor: 'catY' stamp: 'pls 8/13/2015 00:36'!m11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #m11 under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !SystemOrganization classify: #T7 under: #'TraitsTests-Kernel'!!Trait method!m13 ^self m12! !T7 organization classify: #m13 under: #cat3!!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T7 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !T7 organization classify: #m22 under: #cat2!!Trait method!m21 ^21! !T7 organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !T7 organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !T7 classTrait organization classify: #m2ClassSide: under: #'as yet unclassified'!Trait named: #T7	uses: T1 + T2	category: 'TraitsTests-Kernel'!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m11! !T5 organization classify: #m11 under: #catY!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T5 organization removeCategory: #'conflict methods'!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m11! !T6 organization classify: #m11 under: #catY!!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !T6 organization removeCategory: #'conflict methods'!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m11! !T7 organization classify: #m11 under: #catY!!Trait method!m21 ^21! !!Trait method!m12 ^12! !T7 organization removeCategory: #'conflict methods'!!Trait method!m2ClassSide: a ^a! !T1 removeSelector: #m11!!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T5 organization classify: #m11 under: #'conflict methods'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T5 organization removeCategory: #catY!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T6 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !T6 organization removeCategory: #catY!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T7 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !T7 organization removeCategory: #catY!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !SystemOrganization classify: #T8 under: #'TraitsTests-Kernel'!!Trait method!m13 ^self m12! !T8 organization classify: #m13 under: #cat3!!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T8 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !T8 organization classify: #m22 under: #cat2!!Trait method!m21 ^21! !T8 organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !T8 organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !T8 classTrait organization classify: #m2ClassSide: under: #'as yet unclassified'!Trait named: #T8	uses: T1 + T2	category: 'TraitsTests-Kernel'!T8 organization classify: #m11 under: #cat1!T1 organization classify: #m11 under: #catZ!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11	"This method has a trait conflict"	^self traitConflict! !T8 organization classify: #m11 under: #'conflict methods'!!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Smalltalk removeClassNamed: #T7!Smalltalk removeClassNamed: #T8!!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 55276155!override ^ 1! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33824623!override ^ 1! !!MCMockClassA methodsFor: 'as yet unclassified' stamp: '' prior: 33738824!one ^2! !MCMockClassA removeSelector: #one!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!one	^ 1! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33824729!override ^ 1! !!MCMethodDefinitionTest methodsFor: '*foobarbaz' stamp: 'pls 8/13/2015 00:36' prior: 33825033!override ^ 2! !!MCMethodDefinitionTest methodsFor: '*monticellomocks-override' stamp: 'pls 8/13/2015 00:36' prior: 33825144!override ^ 3! !!MCMethodDefinitionTest methodsFor: '*monticellomocks-override' stamp: 'pls 8/13/2015 00:36' prior: 33825270!override ^ 4! !!MCMethodDefinitionTest methodsFor: '*foobarbaz' stamp: 'pls 8/13/2015 00:36' prior: 33825396!override ^ 2! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33825507!override ^ 1! !!Object methodsFor: '*monticellomocks-override' stamp: 'pls 8/13/2015 00:36' prior: 66584172!yourself ^ self! !!Object methodsFor: 'accessing' stamp: 'md 5/16/2006 12:34' prior: 33825723!yourself	"Answer self."	^self! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33825613!override ^ 1! !!MCMethodDefinitionTest methodsFor: '*foobarbaz-override' stamp: 'pls 8/13/2015 00:36' prior: 33825944!override ^ 2! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33826064!override ^ 1! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'cwp 11/7/2004 17:09' prior: 33826170!override ^ 1! !Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!Object subclass: #TUTU	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KernelTests-Methods'!!TUTU methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^ 10! !Smalltalk removeClassNamed: #TUTU!SystemChangeTestRoot subclass: #SystemChangeErrorHandling	instanceVariableNames: 'capturedEvents'	classVariableNames: ''	poolDictionaries: ''	category: 'SystemChangeNotification-Tests'!SystemChangeTestRoot subclass: #SystemChangeErrorHandling	instanceVariableNames: 'capturedEvents'	classVariableNames: ''	poolDictionaries: ''	category: 'SystemChangeNotification-Tests'!SystemChangeTestRoot subclass: #SystemChangeErrorHandling	instanceVariableNames: 'capturedEvents'	classVariableNames: ''	poolDictionaries: ''	category: 'SystemChangeNotification-Tests'!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 0!a	^ 'a'! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 0!one	^ 1! !!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !Object subclass: #X	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Object subclass: #X	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !X subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !X subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!X methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^17! !!C2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33833940!m51 ^19! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C1 subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C1 subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Smalltalk removeClassNamed: #X!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m22 ^22! !C1 organization classify: #m22 under: #cat2!!Trait method!m11 ^11! !C1 organization classify: #m11 under: #cat1!!Trait method!m13 ^self m12! !C1 organization classify: #m13 under: #cat3!!Trait method!m22Alias ^22! !C1 organization classify: #m22Alias under: #'as yet unclassified'!!Trait method!m21 ^21! !C1 organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !C1 organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !C1 class organization classify: #m2ClassSide: under: #'as yet unclassified'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m22 ^22! !C1 organization classify: #m22 under: #cat2!!Trait method!m11 ^11! !C1 organization classify: #m11 under: #cat1!!Trait method!m13 ^self m12! !C1 organization classify: #m13 under: #cat3!!Trait method!m22Alias ^22! !C1 organization classify: #m22Alias under: #'as yet unclassified'!!Trait method!m21 ^21! !C1 organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !C1 organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !C1 class organization classify: #m2ClassSide: under: #'as yet unclassified'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !C2 removeSelector: #m51!T5 removeSelector: #m51!!T5 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33848132!m52 ^self! !!Trait method!m52 ^self! !!Trait method!m53 ^ self class bar! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!local2 ^self! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !T4 organization classify: #local2 under: #'as yet unclassified'!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !T6 organization classify: #local2 under: #'as yet unclassified'!!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !T5 organization classify: #local2 under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!local2 ^self! !C2 organization classify: #local2 under: #'as yet unclassified'!!Trait method!m52 ^self! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^self! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!local2 ^self! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^self! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 methodsFor: 'category1' stamp: 'pls 8/13/2015 00:36'!m1! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1! !T4 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m1! !T5 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m1! !C2 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1! !T6 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m1! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !T1 organization classify: #m1 under: #category2!!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1! !T4 organization classify: #m1 under: #category2!T4 organization removeCategory: #category1!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m1! !T5 organization classify: #m1 under: #category2!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !C2 organization classify: #m1 under: #category2!!Trait method!m52 ^ self class bar! !C2 organization removeCategory: #category1!!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !T5 organization removeCategory: #category1!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1! !T6 organization classify: #m1 under: #category2!!Trait method!m21 ^21! !T6 organization removeCategory: #category1!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!SystemOrganization classify: #TraitsTestTrait under: #'TraitsTests-Kernel'!Trait named: #TraitsTestTrait	uses: #()	category: 'TraitsTests-Kernel'!!TraitsTestTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m11 ^999! !!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m12 ^12! !TraitsTestTrait organization classify: #m12 under: #cat2!!Trait method!m13 ^self m12! !TraitsTestTrait organization classify: #m13 under: #cat3!Trait named: #TraitsTestTrait	uses: T1	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #TraitsTestTrait!!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!zork ^false! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!zork ^false! !T4 organization classify: #zork under: #'as yet unclassified'!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork ^false! !T5 organization classify: #zork under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!zork ^false! !C2 organization classify: #zork under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!zork ^false! !T6 organization classify: #zork under: #'as yet unclassified'!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork ^false! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!zork ^false! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!zork ^false! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!zork ^false! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m21 ^21! !T4 removeSelector: #m12!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m21 ^21! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #m12!!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 removeSelector: #m12!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!zork ^false! !!Trait method!m21 ^21! !T6 removeSelector: #m12!!Trait method!m2ClassSide: a ^a! !T1 removeSelector: #m12!!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33863910!m21 ^99! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m21 ^99! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!zork ^false! !!Trait method!m21 ^99! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m21 ^99! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!zork ^false! !!Trait method!m21 ^99! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !Object subclass: #TraitsTestAliasTestClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!m22 ^22! !TraitsTestAliasTestClass organization classify: #m22 under: #cat2!!Trait method!m11 ^11! !TraitsTestAliasTestClass organization classify: #m11 under: #cat1!!Trait method!m13 ^self m12! !TraitsTestAliasTestClass organization classify: #m13 under: #cat3!!Trait method!m22Alias ^22! !TraitsTestAliasTestClass organization classify: #m22Alias under: #'as yet unclassified'!!Trait method!m21 ^21! !TraitsTestAliasTestClass organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !TraitsTestAliasTestClass organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !TraitsTestAliasTestClass class organization classify: #m2ClassSide: under: #'as yet unclassified'!Object subclass: #TraitsTestAliasTestClass	uses: T6	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33873948!m22 ^17! !!Trait method!m13 ^self m12! !!Trait method!m22 ^17! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^17! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^17! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^17! !!Trait method!m22Alias ^17! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^17! !!Trait method!m22Alias ^17! !!Trait method!m13 ^self m12! !!Trait method!m22 ^17! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^17! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^17! !!Trait method!m22Alias ^17! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !T4 removeSelector: #m22!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #m22!!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !C2 removeSelector: #m22!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !T6 removeSelector: #m22!T6 removeSelector: #m22Alias!!Trait method!m2ClassSide: a ^a! !TraitsTestAliasTestClass removeSelector: #m22Alias!TraitsTestAliasTestClass organization removeCategory: #'as yet unclassified'!T2 removeSelector: #m22!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Smalltalk removeClassNamed: #TraitsTestAliasTestClass!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !Object subclass: #TraitsTestAliasTestClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!aliasM11 ^11! !TraitsTestAliasTestClass organization classify: #aliasM11 under: #cat1!!Trait method!m12 ^12! !TraitsTestAliasTestClass organization classify: #m12 under: #cat2!!Trait method!m13 ^self m12! !TraitsTestAliasTestClass organization classify: #m13 under: #cat3!Object subclass: #TraitsTestAliasTestClass	uses: T1 @ {#aliasM11->#m11} - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33883872!m11 ^17! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^17! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^17! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!aliasM11 ^17! !!Trait method!m12 ^12! !!Trait method!m13 ^self m12! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Smalltalk removeClassNamed: #TraitsTestAliasTestClass!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #m21!!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !T5 removeSelector: #m22!!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !C2 removeSelector: #m22!Trait named: #T5	uses: T1 + T2 - {#m21. #m22}	category: 'TraitsTests-Kernel'!!Trait method!m32 ^32! !T2 organization classify: #m32 under: #cat2!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m32 ^32! !T4 organization classify: #m32 under: #cat2!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m32 ^32! !T6 organization classify: #m32 under: #cat2!!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m32 ^32! !T5 organization classify: #m32 under: #cat2!!Trait method!m52 ^ self class bar! !!Trait method!m32 ^32! !C2 organization classify: #m32 under: #cat2!!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m33 ^33! !T2 organization classify: #m33 under: #cat3!!Trait method!m33 ^33! !T4 organization classify: #m33 under: #cat3!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m33 ^33! !T6 organization classify: #m33 under: #cat3!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m33 ^33! !T5 organization classify: #m33 under: #cat3!!Trait method!m51 ^super foo! !!Trait method!m33 ^33! !C2 organization classify: #m33 under: #cat3!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m31 ^31! !T2 organization classify: #m31 under: #cat1!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m31 ^31! !T4 organization classify: #m31 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m31 ^31! !T6 organization classify: #m31 under: #cat1!!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m31 ^31! !T5 organization classify: #m31 under: #cat1!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m31 ^31! !C2 organization classify: #m31 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !Trait named: #T2	uses: T3	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!C2 methodsFor: 'xxx' stamp: 'pls 8/13/2015 00:36' prior: 33903598!m12 ^0! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !C2 organization classify: #m12 under: #cat2!!Trait method!m52 ^ self class bar! !C2 removeSelector: #m12!!T5 methodsFor: 'xxx' stamp: 'pls 8/13/2015 00:36' prior: 33903112!m12 ^0! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !T5 organization classify: #m12 under: #cat2!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !C2 organization classify: #m12 under: #cat2!!Trait method!m52 ^ self class bar! !C2 organization removeCategory: #xxx!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #m12!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C1 subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: 'foobar'	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C1 subclass: #C2	uses: T5 - {#m11}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !T6 removeSelector: #m12!T6 removeSelector: #m11!T6 removeSelector: #m13!T6 organization removeCategory: #cat3!T6 removeSelector: #m22Alias!!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !T6 organization classify: #m13 under: #cat3!!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m13Alias ^self m12! !T6 organization classify: #m13Alias under: #cat3!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m32 ^32! !T2 organization classify: #m32 under: #cat2!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m32 ^32! !T4 organization classify: #m32 under: #cat2!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m32 ^32! !T5 organization classify: #m32 under: #cat2!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m32 ^32! !C2 organization classify: #m32 under: #cat2!!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m32 ^32! !T6 organization classify: #m32 under: #cat2!!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m33 ^33! !T2 organization classify: #m33 under: #cat3!!Trait method!m33 ^33! !T4 organization classify: #m33 under: #cat3!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m33 ^33! !T5 organization classify: #m33 under: #cat3!!Trait method!m51 ^super foo! !!Trait method!m33 ^33! !C2 organization classify: #m33 under: #cat3!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m33 ^33! !T6 organization classify: #m33 under: #cat3!!Trait method!m2ClassSide: a ^a! !!Trait method!m31 ^31! !T2 organization classify: #m31 under: #cat1!!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m31 ^31! !T4 organization classify: #m31 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m31 ^31! !T5 organization classify: #m31 under: #cat1!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m31 ^31! !C2 organization classify: #m31 under: #cat1!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m31 ^31! !T6 organization classify: #m31 under: #cat1!!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T5 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^123! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!foo ^123! !C2 organization classify: #foo under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !C2 removeSelector: #foo!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!SystemOrganization addCategory: #'ClassRenameFix-GeneradClass'!Object subclass: #AutoGeneratedClassForTestingSystemChanges1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ClassRenameFix-GeneradClass'!Smalltalk renameClassNamed: #AutoGeneratedClassForTestingSystemChanges1 as: #AutoGeneratedClassForTestingSystemChanges2!SystemOrganization addCategory: #'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz aaa'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!Smalltalk removeClassNamed: #JunkClass!SystemOrganization removeSystemCategory: #'DeleteMe-1'!SystemOrganization removeSystemCategory: #'DeleteMe-2'!SystemOrganization addCategory: #'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz aaa'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!Smalltalk removeClassNamed: #JunkClass!SystemOrganization removeSystemCategory: #'DeleteMe-1'!SystemOrganization removeSystemCategory: #'DeleteMe-2'!SystemOrganization addCategory: #'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!SystemOrganization addCategory: #'DeleteMe-2'!SystemOrganization classify: #JunkClass under: 'DeleteMe-2'!Smalltalk removeClassNamed: #JunkClass!SystemOrganization removeSystemCategory: #'DeleteMe-1'!SystemOrganization removeSystemCategory: #'DeleteMe-2'!SystemOrganization addCategory: #'DeleteMe-1'!Object subclass: #JunkClass	instanceVariableNames: 'zzz'	classVariableNames: ''	poolDictionaries: ''	category: 'DeleteMe-1'!SystemOrganization addCategory: #'DeleteMe-2'!SystemOrganization classify: #JunkClass under: 'DeleteMe-2'!Smalltalk removeClassNamed: #JunkClass!SystemOrganization removeSystemCategory: #'DeleteMe-1'!SystemOrganization removeSystemCategory: #'DeleteMe-2'!SystemOrganization removeSystemCategory: #'DeleteMe-1'!SystemOrganization removeSystemCategory: #'DeleteMe-2'!Object subclass: #MCMockClassC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!!MCMockClassC commentStamp: 'tester-MCMockClassC 1/1/2000 00:00' prior: 0!This is a comment for MCMockClassC!Smalltalk removeClassNamed: #MCMockClassC!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!MethodPragmaTest organization removeCategory: #generated!3+4!1@1 corner: 20@20!1@1 corner: 20@20!self color!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !C2 removeSelector: #m51!T5 removeSelector: #m51!!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!Trait method!foo ^true! !T4 organization classify: #foo under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !T6 organization classify: #foo under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !T5 organization classify: #foo under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!Trait method!foo ^true! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m53 ^ self class bar! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m51 ^self! !!Trait method!foo ^true! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m51 ^self! !T4 organization classify: #m51 under: #'as yet unclassified'!!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m51 ^self! !T6 organization classify: #m51 under: #'as yet unclassified'!!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^self! !T5 organization classify: #m51 under: #'as yet unclassified'!!Trait method!m51 ^self! !C2 organization classify: #m51 under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!foo ^true! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m51 ^self! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m51 ^self! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^self! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!foo ^true! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!C2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 33951223!m51 ^123! !!Trait method!m51 ^super foo! !C2 organization classify: #m51 under: #cat1!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !C2 removeSelector: #m51!!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !T4 organization classify: #m11 under: #cat1!!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !T4 removeSelector: #m11!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m self explicitRequirement! !!Trait method!m13 ^self m12! !!Trait method!m self explicitRequirement! !T4 organization classify: #m under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self explicitRequirement! !T5 organization classify: #m under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m self explicitRequirement! !C2 organization classify: #m under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self explicitRequirement! !T6 organization classify: #m under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m self explicitRequirement! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self explicitRequirement! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self explicitRequirement! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m ^true! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m ^true! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m self explicitRequirement! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self explicitRequirement! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m self explicitRequirement! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self explicitRequirement! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !T2 removeSelector: #m!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m1 self foo bar! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !T4 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !T5 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m1 self foo bar! !C2 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !T6 organization classify: #m1 under: #'as yet unclassified'!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2 self requirement! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m2 self requirement! !T4 organization classify: #m2 under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !T5 organization classify: #m2 under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m2 self requirement! !C2 organization classify: #m2 under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m2 self requirement! !T6 organization classify: #m2 under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m13 ^self m12! !!Trait method!m2 self requirement! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m2 self requirement! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m3 ^self requirement! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m22 ^22! !!Trait method!m3 ^self requirement! !T4 organization classify: #m3 under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m3 ^self requirement! !T5 organization classify: #m3 under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m3 ^self requirement! !C2 organization classify: #m3 under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m3 ^self requirement! !T6 organization classify: #m3 under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m22 ^22! !!Trait method!m3 ^self requirement! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m3 ^self requirement! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m2 self requirement! !!Trait method!m12 ^12! !!Trait method!m1 self foo bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m3 ^self requirement! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m self requirement! !!Trait method!m13 ^self m12! !!Trait method!m self requirement! !T4 organization classify: #m under: #'as yet unclassified'!!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self requirement! !T5 organization classify: #m under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m self requirement! !C2 organization classify: #m under: #'as yet unclassified'!!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self requirement! !T6 organization classify: #m under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m self requirement! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self requirement! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self requirement! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T2 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m ^true! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m ^true! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m ^true! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m ^true! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m ^true! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m self requirement! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m self requirement! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m self requirement! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m self requirement! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !T2 removeSelector: #m!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!SystemOrganization classify: #TTraitTestBaseTrait under: #'TraitsTests-Kernel'!Trait named: #TTraitTestBaseTrait	uses: #()	category: 'TraitsTests-Kernel'!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:36'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:36'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:36'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:36'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:36'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:36'!bar ^self blah! !Smalltalk removeClassNamed: #TTraitTestBaseTrait!SystemOrganization classify: #TraitTestBaseTrait under: #'TraitsTests-Kernel'!Trait named: #TraitTestBaseTrait	uses: #()	category: 'TraitsTests-Kernel'!Object subclass: #TraitTestMethodClassA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!traitMethod	^ self! !TraitTestMethodClassA organization classify: #traitMethod under: #tests!Object subclass: #TraitTestMethodClassA	uses: TraitTestBaseTrait	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Object subclass: #TraitTestMethodClassB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!traitMethod	^ self! !TraitTestMethodClassB organization classify: #traitMethod under: #tests!Object subclass: #TraitTestMethodClassB	uses: TraitTestBaseTrait	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #TraitTestBaseTrait!Smalltalk removeClassNamed: #TraitTestMethodClassA!Smalltalk removeClassNamed: #TraitTestMethodClassB!SystemOrganization classify: #TraitTestBaseTrait under: #'TraitsTests-Kernel'!Trait named: #TraitTestBaseTrait	uses: #()	category: 'TraitsTests-Kernel'!Object subclass: #TraitTestMethodClassA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!traitMethod	^ self! !TraitTestMethodClassA organization classify: #traitMethod under: #tests!!Trait method!methodA	^ self! !TraitTestMethodClassA organization classify: #methodA under: #tests!Object subclass: #TraitTestMethodClassA	uses: TraitTestBaseTrait @ {#methodA->#traitMethod}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Object subclass: #TraitTestMethodClassB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!Trait method!traitMethod	^ self! !TraitTestMethodClassB organization classify: #traitMethod under: #tests!!Trait method!methodB	^ self! !TraitTestMethodClassB organization classify: #methodB under: #tests!Object subclass: #TraitTestMethodClassB	uses: TraitTestBaseTrait @ {#methodB->#traitMethod}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!Smalltalk removeClassNamed: #TraitTestBaseTrait!Smalltalk removeClassNamed: #TraitTestMethodClassA!Smalltalk removeClassNamed: #TraitTestMethodClassB!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !!Trait method!m11 ^11! !C2 organization classify: #m11 under: #cat1!!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !C2 removeSelector: #m12!C2 removeSelector: #m53!C2 removeSelector: #m11!C2 removeSelector: #m13!C2 organization removeCategory: #cat3!C2 removeSelector: #m51!C2 removeSelector: #m52!!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!SystemOrganization addCategory: 'Tests-MonticelloMocks'!SystemOrganization addCategory: 'Tests-MonticelloMocks'!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21' prior: 33737703!mockClassExtension! !MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 33736159!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33737804!variables	^ x + Y + MCMockClassA! !MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33737920!variables2	^ ivar + CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33738033!cVar	^ CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31' prior: 33738133!initialize	CVar := #initialized! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21' prior: 33738251!one	^ 1! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32' prior: 33738348!touchCVar	CVar := #touched! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33828415!a	^ 'a'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33738465!b	^ 'b'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric' stamp: '' prior: 33738514!c	^ 'c'! !MCMockClassA methodsFor: 'as yet classified' stamp: ''!!MCMockClassA methodsFor: 'as yet classified' stamp: '' prior: 33738573!d	^ 'd'! !MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49' prior: 33738651!falsehood	^ false! !MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21' prior: 33738737!moreTruth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26' prior: 33828501!one	^ 1! !MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14' prior: 33738908!q! !MCMockClassA methodsFor: 'boolean' stamp: ''!!MCMockClassA methodsFor: 'boolean' stamp: '' prior: 33738950!truth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59' prior: 33739033!two	^ 2! !MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB commentStamp: '' prior: 0!!MCMockClassB commentStamp: '' prior: 33737581!This comment has a bang!! Bang!! Bang!!!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21' prior: 33739293!two	^ 2! !Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21' prior: 33739122!one	^ 1! !Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22' prior: 33739217!two	^ 2! !Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA initialize!----End fileIn of a stream----!MCMockClassB removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassB!Smalltalk removeClassNamed: #MCMockClassI!Smalltalk removeClassNamed: #MCMockClassH!Smalltalk removeClassNamed: #MCMockClassG!Smalltalk removeClassNamed: #MCMockClassF!MCMockClassE class removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassE!MCMockClassD removeSelector: #one!Smalltalk removeClassNamed: #MCMockClassD!MCMockClassA removeSelector: #two!MCMockClassA removeSelector: #truth!MCMockClassA removeSelector: #q!MCMockClassA removeSelector: #one!MCMockClassA removeSelector: #moreTruth!MCMockClassA removeSelector: #falsehood!MCMockClassA removeSelector: #d!MCMockClassA removeSelector: #c!MCMockClassA removeSelector: #b!MCMockClassA removeSelector: #a!MCMockClassA class removeSelector: #touchCVar!MCMockClassA class removeSelector: #one!MCMockClassA class removeSelector: #initialize!MCMockClassA class removeSelector: #cVar!MCMockASubclass removeSelector: #variables2!MCMockASubclass removeSelector: #variables!Smalltalk removeClassNamed: #MCMockASubclass!Smalltalk removeClassNamed: #MCMockClassA!MCSnapshotTest removeSelector: #mockClassExtension!SystemOrganization addCategory: 'Tests-MonticelloMocks'!SystemOrganization addCategory: 'Tests-MonticelloMocks'!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!!MCSnapshotTest methodsFor: '*Tests-MonticelloMocks' stamp: 'ab 7/7/2003 23:21'!mockClassExtension! !MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables	^ x + Y + MCMockClassA! !MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables2	^ ivar + CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!cVar	^ CVar! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!initialize	CVar := #initialized! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!one	^ 1! !MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:32'!touchCVar	CVar := #touched! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric'!a	^ 'a'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric'!b	^ 'b'! !MCMockClassA methodsFor: 'numeric' stamp: ''!!MCMockClassA methodsFor: 'numeric'!c	^ 'c'! !MCMockClassA methodsFor: 'as yet classified' stamp: ''!!MCMockClassA methodsFor: 'as yet classified'!d	^ 'd'! !MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!falsehood	^ false! !MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!moreTruth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!one	^ 1! !MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!q! !MCMockClassA methodsFor: 'boolean' stamp: ''!!MCMockClassA methodsFor: 'boolean'!truth	^ true! !MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!two	^ 2! !MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB commentStamp: '' prior: 0!!MCMockClassB commentStamp: '' prior: 0!This comment has a bang!! Bang!! Bang!!!MCMockClassB class	instanceVariableNames: 'ciVar'!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!two	^ 2! !Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!one	^ 1! !Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!two	^ 2! !Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMockClassA initialize!----End fileIn of a stream----!!DecompilerTests methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36'!loopWithMovingLimit	"This loop might be decompiled as a to:do: but should not because it does modify its limit"	| n i |	n := 4.	i := 1.	[i <= n] whileTrue: [		n := n - 1.		i := i + 1].	^n! !!DecompilerTests methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:36' prior: 34014487!loopWithMovingLimit	| t1 t2 |	t1 := 4.	t2 := 1.	[t2 <= t1]		whileTrue: [t1 := t1 - 1.			t2 := t2 + 1].	^ t1! !DecompilerTests removeSelector: #loopWithMovingLimit!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:37'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^self blah! !!T6 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!das2qwdqwd! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:37'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^self blah! !!T1 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!foo 1 dasoia! !!Trait method!foo 1 dasoia! !T4 organization classify: #foo under: #'as yet unclassified'!!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!foo 1 dasoia! !T5 organization classify: #foo under: #'as yet unclassified'!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!foo 1 dasoia! !T6 organization classify: #foo under: #'as yet unclassified'!!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!foo 1 dasoia! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!foo 1 dasoia! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !!Trait method!foo 1 dasoia! !!Trait method!m11 ^11! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 33686095!foo ^ 1! !Griffle organization classify: #foo under: #accessing!!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 33686201!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 33686306!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 33686404!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34027957!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028119!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028224!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028322!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028773!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028879!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34028984!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34029082!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34029533!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34029639!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34029744!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34029842!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34030293!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34030399!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34030504!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34030602!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031053!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031159!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031264!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031362!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031813!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34031919!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032024!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032122!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032573!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032679!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032784!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34032882!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34033333!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34033439!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34033544!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34033642!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Griffle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!Object subclass: #Plonk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34034093!foo ^ 1! !!Griffle class methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34034199!classFoo ^ 1! !!Griffle methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34034304!bar ^ 1! !!Plonk methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37' prior: 34034402!foo ^ 2! !Object subclass: #Unused	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'nil'!SystemOrganization addCategory: 'TraitsTests-FileOut'!SystemOrganization classify: #TD under: #'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!d! !SystemOrganization classify: #TC under: #'TraitsTests-FileOut'!!Trait method!d! !TC organization classify: #d under: #cat1!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!c! !SystemOrganization classify: #TB under: #'TraitsTests-FileOut'!!Trait method!d! !TB organization classify: #d under: #cat1!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!b! !SystemOrganization classify: #TA under: #'TraitsTests-FileOut'!!Trait method!b! !TA organization classify: #b under: #cat1!!Trait method!d! !TA organization classify: #d under: #cat1!!Trait method!cc! !TA organization classify: #cc under: #cat1!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!a! !Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!ca! !CA subclass: #CB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!Trait method!cc! !CB organization classify: #cc under: #'as yet unclassified'!!Trait method!b! !CB organization classify: #b under: #cat1!!Trait method!d! !CB organization classify: #d under: #cat1!!Trait method!a! !CB organization classify: #a under: #cat1!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!cb! !!Trait method!c! !CB class organization classify: #c under: #cat1!!Trait method!d! !CB class organization classify: #d under: #cat1!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:37'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^self blah! !Smalltalk removeClassNamed: #CB!Smalltalk removeClassNamed: #TA!Smalltalk removeClassNamed: #TC!Smalltalk removeClassNamed: #TB!Smalltalk removeClassNamed: #TD!Smalltalk removeClassNamed: #CA!SystemOrganization removeSystemCategory: 'TraitsTests-FileOut'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!SystemOrganization addCategory: 'TraitsTests-FileOut'!SystemOrganization classify: #TD under: #'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!d! !SystemOrganization classify: #TC under: #'TraitsTests-FileOut'!!Trait method!d! !TC organization classify: #d under: #cat1!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!c! !SystemOrganization classify: #TB under: #'TraitsTests-FileOut'!!Trait method!d! !TB organization classify: #d under: #cat1!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!b! !SystemOrganization classify: #TA under: #'TraitsTests-FileOut'!!Trait method!b! !TA organization classify: #b under: #cat1!!Trait method!d! !TA organization classify: #d under: #cat1!!Trait method!cc! !TA organization classify: #cc under: #cat1!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!a! !Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!ca! !CA subclass: #CB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!Trait method!cc! !CB organization classify: #cc under: #'as yet unclassified'!!Trait method!b! !CB organization classify: #b under: #cat1!!Trait method!d! !CB organization classify: #d under: #cat1!!Trait method!a! !CB organization classify: #a under: #cat1!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!cb! !!Trait method!c! !CB class organization classify: #c under: #cat1!!Trait method!d! !CB class organization classify: #d under: #cat1!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!Smalltalk removeClassNamed: #CB!Smalltalk removeClassNamed: #TA!Smalltalk removeClassNamed: #TC!Smalltalk removeClassNamed: #TB!Smalltalk removeClassNamed: #TD!Smalltalk removeClassNamed: #CA!SystemOrganization removeSystemCategory: 'TraitsTests-FileOut'!SystemOrganization addCategory: #'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!ca! !SystemOrganization classify: #TD under: #'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!d! !SystemOrganization classify: #TB under: #'TraitsTests-FileOut'!!Trait method!d! !TB organization classify: #d under: #cat1!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!b! !SystemOrganization classify: #TC under: #'TraitsTests-FileOut'!!Trait method!d! !TC organization classify: #d under: #cat1!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!c! !SystemOrganization classify: #TA under: #'TraitsTests-FileOut'!!Trait method!b! !TA organization classify: #b under: #cat1!!Trait method!d! !TA organization classify: #d under: #cat1!!Trait method!cc! !TA organization classify: #cc under: #cat1!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!a! !CA subclass: #CB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!Trait method!cc! !CB organization classify: #cc under: #'as yet unclassified'!!Trait method!b! !CB organization classify: #b under: #cat1!!Trait method!d! !CB organization classify: #d under: #cat1!!Trait method!a! !CB organization classify: #a under: #cat1!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!cb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!Trait method!c! !CB class organization classify: #c under: #cat1!!Trait method!d! !CB class organization classify: #d under: #cat1!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/TraitsTests-FileOut.st----!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:37'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^self blah! !Smalltalk removeClassNamed: #CB!Smalltalk removeClassNamed: #TA!Smalltalk removeClassNamed: #TC!Smalltalk removeClassNamed: #TB!Smalltalk removeClassNamed: #TD!Smalltalk removeClassNamed: #CA!SystemOrganization removeSystemCategory: 'TraitsTests-FileOut'!SystemOrganization addCategory: 'TraitsTests-FileOut'!SystemOrganization classify: #TD under: #'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!d! !SystemOrganization classify: #TC under: #'TraitsTests-FileOut'!!Trait method!d! !TC organization classify: #d under: #cat1!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!c! !SystemOrganization classify: #TB under: #'TraitsTests-FileOut'!!Trait method!d! !TB organization classify: #d under: #cat1!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!b! !SystemOrganization classify: #TA under: #'TraitsTests-FileOut'!!Trait method!b! !TA organization classify: #b under: #cat1!!Trait method!d! !TA organization classify: #d under: #cat1!!Trait method!cc! !TA organization classify: #cc under: #cat1!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!a! !Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!ca! !CA subclass: #CB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!Trait method!cc! !CB organization classify: #cc under: #'as yet unclassified'!!Trait method!b! !CB organization classify: #b under: #cat1!!Trait method!d! !CB organization classify: #d under: #cat1!!Trait method!a! !CB organization classify: #a under: #cat1!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!cb! !!Trait method!c! !CB class organization classify: #c under: #cat1!!Trait method!d! !CB class organization classify: #d under: #cat1!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!!T6 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!localMethod: argument ^argument! !!T6 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!localClassSideMethod: argument ^argument! !Smalltalk removeClassNamed: #T6!'From Squeak5.0 of 12 August 2015 [latest update: #15117] on 13 August 2015 at 12:37:13 am'!SystemOrganization classify: #T6 under: #'TraitsTests-Kernel'!!Trait method!m13 ^self m12! !T6 organization classify: #m13 under: #cat3!!Trait method!m11 ^11! !T6 organization classify: #m11 under: #cat1!!Trait method!m22 ^22! !T6 organization classify: #m22 under: #cat2!!Trait method!m22Alias ^22! !T6 organization classify: #m22Alias under: #cat2!!Trait method!m21 ^21! !T6 organization classify: #m21 under: #cat1!!Trait method!m12 ^12! !T6 organization classify: #m12 under: #cat2!!Trait method!m2ClassSide: a ^a! !T6 classTrait organization classify: #m2ClassSide: under: #'as yet unclassified'!Trait named: #T6	uses: T1 + T2 @ {#m22Alias->#m22}	category: 'TraitsTests-Kernel'!Trait named: #T6	uses: T1 + T2 @ {#m22Alias->#m22}	category: 'TraitsTests-Kernel'!T6 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!!T6 methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!localMethod: argument ^argument! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!Trait method!m2ClassSide: a ^a! !T6 classTrait	uses: T1 classTrait + T2 classTrait!T6 classTrait	uses: T1 classTrait + T2 classTrait!T6 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!!T6 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!localClassSideMethod: argument ^argument! !----End fileIn of /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/T6.st----!Smalltalk removeClassNamed: #CB!Smalltalk removeClassNamed: #TA!Smalltalk removeClassNamed: #TC!Smalltalk removeClassNamed: #TB!Smalltalk removeClassNamed: #TD!Smalltalk removeClassNamed: #CA!SystemOrganization removeSystemCategory: 'TraitsTests-FileOut'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!Smalltalk removeClassNamed: #T6!SystemOrganization addCategory: 'TraitsTests-FileOut'!SystemOrganization classify: #TD under: #'TraitsTests-FileOut'!Trait named: #TD	uses: #()	category: 'TraitsTests-FileOut'!!TD methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!d! !SystemOrganization classify: #TC under: #'TraitsTests-FileOut'!!Trait method!d! !TC organization classify: #d under: #cat1!Trait named: #TC	uses: TD	category: 'TraitsTests-FileOut'!!TC methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!c! !SystemOrganization classify: #TB under: #'TraitsTests-FileOut'!!Trait method!d! !TB organization classify: #d under: #cat1!Trait named: #TB	uses: TD	category: 'TraitsTests-FileOut'!!TB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!b! !SystemOrganization classify: #TA under: #'TraitsTests-FileOut'!!Trait method!b! !TA organization classify: #b under: #cat1!!Trait method!d! !TA organization classify: #d under: #cat1!!Trait method!cc! !TA organization classify: #cc under: #cat1!Trait named: #TA	uses: TB + TC @ {#cc->#c} - {#c}	category: 'TraitsTests-FileOut'!!TA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!a! !Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!Object subclass: #CA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CA methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!ca! !CA subclass: #CB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!Trait method!cc! !CB organization classify: #cc under: #'as yet unclassified'!!Trait method!b! !CB organization classify: #b under: #cat1!!Trait method!d! !CB organization classify: #d under: #cat1!!Trait method!a! !CB organization classify: #a under: #cat1!CA subclass: #CB	uses: TA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-FileOut'!!CB methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!cb! !!Trait method!c! !CB class organization classify: #c under: #cat1!!Trait method!d! !CB class organization classify: #d under: #cat1!CB class	uses: TA classTrait + TC	instanceVariableNames: ''!!T1 commentStamp: '<historical>' prior: 0!I am the trait T1!!T2 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m21 ^21! !!T2 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m22 ^22! !!T2 classTrait methodsFor: 'as yet unclassified' stamp: 'pls 8/13/2015 00:37'!m2ClassSide: a ^a! !!T3 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m31 ^31! !!T3 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m32 ^32! !!T3 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m33 ^33! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T4 methodsFor: 'catX' stamp: 'pls 8/13/2015 00:37'!m11 ^41! !!T4 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m42 ^42! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m2ClassSide: a ^a! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m51 ^super foo! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m52 ^ self class bar! !!T5 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m53 ^ self class bar! !!Trait method!m21 ^21! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m2ClassSide: a ^a! !!C1 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^true! !!T1 methodsFor: 'cat1' stamp: 'pls 8/13/2015 00:37'!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat2' stamp: 'pls 8/13/2015 00:37'!m12 ^12! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m22 ^22! !!Trait method!m11 ^11! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!T1 methodsFor: 'cat3' stamp: 'pls 8/13/2015 00:37'!m13 ^self m12! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m22Alias ^22! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!Trait method!m52 ^ self class bar! !!Trait method!m22 ^22! !!Trait method!m13 ^self m12! !!Trait method!m53 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m21 ^21! !!Trait method!m12 ^12! !!Trait method!m2ClassSide: a ^a! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!foo ^false! !!C2 methodsFor: 'private' stamp: 'pls 8/13/2015 00:37'!bar ^self foo! !!C3 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self bla! !!C4 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blew! !!C5 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self blah! !!C6 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^self x! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!foo ^3! !!C7 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^super foo! !!C8 methodsFor: 'accessing' stamp: 'pls 8/13/2015 00:37'!bar ^self blah! !!C2 methodsFor: 'xxx' stamp: 'pls 8/13/2015 00:37' prior: 34065415!m12 ^0! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !C2 organization classify: #m12 under: #cat2!!Trait method!m52 ^ self class bar! !C2 removeSelector: #m12!!T5 methodsFor: 'xxx' stamp: 'pls 8/13/2015 00:37' prior: 34064929!m12 ^0! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^0! !!Trait method!m52 ^ self class bar! !!Trait method!m13 ^self m12! !!Trait method!m11 ^11! !!Trait method!m22 ^22! !!Trait method!m12 ^12! !T5 organization classify: #m12 under: #cat2!!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m12 ^12! !C2 organization classify: #m12 under: #cat2!!Trait method!m52 ^ self class bar! !C2 organization removeCategory: #xxx!!Trait method!m21 ^21! !!Trait method!m2ClassSide: a ^a! !!Trait method!m51 ^super foo! !!Trait method!m53 ^ self class bar! !!Trait method!m52 ^ self class bar! !T5 removeSelector: #m12!Smalltalk removeClassNamed: #CB!Smalltalk removeClassNamed: #TA!Smalltalk removeClassNamed: #TC!Smalltalk removeClassNamed: #TB!Smalltalk removeClassNamed: #TD!Smalltalk removeClassNamed: #CA!SystemOrganization removeSystemCategory: 'TraitsTests-FileOut'!Smalltalk removeClassNamed: #T1!Smalltalk removeClassNamed: #T2!Smalltalk removeClassNamed: #T3!Smalltalk removeClassNamed: #T4!Smalltalk removeClassNamed: #T5!Smalltalk removeClassNamed: #T6!Smalltalk removeClassNamed: #C1!Smalltalk removeClassNamed: #C2!Smalltalk removeClassNamed: #C3!Smalltalk removeClassNamed: #C4!Smalltalk removeClassNamed: #C5!Smalltalk removeClassNamed: #C6!Smalltalk removeClassNamed: #C7!Smalltalk removeClassNamed: #C8!WebClient!WebServer!!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:56' prior: 58282152!ensureSampleCertFile	"On Unix, we can simply create a valid cert file"	| certName file |	SqueakSSL platformName = 'unix' ifFalse:[^self].	certName := self name, 'Cert.pem'.	(FileDirectory default fileExists: certName) ifFalse:[		file := FileDirectory default newFileNamed: certName.		[file nextPutAll: self exampleCertFile] ensure:[file close].	].	^FileDirectory default fullNameFor: certName.! !!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 11/17/2011 17:10' prior: 50763697!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[			self nextPutAll: (sendBuf copyFrom: 1 to: result).			self flush.		].		"Read more input and repeat"		self receiveData.		inbuf := self nextAvailable.	].	"There should be no pending data at this point, ensure it is so.	XXXX: If you ever see this problem, please inform me."	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !!SecureSocket class methodsFor: 'examples' stamp: 'ar 6/17/2012 11:13' prior: 65019771!google: query	"An example HTTPS query to encrypted.google.com.	Example:		SecureSocket google: 'squeak'.		SecureSocket google: 'SqueakSSL'.	"	| hostName address socket |	"Change the host name to try an https request to some other host"	hostName := 'encrypted.google.com'..	address := NetNameResolver addressForName: hostName.	socket := SecureSocket newTCP.	"Connect the TCP socket"	socket connectTo: address port: 443.	socket waitForConnectionFor: 10.	["Handle the client handshake"	socket sslConnect.	"Verify that the cert is valid"	socket certState = 0 ifFalse:[		self error: 'The certificate is invalid (code: ', socket certState,')'.	].	"If the certificate is valid, make sure we're were we wanted to go"	(socket peerName match: hostName) ifFalse:[		self error: 'Host name mismatch: ', socket peerName.	].	"Send encrypted data"	socket sendData:		'GET /search?q=', query,' HTTP/1.0', String crlf,		'Host: ', hostName, String crlf,		'Connection: close', String crlf,		String crlf.	"Wait for the response"	^String streamContents:[:s|		[[true] whileTrue:[s nextPutAll: socket receiveData]]			on: ConnectionClosed, ConnectionTimedOut do:[:ex| ex return].	]] ensure:[socket destroy].! !!SecureSocket methodsFor: 'connect' stamp: 'ar 6/17/2012 11:03' prior: 65014545!sslConnect	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."	| inbuf squeakSSL result |	inbuf := ''.	squeakSSL := SqueakSSL new.	"Perform the SSL handshake"	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.	result = 0] whileFalse:[		"Check for errors first"		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].		"If a token has been produced in the handshake, send it to the remote"		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].		"Read more input and repeat"		inbuf := self receiveData.	].	"We are connected. From here on, encryption will take place."	ssl := squeakSSL.	] ifCurtailed:[		"Make sure we destroy the platform handle if the handshake gets interrupted"		squeakSSL destroy.	].! !SecureSocket removeSelector: #sslConnectTo:!SecureSocket removeSelector: #accept!SecureSocketStream removeSelector: #sslConnectTo:!SqueakSSL removeSelector: #serverName:!"SqueakSSL-Core"!!SqueakSSLTest methodsFor: 'tests' stamp: 'ar 11/27/2011 11:26' prior: 59373305!testYahooOpenID	"Yahoo sends an SSL shutdown sequence which we didn't handle in the past.	Also, there were some issues with SecureSocketStream that were unearthed	by using it via WebClient's chunking method (not easy to reproduce without WC)."	Smalltalk at: #WebClient ifPresent:[:webClient|		self shouldnt:[			[webClient httpGet: 'https://open.login.yahooapis.com/openid/op/auth']				"Allow certificate errors on the Mac since cert validation isn't				implemented yet."				on: SqueakSSLCertificateError do:[:ex|					SqueakSSL platformName = 'Mac OS'						ifTrue:[ex resume]						ifFalse:[ex pass]].		] raise: Error.	]..! !"SqueakSSL-Tests"!(Installer ss project: 'SqueakSSL')		install: 'SqueakSSL-Core';		install: 'SqueakSSL-Tests'.!SystemOrganization addCategory: #'RFB-Communication'!Socket subclass: #RFBSocket	instanceVariableNames: 'hostName'	classVariableNames: 'LastServerAddress MaximumTransmissionUnit RFBSocketInstances RfbListenPortOffset RfbPortOffset SendTimeout ServerPortOffset ViewerPortOffset'	poolDictionaries: ''	category: 'RFB-Communication'!!RFBSocket commentStamp: 'ikp 3/5/2004 14:39' prior: 0!I am a kind of Socket that understands how to transmit word objects and the originalContents of a Stream.!SystemOrganization addCategory: #'RFB-Viewer'!RFBSocket subclass: #RFBClientSocket	instanceVariableNames: 'getPixel getCPixel pixelBuffer'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!!RFBClientSocket commentStamp: 'ikp 3/23/2004 12:05' prior: 0!I am a RFBSocket that understands how to read pixels.!TwoWayScrollPane subclass: #RFBScrollPane	instanceVariableNames: 'rfbClient'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!!RFBScrollPane commentStamp: 'ikp 3/23/2004 12:05' prior: 0!I an a TwoWayScrollPane optimised for use with a RFBClient.!SystemOrganization addCategory: #'RFB-Messages'!ByteArray variableByteSubclass: #RFBMessage	instanceVariableNames: ''	classVariableNames: 'RfbBell RfbClientCutText RfbConnFailed RfbFixColourMapEntries RfbFramebufferUpdate RfbFramebufferUpdateRequest RfbKeyEvent RfbNoAuth RfbPointerEvent RfbServerCutText RfbSetColourMapEntries RfbSetEncodings RfbSetPixelFormat RfbVncAuth RfbVncAuthFailed RfbVncAuthOK RfbVncAuthTooMany'	poolDictionaries: ''	category: 'RFB-Messages'!!RFBMessage commentStamp: 'ikp 3/5/2004 14:45' prior: 0!We (myself and my subclasses) represent a message sent to, or received from, a remote RFB viewer.  We implement accessing protocol that makes it easy to read and write the fields within messages, but we are also a kind of ByteArray (which makes it east to read and write us over a network connection).!RFBMessage variableByteSubclass: #RFBBell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBBell commentStamp: 'ikp 3/5/2004 14:46' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBClientCutText	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBClientCutText commentStamp: 'ikp 3/5/2004 14:46' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBCoRRERectangle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBCoRRERectangle commentStamp: 'ikp 3/5/2004 14:51' prior: 0!I am a fragment of a RFBMessage representing an update rectangle in the CoRRE encoding.!RFBMessage variableByteSubclass: #RFBFixColourMapEntries	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBFixColourMapEntries commentStamp: 'ikp 3/5/2004 14:46' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBFramebufferUpdate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBFramebufferUpdate commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBFramebufferUpdateRectHeader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBFramebufferUpdateRectHeader commentStamp: 'ikp 3/5/2004 14:51' prior: 0!I am a fragment of a RFBMessage representing a "generic" screen update rectangle.!RFBMessage variableByteSubclass: #RFBFramebufferUpdateRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBFramebufferUpdateRequest commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBKeyEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBKeyEvent commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBPointerEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBPointerEvent commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBRREHeader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBRREHeader commentStamp: 'ikp 3/5/2004 14:51' prior: 0!I am a fragment of a RFBMessage representing an update in the RRE encoding.!RFBMessage variableByteSubclass: #RFBRectangle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBRectangle commentStamp: 'ikp 3/5/2004 14:52' prior: 0!I am a fragment of a RFBMessage representing a "generic" rectangle.!RFBMessage variableByteSubclass: #RFBServerCutText	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBServerCutText commentStamp: 'ul 8/13/2012 02:02' prior: 0!I am an RFBMessage used for passing server side clipboard changes to the client.!RFBMessage variableByteSubclass: #RFBServerInitialisation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBServerInitialisation commentStamp: 'ikp 3/23/2004 12:05' prior: 0!I am a RFBMessage representing a server initialisation message.!RFBMessage variableByteSubclass: #RFBSetEncodings	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBSetEncodings commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBSetPixelFormat	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBSetPixelFormat commentStamp: 'ikp 3/5/2004 14:47' prior: 0!I am a kind of RFBMessage.  See the comment in that class for more information.!RFBMessage variableByteSubclass: #RFBXCursorColoursHeader	instanceVariableNames: ''	classVariableNames: 'StandardCursorColours'	poolDictionaries: ''	category: 'RFB-Messages'!!RFBXCursorColoursHeader commentStamp: 'ikp 3/5/2004 14:53' prior: 0!I am a fragment of a RFBMessage representing the foreground and background colours of a cursor shape.!RFBMessage variableByteSubclass: #RFBZRLEHeader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Messages'!!RFBZRLEHeader commentStamp: 'ikp 3/18/2004 04:05' prior: 0!I am a header for an update rectangle in ZRLE (Zlib Run Length Encoding) format.!ZLibReadStream subclass: #RFBZLibReadStream	instanceVariableNames: 'getPixel getCPixel pixelBuffer'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!!RFBZLibReadStream commentStamp: 'ikp 3/23/2004 12:06' prior: 0!I am a ZLibReadStream that understands how to decompress pixel values.!SystemOrganization addCategory: #'RFB-Server'!DisplayScreen subclass: #RFBDisplayScreen	instanceVariableNames: 'rfbServer colourMap'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBDisplayScreen commentStamp: 'ikp 3/5/2004 14:16' prior: 0!I am a kind of DisplayScreen that also forwards screen updates and beep requests to the active RFBServer.  I replace the usual Display whenever a RFBServer is running, and remove myself gracefully whenever the RFBServer is shut down.!Form subclass: #RFBForm	instanceVariableNames: 'format fill'	classVariableNames: 'IdentityMap16 NumLargeInts NumSmallInts RfbHextileAnySubrects RfbHextileBackgroundSpecified RfbHextileForegroundSpecified RfbHextileRaw RfbHextileSubrectsColoured RfbZrleBitsPerPackedPixel RfbZrleTileHeight RfbZrleTileWidth'	poolDictionaries: ''	category: 'RFB-Server'!!RFBForm commentStamp: 'ikp 3/24/2004 00:17' prior: 0!I am a kind of Form that provides several additional facilities:	- I hold on to cached BitBlts for doing pixel-based access (peeking, poking and filling), and provide additional methods #pixelAt:, #pixelAt:put:, and #pixelsIn:put: that use them.	- I can describe my pixel format (depth, byte order, etc.) in the way that an RFBServer finds most useful.	- I provide several methods to support the encoding of my contents on a stream for sending to a remote RFB viewer.!RFBForm subclass: #OldRFBDamageRecorder	instanceVariableNames: 'cachedForm deltaForm deltaBlt depthBlt foldBlt updateBlt clearBlt'	classVariableNames: 'DamageHeight DamageWidth'	poolDictionaries: ''	category: 'RFB-Server'!!OldRFBDamageRecorder commentStamp: 'ikp 3/4/2004 04:04' prior: 0!| r |r := RFBDamageRecorder forDisplay.Time millisecondsToRun: [10000 timesRepeat: [r testDamage: Display in: (96@96 extent: 32@32)]] 1241Time millisecondsToRun: [10000 timesRepeat: [Display isChangedFrom3b: Display in: (96@96 extent: 32@32).]]  1333| f d l t n |n := 128.f := RFBForm fromDisplay: Display boundingBox.d := RFBDamageRecorder forForm: f.f fill: (200@200 corner: 600@600) fillColor: Color red.l := OrderedCollection new.MessageTally spyOn: [t := Time millisecondsToRun: [0 to: f height - n by: n do: [:y | 0 to: f width - n by: n do: [:x |	(d testDamage: f in: (x@y extent: n@n))		ifTrue: [l add: x@y]]].]].^Array with: t with: l| f d l |f := RFBForm fromDisplay: (0@0 extent: 64@64).d := RFBDamageRecorder forForm: f."MessageTally spyOn: ["0 to: 20 do: [:yy | Smalltalk beepPrimitive.0 to: 20 do: [:xx |1 to: 8 do: [:n | 	f fill: (xx@yy extent: 1@1) fillColor: (Color r: yy / 40.0 g: xx / 40.0 b: n / 8.0).	l := OrderedCollection new.	0 to: f height - n by: n do: [:y | 0 to: f width - n by: n do: [:x |	(d testDamage: f in: (x@y extent: n@n))		ifTrue: [l add: x@y]]].	l size ~= 1 ifTrue: [self error: 'oops']]]]."]"!RFBForm subclass: #RFBClientForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!!RFBClientForm commentStamp: 'ikp 3/23/2004 12:04' prior: 0!I am a RFBForm that understands how to decode framebuffer update messages.!RFBForm subclass: #RFBDamageRecorder	instanceVariableNames: 'targetForm'	classVariableNames: 'DamageHeight DamageWidth'	poolDictionaries: ''	category: 'RFB-Server'!!RFBDamageRecorder commentStamp: 'ikp 3/5/2004 14:09' prior: 0!I am a Form that record damaged areas relative to another Form.  After instantiating me with "on: originalForm" you can ask me at any time "isDamaged" or "isDamagedIn: boundingRectangle" and I will answer true or false, depending on whether originalForm has changed in the given bounds since the last time you asked.!RFBDamageRecorder subclass: #RFBDamageFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBDamageFilter commentStamp: 'ikp 3/5/2004 14:12' prior: 0!I am a kind of RFBDamageRecorder that understands damaged regions (consisting of Collections of Rectangles) instead of just a simple bounding Rectangle.  You instantiate me just like a RFBDamageRecorder, and can then ask me to "getDamageInRegion: rectangleCollection".  I will answer with another Collection containing only rectangles that really were modified since the last time you asked, and which have been trimmed as necessary to guarantee that no "false" damage is reported more than 32 pixels away from "real" damage.!ZLibWriteStream subclass: #RFBZLibWriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBZLibWriteStream commentStamp: 'ikp 3/24/2004 00:19' prior: 0!I am a ZLibWriteStream that understands how to synchronise my encodedData with a remote inflation process.  At each synchronisation point I write a marker to the encodedStream that will cause the inflation process in the remote client to ensure that all preceding data has been inflated and presented to the final consumer, avoiding any possibility for data to become 'stuck' in the inflation buffer.  This is most convenient when encoded data is being sent over a network and contains (for example) interactive screen updates.!BitBlt subclass: #RFBBitBlt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBBitBlt commentStamp: 'ikp 3/5/2004 14:05' prior: 0!I am a regular BitBlt with slightly modified behaviour:	- I provide instance creation methods that work for 8-bit Forms that are RGB (rather than indexed, a rather gross assumption on the part of BitBlt)	- I support filling areas with pixel values (rather than Colors)	- I provide some additional accessing methods (to eliminate a few message sends here and there)	- I take care to unhibernate my destForm correctly after snapshot (avoiding a nasty bug that affects cached "bit peekers")!ImageMorph subclass: #RFBClientMorph	instanceVariableNames: 'scrollPane window rfbClient damage'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!SystemWindow subclass: #RFBSystemWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Viewer'!!RFBSystemWindow commentStamp: 'ikp 3/23/2004 12:06' prior: 0!I am a SystemWindow with additional support for working with RFBClients.!Bag subclass: #RFBPixelPopulation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBPixelPopulation commentStamp: 'ikp 3/5/2004 14:23' prior: 0!I am a kind of Bag that interprets its contents as a map of pixelValue -> pixelCount.!WriteStream subclass: #RFBStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStream commentStamp: 'ikp 3/5/2004 14:43' prior: 0!I am a kind of Stream over a ByteArray.  I understand both #nextPut: (to append bytes to my contents) and #nextPutPixel: (to append 8-, 16- or 32-bit pixel data, possibly byte-swapped, according to a "pixel format" specified when you instantiate me).  I cooperate with RFBSocket to send my contents over a network connection with "zero copy".You instantiate me by sending "forDepth: bitsPerPixel byteSwapped: swapFlag".  If bitsPerPixel is 8 then you get back an instance of me.  If bitsPerPixel is not 8 then you get back an instance of one of my four subclasses that deal with 16- and 32-bit pixels in native or byte-swapped order.!RFBStream subclass: #RFBStream16	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStream16 commentStamp: 'ikp 3/7/2004 20:07' prior: 0!I am a kind of RFBStream for writing 16-bit pixel data.  See the comment in that class for more information.!RFBStream subclass: #RFBStream32	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStream32 commentStamp: 'ikp 3/7/2004 20:07' prior: 0!I am a kind of RFBStream for writing 32-bit pixel data.  See the comment in that class for more information.!RFBStream32 subclass: #RFBStream24	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStream24 commentStamp: 'ikp 3/18/2004 03:18' prior: 0!I am a kind of RFBStream for writing 32-bit pixel data or 24-bit 'compressed' pixel data for ZRLE encoding.  See the comment in that class for more information.!RFBStream subclass: #RFBStreamSwap16	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStreamSwap16 commentStamp: 'ikp 3/7/2004 20:08' prior: 0!I am a kind of RFBStream for writing byte-swapped 16-bit pixel data.  See the comment in that class for more information.!RFBStream subclass: #RFBStreamSwap32	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStreamSwap32 commentStamp: 'ikp 3/7/2004 20:08' prior: 0!I am a kind of RFBStream for writing byte-swapped 32-bit pixel data.  See the comment in that class for more information.!RFBStreamSwap32 subclass: #RFBStreamSwap24	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBStreamSwap24 commentStamp: 'ikp 3/18/2004 03:18' prior: 0!I am a kind of RFBStream for writing byte-swapped 32-bit pixel data or 24-bit 'compressed' pixel data for ZRLE encoding.  See the comment in that class for more information.!WriteStream subclass: #RFBZLibFakeStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Communication'!!RFBZLibFakeStream commentStamp: 'ikp 3/17/2004 20:32' prior: 0!I am a completely bogus ZLib write stream.You write uncompressed data to me with #nextPutAll: and retrieve the 'compressed' data with #contents (followed by position: 0, if appropriate, to empty my output buffer).If you expect a pause in your data stream then you should send me #synchronise.  This will ensure that *all* data is flushed through to the *final* consumer of the uncompressed data at the other end of the (e.g.) network connection.You can therefore repeat the cycle:	oneOfMe		nextPutAll: yourUncompressedData;		synchronise;		contents;		position: 0.as many times as you like, each time sending the answer to #contents to a (possibly remote) consumer who is piping their incoming 'compressed' data through a zlib inflation process.  This consumer is *guaranteed* to receive all yourUncompressedData at each point you send #synchronise.I am completely bogus because I don't compress anything at all.  The 'compressed' data is larger than the uncompressed data, but it *does* conform rigorously to the format described in RFC 1951.  You can therefore send the 'compressed' data I produce to any conforming implementation of zlib and expect to retrieve the original data, with inflation 'latencies' managed correctly as per the synchronisation behaviour described above.!SystemOrganization addCategory: #'RFB-Crypto-3DES'!Object subclass: #RFB3DES	instanceVariableNames: 'knl knr kn3'	classVariableNames: 'BigByte ByteBit PC1 PC2 SP1 SP2 SP3 SP4 SP5 SP6 SP7 SP8 TotRot'	poolDictionaries: ''	category: 'RFB-Crypto-3DES'!!RFB3DES commentStamp: 'ikp 3/8/2004 04:36' prior: 0!I am a (somewhat trimmed-down) 3DES encryption algorithm intended only for use in VNC password authentication.  My reason for existing is to avoid an otherwise very nasty dependency on the DESPlugin (which would provided suitable functionality, but which is not normally bundled with Squeak VMs).I'm not particularly fast (you wouldn't want to ask me to encrypt a megabyte of data) but, since I'm only here to encrypt 16-byte authentication challenges during the connection handshake, who cares?!Object subclass: #RFBClient	instanceVariableNames: 'target image socket sendLock state process protocolMinor serverExtent serverFormat serverName updateRequestPending currentCursor savedCursor hasCursor modifierState zlibStream logClient'	classVariableNames: 'CommandKeySym CtrlKeySym DefaultEncoding Enable8Bit EnableExpandOnBell EnableExpandOnConnection EnableShared EnableViewOnly EnableXCursor Encodings FastUpdate KeySyms MessageTypes ModifierMap OptionKeySym ProtocolMajor ProtocolMinor RfbEncodingAuto RfbEncodingCoRRE RfbEncodingCopyRect RfbEncodingHextile RfbEncodingLastRect RfbEncodingPointerPos RfbEncodingRRE RfbEncodingRaw RfbEncodingRichCursor RfbEncodingTight RfbEncodingXCursor RfbEncodingZRLE RfbEncodingZlib RfbEncodingZlibHex ShiftKeySym'	poolDictionaries: 'EventSensorConstants'	category: 'RFB-Viewer'!!RFBClient commentStamp: 'ikp 3/23/2004 12:03' prior: 0!I am a RFB/VNC viewer.  If you send me #open then I will open a window with a menu (on the scrollbar button) for connecting to a remote RFB/VNC server.!Object subclass: #RFBPalette	instanceVariableNames: 'index key pixels size'	classVariableNames: 'RfbPaletteMaxSize'	poolDictionaries: ''	category: 'RFB-Server'!!RFBPalette commentStamp: 'ikp 3/24/2004 00:17' prior: 0!I am a colour palette.  I manage some number of pixel values (see #insert:) which I convert into an indexed palette (see #lookup:).  I am used by the ZRLE encoding which tries to send indexed pixel values instead of raw pixel values whenever possible.!Object subclass: #RFBPixelFormat	instanceVariableNames: 'bitsPerPixel depth bigEndian trueColour redMax greenMax blueMax redShift greenShift blueShift orderMap colourMap'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBPixelFormat commentStamp: 'ikp 3/5/2004 14:22' prior: 0!I describe the pixel format being used by a remote RFB viewer, including:	- the byte order (big or little endian)	- whether pixels are RGB (true colour) or indices into a colour lookup table (pseudo colour)	- for true colour, I also remember the shifts and masks that describe each of the three colour channels (R, G and B) in a pixel.!Object subclass: #RFBServer	instanceVariableNames: 'socket sessions sessionsSema process port localHostName localHostAddress loopbackAddress'	classVariableNames: 'AllowEmptyPasswords AllowInputEvents AllowLocalConnections AllowRemoteConnections AllowZRLE ConnectionPriority ConserveMemory EnableDamageFilter EnableDebugging EnableLogging EnableMemoryLog EnableRawFilter FixedKey LoopbackAddress LowWaterMark Server ServerLog ServerPreferences ServerProcess VNCPasswords'	poolDictionaries: ''	category: 'RFB-Server'!!RFBServer commentStamp: 'ikp 3/19/2004 04:05' prior: 0!I provide interaction with the Squeak display for remote "viewers" using the RFB (Remote Frame Buffer, sometimes also called "VNC" for Virtual Network Computing) protocol developped (initially) by AT&T and (later) by RealVNC.The easiest way to configure and control me is to open my menu:	RFBServer open(which you can pin to the desktop if you like).  You can also send me messages to perform various configuration/control tasks.  The most important of these is:	RFBServer setFullPasswordwhich sets a password that remote users must provide in order to connect.  Once you have installed a password you can send me:	RFBServer start				-- to enable connections from remote viewers	RFBServer stop				-- to disable them again.RFB/VNC experts can also send me:	RFBServer start: displayNumber(If you don't know the relevance of "displayNumber" then either don't worry about it, or see the documentation that came with your viewer application for an explanation.)** PERFORMANCE HINTSIf you are running Squeak and the viewer on the same machine (which might happen if you start the image "headless" and suddenly need to interact with it), or if there is a fast connection (100Mbps or better) between you and Squeak, then always use "raw" encoding.  (If you're running a non-headless Unix Squeak remotely over a 100Mbps connection then you shouldn't be using RFB/VNC at all: use X11 instead.)When using any encoding other than "raw", avoid running the (native) Squeak display at depth 32; use 8 or 16 instead.  This permits various optimisations using BitBlt that significantly decrease the computation needed to analyse the contents of large screen areas.  Although this won't (generally) affect the speed at which remote viewers receive screen updates, it will reduce the load on your running image and free up the processor for doing useful stuff instead.Avoid "RRE" encoding if you can.  This encoding must analyse the entire update area before sending anything to the viewer.  The result is a long pause (while analysing the update area) followed by saturation of the connection while the entire area is sent at once.  Two time-consuming activities that are strictly sequential when using "RRE".  Conversely, "Hextile" and "CoRRE" split the update area into subrectangles and send each one independently.  This is better for two reasons.  Firstly, it introduces parallelism by overlapping the communication and computation.  Secondly, it's psychologically (much) less stressful on you, since the viewer will update the window contents incrementally -- giving you something to watch while waiting for a large update to complete.  (Note that some viewers deliberately increase your stress level by deferring all graphical output while receiving the initial framebuffer contents.  Ho hum.)If you are on a slow connection then (obviously) avoid leaving anything on your desktop that 'moves' (a ClockMorph, the Squeak logo with the roving eyes, etc...).In general:  When running locally, always use "Raw" encoding at any bit depth.  When running remotely, over a medium or slow speed connection, always use "Hextile" encoding at depth 8 or 16, unless you have a good reason not to.If you have a really hopeless connection (e.g., a very slow modem) consider using "ZRLE" (if your viewer supports it).  This behaves somewhat like Hextile but also "zip" compresses the data before sending it.  Needless to say, ZRLE is extremely CPU-intensive at the server (Squeak) end.** AESTHETIC HINTSIf you are using the TightVNC viewer then always enable the 'x11cursor' extension.  This (greatly) improves the behaviour of the cursor (it should be identical to the behaviour you'd see if running Squeak locally), eliminates the annoying dot that normally tracks your local cursor position, and decreases (slightly) the bandwidth used.If you want to use 8-bit colour in the viewer then either:	- Run Squeak in 8-bit depth and enable 'own colourmap' in the viewer.  Depending on your window system, this may introduce unpleasant artefacts when the pointer enters/leaves the viewer window.	- Run Squeak in 16-bit depth and use the 'bgr223' pixel format in the viewer.  This provides the most accurate mapping of Squeak colours into the standard 8-bit 'true'-colour pallette of the viewer.  (The results are better than you might expect.)** CAVEATSWhile I am running (between sending me #start and #stop) I replace the Display and Sensor objects with something (almost but not quite entirely) equivalent.  When I am not running I do not leave any trace of my existence behind.Active sessions to remote viewers involve several inter-communicating processes running at higher than user priority.  In the unlikely event that you hit the interrupt key while one of these processes is in a critical region, quitting the resulting debugger will effectively freeze the remote session.RealVNC (and many other) viewers do not support the "X11Cursor" extension, which was introduced by TightVNC.TightVNC (and many other) viewers do not support "ZRLE" encoding, which was introduced by RealVNC.** BUGSScreen updates correspond faithfully to the "damaged regions" maintained by Morphic.  This often results in undamaged parts of the display being updated unnecessarily.  This isn't too bad when running locally (you probably won't even notice it most of the time), but can be disasterous when viewing remotely over a slow connection.  The correct solution would be to fix Morphic so that damaged regions accurately reflect the parts of the Display that have been modified (and not simply repainted with the same content) -- so that local screen updates benefit too.  The pragmatic solution (adopted here) is to filter the damage reported by Morphic to eliminate the bogus regions.  (The classes RFBDamageRecorder and RFBDamageFilter take care of the unpleasant details.)!Object subclass: #RFBSession	instanceVariableNames: 'server socket process state protocolMinor interactive reverseConnection readyForSetColourMapEntries preferredEncoding sendRect countRects correMaxWidth correMaxHeight authChallenge modifiedRegion requestedRegion format zlibCompressLevel zlibStream enableLastRectEncoding enableCursorShapeUpdates enableCursorPosUpdates useRichCursorEncoding modifiers updateProcess updateSemaphore currentCursor clientCursor mousePosition clientPosition fixColourMapEntries framebufferUpdateRequest framebufferUpdate updateRectHeader keyEvent pointerEvent clientCutText rreHeader zrleHeader xCursorColoursHeader rfbStream damageFilter incremental allocationCount bytesLeft updateCount lowWaterMark highWaterMark meanSeaLevel updateTime totalTime'	classVariableNames: 'Encodings KeyCodesFF Logging MessageTypes ModifierMap ProtocolMajor ProtocolMinor ProtocolVersion RfbEncodingCoRRE RfbEncodingCopyRect RfbEncodingHextile RfbEncodingLastRect RfbEncodingPointerPos RfbEncodingRRE RfbEncodingRaw RfbEncodingRichCursor RfbEncodingTight RfbEncodingXCursor RfbEncodingZRLE RfbEncodingZlib RfbEncodingZlibHex SecurityTypeNone SecurityTypeVNC SpecialEncodings UseLastRect'	poolDictionaries: 'EventSensorConstants'	category: 'RFB-Server'!!RFBSession commentStamp: 'ikp 3/19/2004 10:37' prior: 0!I am an active RFB session between a remote viewer and this image.  I implement the full version 3.7 RFB protocol (which is the most recent specification published by RealVNC.com), as well as some of the extensions defined by the popular 'TightVNC' viewer.You should not instantiate me directly.  See the class comment in RFBServer for further details.!DumberMenuMorph subclass: #RFBMenuMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBMenuMorph commentStamp: 'ikp 3/24/2004 00:17' prior: 0!I am a MenuMorph that knows how to retrieve update information from blocks in addition to the usual "target + selector" mechanism.!SharedQueue subclass: #RFBRegion	instanceVariableNames: 'rectangles lock'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBRegion commentStamp: 'ikp 3/5/2004 14:25' prior: 0!I represent a (possibly non-contiguous) damaged region in some display medium (such as a Form).  You send me "add: aRectangle" to add new areas to the region I represent.  Later you can send me "removeFirst" to retrieve individual areas in the region, or "removeAll" to retrieve a Collection of all the rectangles in the region.!EventSensor subclass: #RFBEventSensor	instanceVariableNames: 'rfbServer eventMutex'	classVariableNames: ''	poolDictionaries: ''	category: 'RFB-Server'!!RFBEventSensor commentStamp: 'ikp 3/5/2004 14:16' prior: 0!I am a kind of EventSensor that forwards mouse events and cursor change requests to the active RFBServer.  I replace the regular Sensor whenever the RFBServer is running (and remove myself whenever the RFBServer is shut down).!!RFBClientSocket methodsFor: 'accessing' stamp: 'ikp 3/23/2004 11:53'!getCPixel	"Answer the next compressed pixel read from the connection."	^getCPixel! !!RFBClientSocket methodsFor: 'accessing' stamp: 'ikp 3/23/2004 11:54'!getPixel	"Answer the next pixel read from the connection."	^getPixel! !!RFBClientSocket methodsFor: 'initialize-release' stamp: 'ikp 3/24/2004 04:40'!initialiseForDepth: depth mask: pixelMask byteSwapped: swapped	"Initialise the receiver to read pixels at the given depth with natural or swapped byte order."	depth == 8 ifTrue: [^getPixel := getCPixel := #next].	depth == 16 ifTrue: [^getPixel := getCPixel := swapped ifTrue: [#nextSwap16] ifFalse: [#next16]].	depth == 32 ifFalse: [self error: 'this cannot happen'].	getPixel := swapped ifTrue: [#nextSwap32] ifFalse: [#next32].	getCPixel := pixelMask < 16r01000000		ifTrue: [swapped ifTrue: [#nextSwap24] ifFalse: [#next24]]		ifFalse: [swapped ifTrue: [#nextSwap32] ifFalse: [#next32]]! !!RFBClientSocket methodsFor: 'initialize-release' stamp: 'ul 7/8/2011 22:37'!initialize	"Set the default conditions in the receiver."	super initialize.	getPixel := #next.	pixelBuffer := ByteArray new: 4! !!RFBClientSocket methodsFor: 'accessing' stamp: 'ikp 3/23/2004 02:59'!next	"Answer the next byte from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 1.	^pixelBuffer at: 1! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:54'!next16	"Answer a 16-bit pixel in natural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 2.	^(			(pixelBuffer at: 1) bitShift: 8)		bitOr: 	(pixelBuffer at: 2)! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:54'!next24	"Answer a 24-bit pixel in natural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 3.	^((			(pixelBuffer at: 1) bitShift: 16)		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 3)! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:55'!next32	"Answer a 32-bit pixel in natural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 4.	^(((			(pixelBuffer at: 1) bitShift: 24)		bitOr: (	(pixelBuffer at: 2) bitShift: 16))		bitOr: (	(pixelBuffer at: 3) bitShift: 8))		bitOr: 	(pixelBuffer at: 4)! !!RFBClientSocket methodsFor: 'accessing' stamp: 'ikp 3/22/2004 22:35'!nextCPixel	"Answer the next compressed pixel from the connection."	^self perform: getCPixel! !!RFBClientSocket methodsFor: 'decoding' stamp: 'ikp 3/23/2004 07:32'!nextHextileBounds: origin	"Answer the next byte decoded as a hextile subrect bounds at the given origin."	^self nextHextileOrigin + origin extent: self nextHextileExtent! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 07:29'!nextHextileExtent	"Answer the next byte decoded as a hextile subrect extent."	| byte |	byte := self next.	^((byte bitShift: -4) + 1) @ ((byte bitAnd: 16r0F) + 1)! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 07:29'!nextHextileOrigin	"Answer the next byte decoded as a hextile subrect origin."	| byte |	byte := self next.	^(byte bitShift: -4) @ (byte bitAnd: 16r0F)! !!RFBClientSocket methodsFor: 'accessing' stamp: 'ikp 3/22/2004 20:26'!nextPixel	"Answer the next pixel from the connection."	^self perform: getPixel! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:55'!nextSwap16	"Answer a 16-bit pixel in unnatural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 2.	^(			(pixelBuffer at: 2) bitShift: 8)		bitOr: 	(pixelBuffer at: 1)! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:55'!nextSwap24	"Answer a 24-bit pixel in unnatural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 3.	^((			(pixelBuffer at: 3) bitShift: 16)		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 1)! !!RFBClientSocket methodsFor: 'private' stamp: 'ikp 3/23/2004 02:56'!nextSwap32	"Answer a 32-bit pixel in unnatural byte order read from the connection."	self receiveData: pixelBuffer startingAt: 1 count: 4.	^(((			(pixelBuffer at: 4) bitShift: 24)		bitOr: (	(pixelBuffer at: 3) bitShift: 16))		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 1)! !!RFBClientSocket methodsFor: 'receiving' stamp: 'ikp 3/23/2004 04:33'!receiveForm: aForm in: bounds	"Read the contents of aForm from the receiver.  Note: this is VERY inefficient.  Decoders generally read a ByteArray and then display it on their Form."	| poke |	poke := RFBBitBlt bitPokerToForm: aForm.	bounds top to: bounds bottom - 1 do:		[:y | bounds left to: bounds right - 1 do:			[:x | poke pixelAt: x@y put: self nextPixel]]! !!RFBSocket class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 03:10'!acceptFrom: aSocket	"Answer a new RFBSocket for the connection just accepted on aSocket."	^RFBSocketInstances add: (super new acceptFrom: aSocket)! !!RFBSocket class methodsFor: 'private' stamp: 'ikp 3/20/2004 07:38'!addressAndPortFor: nameAndDisplay offset: portOffset	"Answer the host address and port number for the given host name and display number."	| address |	(address := NetNameResolver addressForName: nameAndDisplay first) isNil ifTrue: [^nil].	^Array with: address with: nameAndDisplay second + portOffset! !!RFBSocket class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 07:51'!connectedToServer	"Answer a RFBSocket (forward) connected to a remote server."	^self connectedWithPrompt: 'Server address?' offset: ServerPortOffset! !!RFBSocket class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 07:51'!connectedToViewer	"Answer a RFBSocket (reverse) connected to a remote viewer."	^self connectedWithPrompt: 'Viewer address?' offset: ViewerPortOffset! !!RFBSocket class methodsFor: 'private' stamp: 'ikp 3/23/2004 03:28'!connectedWithPrompt: promptString offset: portOffset	"Prompt for a server or viewer address.  Answer a RFBSocket connected to the address with the given portOffset."	| nameDisplay addrPort socket |	(nameDisplay := self requestHostAndDisplay: promptString) isNil ifTrue: [^nil].	(addrPort := self addressAndPortFor: nameDisplay offset: portOffset) isNil ifTrue: [^nil].	[socket := self newTCP connectTo: addrPort first port: addrPort second]		on: Exception		do:			[self inform: 'Could not connect to ' , nameDisplay first , ':' , addrPort second printString.			 ^nil].	^socket! !!RFBSocket class methodsFor: 'class initialisation' stamp: 'ikp 3/20/2004 09:21'!initialize	"RFBSocket initialize"	ServerPortOffset := 5900.	ViewerPortOffset := 5500.	LastServerAddress := 'hostName:displayNumber'.	SendTimeout := 60.	MaximumTransmissionUnit := 1450.	"Conservative: min MTU for PPP with NAT."	RFBSocketInstances := IdentitySet new.	Smalltalk		addToStartUpList: self;		addToShutDownList: self! !!RFBSocket class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 03:09'!new	"Answer a new, unconnected, undifferentiated socket."	^RFBSocketInstances add: super new! !!RFBSocket class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 03:09'!newTCP	"Answer a new, unconnected TCP socket."	^RFBSocketInstances add: super newTCP! !!RFBSocket class methodsFor: 'private' stamp: 'klib 2/27/2012 14:54'!requestHostAndDisplay: promptString	"Request and parse an address in the form 'hostname' or 'hostname:<dpy>'.  Answer an array containing the host name and display number, or nil if there was a problem."	"RFBSocket requestHostAndDisplay: 'test me?'"	| display hostName hostAndDisplay |	(hostAndDisplay := UIManager default request: promptString initialAnswer: LastServerAddress) isEmptyOrNil ifTrue: [^nil].	hostAndDisplay := hostAndDisplay findTokens: $:.	(hostAndDisplay size < 1 or: [hostAndDisplay size > 2])		ifTrue:			[self inform: 'I could not parse that address.  Use: hostname[:<displayNumber>]'.			 ^nil].	hostName := hostAndDisplay first withBlanksTrimmed.	display := hostAndDisplay size == 2		ifTrue: [hostAndDisplay second withBlanksTrimmed asInteger]		ifFalse: [0].	display isNil		ifTrue:			[self inform: 'I could not parse the display number.'.			 ^nil].	LastServerAddress := hostName , ':' , display printString.	^Array with: hostName with: display! !!RFBSocket class methodsFor: 'constants' stamp: 'ikp 3/20/2004 07:44'!serverPortOffset	"Answer the offset (from the display number) of the port on which servers listen for forward connections."	^ServerPortOffset! !!RFBSocket class methodsFor: 'snapshot' stamp: 'ikp 3/7/2004 16:00'!shutDown: quitting	"We're about to snapshot and quit: shut down any open connections."	RFBSocketInstances := RFBSocketInstances select: [:sock | sock isValid and: [sock isConnected]].	(quitting and: [RFBSocketInstances notEmpty])		ifTrue: [RFBSocketInstances do: [:sock | sock close]]! !!RFBSocket class methodsFor: 'snapshot' stamp: 'ikp 3/7/2004 16:01'!startUp: resuming	"We're coming back from snapshot and quit.  Close any connections that were left open in the snapshot."	(resuming and: [RFBSocketInstances notEmpty])		ifTrue: [RFBSocketInstances do: [:sock | sock close]]! !!RFBSocket class methodsFor: 'constants' stamp: 'ikp 3/20/2004 07:44'!viewerPortOffset	"Answer the offset (from the display number) of the port on which viewers listen for reverse connections."	^ViewerPortOffset! !!RFBSocket methodsFor: 'connecting' stamp: 'ikp 2/25/2004 13:36'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^(RFBSocket acceptFrom: self)"	setOption: 'TCP_NODELAY' value: 1;		yourself"! !!RFBSocket methodsFor: 'closing' stamp: 'ikp 3/19/2004 02:58'!close	"Close the receiver's connection and remove it from the list of active sockets."	super close.	RFBSocketInstances remove: self ifAbsent: [].	semaphore isNil ifFalse: [semaphore signal].	readSemaphore isNil ifFalse: [readSemaphore signal].	writeSemaphore isNil ifFalse: [writeSemaphore signal].! !!RFBSocket methodsFor: 'closing' stamp: 'ikp 3/19/2004 02:59'!closeAndDestroy	"Close and destroy the receiver."	self close; closeAndDestroy: 1.	RFBSocketInstances remove: self ifAbsent: []! !!RFBSocket methodsFor: 'connecting' stamp: 'ikp 3/8/2004 03:10'!connectTo: host port: port	"Connect the receiver to the given host and port number."	hostName := host.	^super connectTo: hostName port: port! !!RFBSocket methodsFor: 'closing' stamp: 'ikp 3/8/2004 03:11'!destroy	"Destroy all external resources associated with the receiver."	super destroy.	RFBSocketInstances remove: self ifAbsent: []! !!RFBSocket methodsFor: 'constants' stamp: 'ikp 3/7/2004 16:07'!maximumTransmissionUnit	"A real network implementation would know the precise value.  In the meantime answer a conservative upper limit."	^MaximumTransmissionUnit! !!RFBSocket methodsFor: 'accessing' stamp: 'ikp 3/7/2004 16:04'!name	"Answer the name of the peer."	^self isConnected		ifTrue: [hostName isNil ifTrue: [NetNameResolver stringFromAddress: self remoteAddress] ifFalse: [hostName]]		ifFalse: ['not connected']! !!RFBSocket methodsFor: 'accessing' stamp: 'ikp 3/7/2004 16:04'!name: aString	"Set the name of the peer."	hostName := aString! !!RFBSocket methodsFor: 'primitives' stamp: 'ikp 3/7/2004 16:05'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed.  Overriden to avoid primitive fail error in superclass."	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>! !!RFBSocket methodsFor: 'primitives' stamp: 'ikp 3/7/2004 16:05'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket.  Overridden to avoid primitive failure when the socket is closed asynchronously (or left open across snapshot and quit)."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	^false! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/20/2004 09:02'!receive: aMessage	"Receive aMessage.  The message type has already been read and stored in aMessage (which is an instance of the corresponding message class).  Fill the remainder of aMessage from incoming bytes, starting with the byte after the message type."	^self receiveData: aMessage startingAt: 2! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/20/2004 09:00'!receiveData: stringOrByteArray	"Receive an incoming message completely."	^self receiveData: stringOrByteArray startingAt: 1! !!RFBSocket methodsFor: 'receiving' stamp: 'JanStruz 7/1/2011 23:46'!receiveData: stringOrByteArray startingAt: initialIndex	"Receive an incoming message."	| index count |	index := initialIndex.	[(index <= stringOrByteArray size) and: [self isConnected]] 			whileTrue:			[count := self receiveDataInto: stringOrByteArray startingAt: index.			 index := index + count].	^stringOrByteArray! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/22/2004 04:07'!receiveData: bytesOrWords startingAt: index count: count	"This is a bug fix implementation.  (The core Socket class does not implement any methods to receive a bounded amount of data.)  Receive count bytes of bytesOrWords starting at index, answer the number of bytes read."	| currIndex lastIndex nRead |	currIndex := index.	lastIndex := currIndex + count.	[currIndex < lastIndex]		whileTrue:			[self waitForData.			 nRead := self						primSocket: socketHandle						receiveDataInto: bytesOrWords						startingAt: currIndex						count: lastIndex - currIndex.			 currIndex := currIndex + nRead].	^count! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/20/2004 09:02'!receiveNew: eventClass	"Answer a new RFBMessage initialised from received data."	^self receiveData: eventClass new startingAt: 2! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/20/2004 11:06'!receiveString	"Answer a String constructed by reading a 4-byte length followed by length characters."	| length |	length := (self receiveData: (RFBMessage new: 4)) unsignedLongAt: 1.	^self receiveData: (String new: length)! !!RFBSocket methodsFor: 'running' stamp: 'ikp 3/20/2004 08:21'!runSafely: aBlock	"Repeatedly execute aBlock until the connection failes or an error is signaled.  If debugging is enabled in RFBServer, open a debugger on the error context for the purposes of developer enlightenment."	[[[self isValid and: [self isConnected]] whileTrue: aBlock]			on: Error			do: [:ex |				Transcript cr; show: 'RFB: caught ' , ex printString.				RFBServer debugging					ifTrue:						[Transcript endEntry.						 self halt]]]		ensure: [self closeAndDestroy]! !!RFBSocket methodsFor: 'sending' stamp: 'ikp 3/1/2004 07:12'!sendData: bytesOrWords	"This is a bug-fix implementation only.  Socket>>sendData: sends the buffer #size, rather than #byteSize, which is somewhat unfortunate when the buffer happens to be a WordArray."	^self sendData: bytesOrWords startingAt: 1 count: bytesOrWords byteSize! !!RFBSocket methodsFor: 'sending' stamp: 'ikp 3/7/2004 15:45'!sendData: bytesOrWords startingAt: index count: count	"This is a bug-fix implementation only.  Socket>>sendData: asks the buffer for its #size, rather than its #byteSize, which is somewhat unfortunate when the buffer happens to be a WordArray."	| currIndex lastIndex sent |	currIndex := index.	lastIndex := currIndex + count.	[currIndex < lastIndex]		whileTrue:			[(self waitForSendDoneFor: self sendTimeout)				ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].			 sent := self primSocket: socketHandle				sendData: bytesOrWords				startIndex: currIndex				count: (lastIndex - currIndex min: self maximumTransmissionUnit).			 currIndex := currIndex + sent].	^count! !!RFBSocket methodsFor: 'sending' stamp: 'ikp 3/20/2004 09:11'!sendStream: aStream	"Write the entire contents of aStream on the receiver's connection."	^self sendData: aStream originalContents count: aStream size! !!RFBSocket methodsFor: 'constants' stamp: 'ikp 3/8/2004 03:10'!sendTimeout	"Answer the send timeout for writes on this socket."	^SendTimeout! !!RFBSocket methodsFor: 'receiving' stamp: 'ikp 3/21/2004 20:21'!waitForDataForMilliseconds: timeout	"Wait for the given nr of milliseconds for data to arrive."	| deadline |	deadline := Time millisecondClockValue + timeout.	[Time millisecondClockValue < deadline]		whileTrue: [			(self primSocketReceiveDataAvailable: socketHandle) ifTrue: [^true].			self isConnected ifFalse: [^false].			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^false! !!RFBSocket methodsFor: 'sending' stamp: 'ul 8/8/2012 23:56'!waitForSendDoneFor: timeout	"This is a (dual) bug-fix implementation only.  Broken VMs (like the Windoze one) confuse the read and write Semaphores (bug #1), and the new Socket implementation fails utterly to deal properly with the situation (bug #2)."	| remainingTime drainDelay sendDone |	sendDone := false.	remainingTime := timeout * 1000.	drainDelay := Delay forMilliseconds: 5.	"Time to send 4 MTUs on a 10Mbps network."	"Avoid waiting on the writeSemaphore, otherwise the server read loop goes catatonic."	[self isConnected			and: [(sendDone := self primSocketSendDone: socketHandle) not			and: [remainingTime > 0]]]		whileTrue:			[drainDelay wait.			 remainingTime := remainingTime - 6].	^sendDone! !!RFBScrollPane methodsFor: 'geometry' stamp: 'ikp 3/23/2004 02:42'!contentBounds	"Answer the visible bounds of my contents in their local coordinate system."	| box |	box := scroller innerBounds translateBy: scroller transform offset.	"Clip the corner since ScrollPane does not calculate its deltas properly and overshoots."	^(box origin corner: (box corner min: scroller localSubmorphBounds corner)) truncated! !!RFBScrollPane methodsFor: 'geometry' stamp: 'ikp 3/24/2004 04:19'!extent: aPoint	"Someone just resized the window.  Inform the model that it needs to refresh its contents in any newly-exposed areas."	| prevBounds newBounds |	(model isNil or: [model isActive not]) ifTrue: [^super extent: aPoint].	prevBounds := self contentBounds.	super extent: aPoint.	newBounds := self contentBounds.	model sendFullUpdateRequestForRegion: (newBounds areasOutside: prevBounds); changed! !!RFBScrollPane methodsFor: 'menu' stamp: 'ikp 3/23/2004 11:56'!getMenu: shiftKeyState	"Answer a menu for the scrollbar button."	^model getMenu: shiftKeyState! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:58'!handleMouseMove: anEvent	"Handle a motion event.  Override to always pass motion events to the client."	model isActive ifFalse: [^super handleMouseMove: anEvent].	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent hand hasSubmorphs) ifTrue:[^self].	(anEvent anyButtonPressed and:[anEvent hand mouseFocus ~~ self]) ifTrue:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:57'!handlesKeyboard: anEvent	"Answer whether we want to process keyboard input."	^model isActive! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:59'!handlesMouseDown: evt	"Answer whether we want to handle the event."	^model isActive and: [self innerBounds containsPoint: evt position]! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:56'!handlesMouseOver: evt	"Answer whether we are interested in mouse events."	^model isActive and: [self handlesMouseDown: evt]! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:54'!keyDown: anEvent	"Pass the event to the client."	model keyDown: anEvent! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:56'!keyStroke: anEvent	"Pass the event to the client."	model keyStroke: anEvent! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:56'!keyUp: anEvent	"Pass the event to the client."	model keyUp: anEvent! !!RFBScrollPane methodsFor: 'geometry' stamp: 'ikp 3/23/2004 02:49'!leftoverScrollRange	"Answer the entire scrolling range minus the currently viewed area.  Overridden from the inherited version for two reasons: (1) TwoWayScrollPane defines this method to arbitrarily add 25% empty space to the right and below the actual contents, presumably for some additional scrolling for StringHolders, but we definitely don't want anything like that; and (2) the inherited version fails utterly to account for the space occupied by the scroll bars.  The version below is what the inherited version should have implemented all along.  Ho hum."	^ self totalScrollRange - self innerBounds extent		"WITHOUT 25% bottom-right space"		+ (yScrollBar width @ xScrollBar height)			"WITH scrollbars accounted for"			max: 0@0! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:56'!mouseDown: evt	"Pass the event to the client."	model mouseDown: (evt transformedBy: (scroller transformFrom: self))! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 03:00'!mouseEnter: evt	"model mouseEnter: evt"! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 03:00'!mouseLeave: evt	"model mouseLeave: evt"! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:57'!mouseMove: evt	"Pass the event to the client."	model mouseMove: (evt transformedBy: (scroller transformFrom: self))! !!RFBScrollPane methodsFor: 'events' stamp: 'ikp 3/23/2004 11:56'!mouseUp: evt	"Pass the event to the client."	model mouseUp: (evt transformedBy: (scroller transformFrom: self))! !!RFBScrollPane methodsFor: 'accessing' stamp: 'ikp 3/23/2004 11:57'!rfbClient: aClient	"Set the receiver's model."	model := aClient! !!RFBScrollPane methodsFor: 'geometry' stamp: 'ikp 3/24/2004 04:19'!xScrollBarValue: scrollValue 	"The window just scrolled.  Pass the message up and then have the client update any newly-exposed regions."	| prevBounds newBounds |	prevBounds := self contentBounds.	super xScrollBarValue: scrollValue.	newBounds := self contentBounds.	model sendFullUpdateRequestForRegion: (newBounds areasOutside: prevBounds)! !!RFBScrollPane methodsFor: 'geometry' stamp: 'ikp 3/24/2004 04:19'!yScrollBarValue: scrollValue	"The window just scrolled.  Pass the message up and then have the client update any newly-exposed regions."	| prevBounds newBounds |	prevBounds := self contentBounds.	super yScrollBarValue: scrollValue.	newBounds := self contentBounds.	model sendFullUpdateRequestForRegion: (newBounds areasOutside: prevBounds)! !!RFBBell class methodsFor: 'instance creation' stamp: 'ikp 3/4/2004 21:23'!new	"RFBBell new"	^super		new: 1					"card1(type)"		type: RfbBell! !!RFBClientCutText class methodsFor: 'instance creation' stamp: 'ikp 3/2/2004 21:14'!new	"RFBClientCutText new"	^super		new: 8					"card1(type) + pad(3) + card32(length)"		type: RfbClientCutText! !!RFBClientCutText methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:16'!length	"Answer the length of the byte data following this message."	^self unsignedLongAt: 5! !!RFBClientCutText methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:16'!length: anInteger	"Set the length of the byte data following this message."	self unsignedLongAt: 5 put: anInteger! !!RFBCoRRERectangle class methodsFor: 'instance creation' stamp: 'ikp 3/7/2004 20:17'!new	"Answer a RFBMessage that represents CoRRE rectangles."	^super new: 4! !!RFBCoRRERectangle methodsFor: 'accessing' stamp: 'ikp 3/23/2004 08:28'!bounds	"Answer the receiver's bounds."	^(self byteAt: 1) @ (self byteAt: 2) extent: (self byteAt: 3) @ (self byteAt: 4)! !!RFBCoRRERectangle methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:16'!bounds: bounds	"Set the receiver's bounds."	self		byteAt: 1 put: bounds left;		byteAt: 2 put: bounds top;		byteAt: 3 put: bounds width;		byteAt: 4 put: bounds height! !!RFBCoRRERectangle methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:17'!x: x y: y w: w h: h	"Set the receiver's bounds."	self		byteAt: 1 put: x;		byteAt: 2 put: y;		byteAt: 3 put: w;		byteAt: 4 put: h! !!RFBFixColourMapEntries class methodsFor: 'instance creation' stamp: 'ikp 3/2/2004 21:26'!firstColour: firstColour nColours: nColours	"RFBFixColourMapEntries firstColour: 0 nColours: 256"	^(self new: nColours)		firstColour: firstColour;		nColours: nColours! !!RFBFixColourMapEntries class methodsFor: 'instance creation' stamp: 'ikp 3/2/2004 21:23'!new	"RFBFixColourMapEntries new"	^super		new: 6					"card8(type) + pad[1] + CARD16(firstColour) + CARD16(nColours)								+ card16[3*nColours]"		type: RfbFixColourMapEntries! !!RFBFixColourMapEntries class methodsFor: 'instance creation' stamp: 'ikp 3/2/2004 21:24'!new: nColours	"RFBFixColourMapEntries new: 42"	^super		new: 6					"card8(type) + pad[1] + CARD16(firstColour) + CARD16(nColours)"			+ (6 * nColours)		"+ card16[3*nColours]"		type: RfbFixColourMapEntries! !!RFBFixColourMapEntries methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:32'!firstColour	"Answer the index of the first colour represented in the pixel data following this message."	^self unsignedShortAt: 3! !!RFBFixColourMapEntries methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:31'!firstColour: firstColour	"Set the first colour index in the pixel data following this message."	self unsignedShortAt: 3 put: firstColour! !!RFBFixColourMapEntries methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:32'!nColours	"Answer the number of colours represented in the pixel data following this message."	^self unsignedShortAt: 5! !!RFBFixColourMapEntries methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:31'!nColours: nColours	"Set the number of colours following this message."	self unsignedShortAt: 5 put: nColours! !!RFBFramebufferUpdate class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:25'!new	"RFBFramebufferUpdate new"	^super		new: 4					"type + pad[1] + CARD16(nrects)"		type: RfbFramebufferUpdate! !!RFBFramebufferUpdate methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:24'!nRects	"Answer the number of rectangles following this message."	^self unsignedShortAt: 3! !!RFBFramebufferUpdate methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:24'!nRects: nRects	"Set the number of rectangles to be sent/received in this message."	self unsignedShortAt: 3 put: nRects! !!RFBFramebufferUpdateRectHeader class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:26'!new	"Answer an empty update rectangle header."	^super new: 12! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:29'!bounds	"Answer the bounds of the update rectangle."	^self x @ self y extent: (self width @ self height)! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:25'!bounds: aRect type: type	"Set the contents of the receiver to represent a rectangle of the specified type."	self		unsignedShortAt: 1 put: aRect left;		unsignedShortAt: 3 put: aRect top;		unsignedShortAt: 5 put: aRect width;		unsignedShortAt: 7 put: aRect height;		unsignedLongAt: 9 put: type! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 06:40'!cursorExtent	"Answer the cursor extent encoded in the receiver."	^self width @ self height! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 06:39'!cursorHotSpot	"Answer the cursor hot spot encoded in the receiver."	^self x @ self y! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:26'!cursorHotSpot: offset extent: extent type: type	"Set the contents of the receiver to represent the header of a pseudo-encoded cursor shape update."	self		unsignedShortAt: 1 put: offset x;		unsignedShortAt: 3 put: offset y;		unsignedShortAt: 5 put: extent x;		unsignedShortAt: 7 put: extent y;		unsignedLongAt: 9 put: type! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:25'!cursorPos: aPoint type: type	"Set the contents of the receiver appropriately for a pseudo-encoded cursor position update."	self		unsignedShortAt: 1 put: aPoint x;		unsignedShortAt: 3 put: aPoint y;		unsignedShortAt: 5 put: 0;		unsignedShortAt: 7 put: 0;		unsignedLongAt: 9 put: type! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:30'!height	"Answer the height of the update rectangle."	^self unsignedShortAt: 7! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:27'!type	"Answer the type of the rectangle represented by the receiver."	^self  unsignedLongAt: 9! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:26'!type: type	"Set the type of the rectangle represented by the receiver."	self		atAllPut: 0;		unsignedLongAt: 9 put: type! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:30'!width	"Answer the width of the update rectangle."	^self unsignedShortAt: 5! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:29'!x	"Answer the left edge of the update rectangle."	^self unsignedShortAt: 1! !!RFBFramebufferUpdateRectHeader methodsFor: 'accessing' stamp: 'ikp 3/21/2004 04:29'!y	"Answer the top edge of the update rectangle."	^self unsignedShortAt: 3! !!RFBFramebufferUpdateRequest class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 22:41'!bounds: boundingBox incremental: incrementalFlag	"Answer a framebuffer update request for the given boundingBox."	"RFBFramebufferUpdateRequest bounds: (10@20 extent: 30@40) incremental: true"	^self new bounds: boundingBox incremental: incrementalFlag! !!RFBFramebufferUpdateRequest class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:25'!new	"RFBFramebufferUpdateRequest new"	^super		new: 10					"type + incremental + x y w h"		type: RfbFramebufferUpdateRequest! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/23/2004 11:54'!bounds: boundingBox incremental: incrementalFlag	"Set the bounds of the update request."	self		byteAt: 2 put: (incrementalFlag ifTrue: [1] ifFalse: [0]);		unsignedShortAt: 3 put: boundingBox left;		unsignedShortAt: 5 put: boundingBox top;		unsignedShortAt: 7 put: boundingBox width;		unsignedShortAt: 9 put: boundingBox height! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:27'!h	"Answer the height of the update represented by the receiver."	^self unsignedShortAt: 9! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:30'!incremental	"Answer whether the update represented by the receiver is incremental.  Incremental updates are just that: updates.  The server is free to send less data than requested if no damage has occurred in the requested region.  Non-incremental updates are to repair pixels lost in the viewer, and all requested data should be sent."	^(self byteAt: 2) ~~ 0! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:28'!w	"Answer the width of the update represented by the receiver."	^self unsignedShortAt: 7! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:27'!x	"Answer the x coordinate of the update represented by the receiver."	^self unsignedShortAt: 3! !!RFBFramebufferUpdateRequest methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:27'!y	"Answer the y coordinate of the update represented by the receiver."	^self unsignedShortAt: 5! !!RFBKeyEvent class methodsFor: 'instance creation' stamp: 'ikp 3/22/2004 04:31'!key: keyCode down: downFlag	"RFBKeyEvent key: 42 down: true"	^self new key: keyCode down: downFlag! !!RFBKeyEvent class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:26'!new	"RFBKeyEvent new"	^super		new: 8					"type + down + pad[2] + key"		type: RfbKeyEvent! !!RFBKeyEvent methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:30'!down	"Answer whether the receiver represents a key down event.  (If not, then it is a key up event.)"	^(self byteAt: 2) ~~ 0! !!RFBKeyEvent methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:30'!key	"Answer the keysym for the event represented by the receiver."	^self unsignedLongAt: 5! !!RFBKeyEvent methodsFor: 'accessing' stamp: 'ikp 3/22/2004 04:32'!key: keyCode down: downFlag	"Set the keysym and down flag for the event represented by the receiver."	self		byteAt: 2 put: (downFlag ifTrue: [1] ifFalse: [0]);		unsignedLongAt: 5 put: keyCode! !!RFBMessage class methodsFor: 'class initialisation' stamp: 'ikp 3/5/2004 13:10'!initialize	"RFBMessage initialize"	"Handshake message opcodes."	RfbConnFailed := 0.	RfbNoAuth := 1.	RfbVncAuth := 2.	"Authentication message opcodes."	RfbVncAuthOK := 0.	RfbVncAuthFailed := 1.	RfbVncAuthTooMany := 2.	"Server -> Client message types."	RfbFramebufferUpdate := 0.	RfbSetColourMapEntries := 1.	RfbBell := 2.	RfbServerCutText := 3.	"Client -> Server message types."	RfbSetPixelFormat := 0.	RfbFixColourMapEntries := 1.	RfbSetEncodings := 2.	RfbFramebufferUpdateRequest := 3.	RfbKeyEvent := 4.	RfbPointerEvent := 5.	RfbClientCutText := 6! !!RFBMessage class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:35'!new	"Answer a new, empty message.  Only my subclasses know how big each kind of message should be, so always defer to them."	^self subclassResponsibility! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 2/28/2004 02:53'!new: size opcode: opcode	"RFBMessage new: 4 opcode: 42"	^(super new: size) unsignedLongAt: 1 put: opcode; yourself! !!RFBMessage class methodsFor: 'protocol' stamp: 'ikp 3/8/2004 02:35'!new: size type: type	"Answer an empty normal message of the given size and type."	^(super new: size) type: type! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 3/20/2004 09:31'!newConnFailed: reason	"RFBMessage newConnFailed: 'no idea why'"	^(self new: 8 + reason size opcode: RfbConnFailed)		unsignedLongAt: 5 put: reason size;		replaceFrom: 9 to: 8 + reason size with: reason! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 3/20/2004 09:31'!newNoAuth	"RFBMessage newNoAuth"	^self new: 4 opcode: RfbNoAuth! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 3/20/2004 09:32'!newVncAuth: challenge	"RFBMessage newVncAuth: ((ByteArray new: 16) atAllPut: 42)"	^(self		new: 20					"card32(rfbVncAuth) + card8[16](challenge)"		opcode: RfbVncAuth)		replaceFrom: 5 to: 20 with: challenge! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 3/20/2004 09:32'!newVncAuthFailed	"RFBMessage newVncAuthFailed"	^self new: 4 opcode: RfbVncAuthFailed! !!RFBMessage class methodsFor: 'handshake' stamp: 'ikp 3/20/2004 09:33'!newVncAuthOK	"RFBMessage newVncAuthOK"	^self new: 4 opcode: RfbVncAuthOK! !!RFBMessage class methodsFor: 'protocol' stamp: 'ikp 3/20/2004 08:44'!protocolVersionMajor: majorNumber minor: minorNumber	"Answer a protocol version string suitable for exchange during handshake."	"RFBMessage protocolVersionMajor: 42 minor: 666"	| protocolVersion major minor |	(protocolVersion := 'RFB 000.000 ' copy) at: 12 put: Character lf.	major := majorNumber printString.	minor := minorNumber printString.	protocolVersion		replaceFrom: 8 - major size to: 7 with: major;		replaceFrom: 12 - minor size to: 11 with: minor.	^protocolVersion! !!RFBMessage class methodsFor: 'constants' stamp: 'ikp 3/20/2004 09:35'!rfbNoAuth	"Answer the number representing authentication/security type 'none'."	^RfbNoAuth! !!RFBMessage class methodsFor: 'constants' stamp: 'ikp 3/20/2004 09:35'!rfbVncAuth	"Answer the number representing authentication/security type 'VNC'."	^RfbVncAuth! !!RFBMessage class methodsFor: 'constants' stamp: 'ikp 3/20/2004 10:07'!rfbVncAuthOK	"Answer the opcode representing authentication success."	^RfbVncAuthOK! !!RFBMessage methodsFor: 'handshake' stamp: 'ikp 3/8/2004 02:32'!opcode	"Answer the 4-byte opcode of the connection handshake message represented by the receiver."	^self unsignedLongAt: 1! !!RFBMessage methodsFor: 'handshake' stamp: 'ikp 3/8/2004 02:33'!opcode: card32	"Set the opcode of the protocol handshake message represented by the receiver."	self unsignedLongAt: 1 put: card32! !!RFBMessage methodsFor: 'comparing' stamp: 'ikp 3/8/2004 02:31'!species	"Answer the class in which RFBMessage should be copied and compared."	^ByteArray! !!RFBMessage methodsFor: 'protocol' stamp: 'ikp 3/21/2004 08:36'!type	"Answer the (1-byte) type of the normal message represented by the receiver."	^self byteAt: 1! !!RFBMessage methodsFor: 'protocol' stamp: 'ikp 3/8/2004 02:34'!type: card8	"Set the type of the normal message represented by the receiver."	self byteAt: 1 put: card8! !!RFBMessage methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:34'!unsignedLongAt: index	"Answer the CARD32 data stored in the receiver at the given 1-relative index."	^self unsignedLongAt: index bigEndian: true! !!RFBMessage methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:34'!unsignedLongAt: index put: value	"Store a CARD32 value into the receiver at the given 1-relative index."	^self unsignedLongAt: index put: value bigEndian: true! !!RFBMessage methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:33'!unsignedShortAt: index	"Answer the CARD16 data at the given 1-relative index in the receiver."	^self unsignedShortAt: index bigEndian: true! !!RFBMessage methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:34'!unsignedShortAt: index put: value	"Store a CARD16 value into the receiver at the given 1-relative index."	^self unsignedShortAt: index put: value bigEndian: true! !!RFBPointerEvent class methodsFor: 'instance creation' stamp: 'ikp 3/21/2004 18:44'!buttonMask: mask position: aPoint	"RFBPointerEvent buttonMask: 42 position: 1@2"	^self new buttonMask: mask position: aPoint! !!RFBPointerEvent class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:26'!new	"RFBPointerEvent new"	^super		new: 6					"type + buttonMask + x + y"		type: RfbPointerEvent! !!RFBPointerEvent methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:57'!buttonMask	"Answer the bit mask corresponding to the buttons pressed when the event represented by the receiver was generated."	^self byteAt: 2! !!RFBPointerEvent methodsFor: 'accessing' stamp: 'ikp 3/21/2004 18:45'!buttonMask: mask position: aPoint	"Set the bit mask corresponding to the buttons pressed and position of the reveiver."	self		byteAt: 2 put: mask;		unsignedShortAt: 3 put: aPoint x;		unsignedShortAt: 5 put: aPoint y! !!RFBPointerEvent methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:56'!x	"Answer the x coordinate at which the pointer event represented by the receiver occurred."	^self unsignedShortAt: 3! !!RFBPointerEvent methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:55'!y	"Answer the y coordinate at which the pointer event represented by the receiver occurred."	^self unsignedShortAt: 5! !!RFBRREHeader class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:58'!new	"Answer a new, empty RRE encoding header message."	^super new: 4! !!RFBRREHeader methodsFor: 'accessing' stamp: 'ikp 3/23/2004 07:42'!nSubrects	"Answer the number of RRE-encoded rectangles that follow this message."	^self unsignedLongAt: 1! !!RFBRREHeader methodsFor: 'accessing' stamp: 'ikp 3/23/2004 07:42'!nSubrects: n	"Set the number of RRE-encoded rectangles that follow this message."	self unsignedLongAt: 1 put: n! !!RFBRectangle class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:58'!new	"Answer a new, empty rectangle."	^super new: 8! !!RFBRectangle methodsFor: 'accessing' stamp: 'ikp 3/23/2004 07:47'!bounds	"Answer the bounds of the rectangle represented by the receiver."	^(self unsignedShortAt: 1) @ (self unsignedShortAt: 3)		extent: (self unsignedShortAt: 5) @ (self unsignedShortAt: 7)! !!RFBRectangle methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:58'!bounds: bounds	"Set the bounds of the rectangle represented by the receiver."	self		unsignedShortAt: 1 put: bounds left;		unsignedShortAt: 3 put: bounds top;		unsignedShortAt: 5 put: bounds width;		unsignedShortAt: 7 put: bounds height! !!RFBRectangle methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:58'!x: x y: y w: w h: h	"Set the bounds of the rectangle represented by the receiver."	self		unsignedShortAt: 1 put: x;		unsignedShortAt: 3 put: y;		unsignedShortAt: 5 put: w;		unsignedShortAt: 7 put: h! !!RFBServerCutText class methodsFor: 'instance creation' stamp: 'ul 8/13/2012 03:01'!text: aStringOrText	"1 message-type + 3 padding + 4 length + text length"		| text |	text := aStringOrText asString withInternetLineEndings.	text := [ text convertToWithConverter: Latin1TextConverter new ]		ifError: [ 			"We cheat here a bit. The RFB protocol (up to and including version 3.8) doesn't support anything but Latin-1, but we don't want to raise errors or do nothing when the copied text cannot be converted to Latin-1, so we convert it to UTF-8 and mark the text with the UTF-8 BOM, this way some clients can detect that it's UTF-8 and are able to decode it properly."			#[16rEF 16rBB 16rBF] asString, text squeakToUtf8 ].	^(self new: 8 + text size type: RfbServerCutText)		length: text size;		text: text;		yourself		! !!RFBServerCutText methodsFor: 'accessing' stamp: 'kb 10/15/2008 16:04'!length: anInteger	self unsignedLongAt: 5 put: anInteger! !!RFBServerCutText methodsFor: 'accessing' stamp: 'kb 10/15/2008 16:06'!text: aByteString	self replaceFrom: 9 to: self size with: aByteString! !!RFBServerInitialisation class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 10:51'!extent: extent format: pixelFormat name: title	"Answer a new server initialisation message describing a desktop with the given extent, pixelFormat and title."	"RFBServerInitialisation extent: 666@42 format: RFBPixelFormat serverFormat name: 'The display with no name'"	^(self new: title size)		width: extent x;		height: extent y;		pixelFormat: pixelFormat;		nameLength: title size;		name: title! !!RFBServerInitialisation class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 10:33'!new	"Answer a new, empty server initialisation message.  Neither the length nor contents of the desktop title are included in the answer."	"RFBServerInitialisation new"	^super new: 4 + 16		"card16(w) card16(h) pixelFormat"! !!RFBServerInitialisation class methodsFor: 'instance creation' stamp: 'ikp 3/20/2004 10:31'!new: titleLength	"Answer a new, empty server initialisation message with enough room to store titleLength characters of desktop title."	"RFBServerInitialisation new: 5"	^super new: 4 + 16 + 4 + titleLength		"card16(w) card16(h) pixelFormat card32(len) card8[len]"! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:33'!height	"Answer the desktop height stored in the receiver."	^self unsignedShortAt: 3! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:38'!height: anInteger	"Set the desktop height stored in the receiver."	self unsignedShortAt: 3 put: anInteger! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:45'!name	"Answer the desktop name stored in the receiver."	| length |	length := self nameLength.	^length > 0		ifTrue: [(self copyFrom: 25 to: 24 + length) asString]		ifFalse: ['']! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:50'!name: aString	"Set the desktop name stored in the receiver."	self replaceFrom: 25 to: 24 + aString size with: aString! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:45'!nameLength	"Answer the length of the desktop name stored in the receiver."	^self size > 20 ifTrue: [self unsignedLongAt: 21] ifFalse: [0]! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:46'!nameLength: anInteger	"Set the length of the desktop name stored in the receiver."	self unsignedLongAt: 21 put: anInteger! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:34'!pixelFormat	"Answer the server pixel format stored in the receiver."	^RFBPixelFormat fromByteArray: (self copyFrom: 5 to: 20)! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:39'!pixelFormat: pixelFormat	"Set the server pixel format stored in the receiver."	self replaceFrom: 5 to: 20 with: pixelFormat asByteArray! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:33'!width	"Answer the desktop width stored in the receiver."	^self unsignedShortAt: 1! !!RFBServerInitialisation methodsFor: 'accessing' stamp: 'ikp 3/20/2004 10:38'!width: anInteger	"Set the desktop width stored in the receiver."	self unsignedShortAt: 1 put: anInteger! !!RFBSetEncodings class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:27'!new	"RFBSetEncodings new"	^super		new: 4					"type + pad[1] + nEncodings"		type: RfbSetEncodings! !!RFBSetEncodings class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:27'!new: nEncodings	"RFBSetEncodings new: 3"	^(super		new: 4 + (nEncodings * 4)		"type + pad[1] + nEncodings + CARD32[nEncodings]"		type: RfbSetEncodings)		nEncodings: nEncodings;		yourself! !!RFBSetEncodings methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:14'!encodingAt: index	"Answer the 32-bit encoding number stored in the receiver at the given index.  The index is 1-relative and counts encodings, not bytes."	^self unsignedLongAt: 1 + (index * 4)! !!RFBSetEncodings methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:15'!encodingAt: index put: encoding	"Store the encoding in the receiver at the given index.  The index is 1-relative and counts encodings, not bytes."	^self unsignedLongAt: 1 + (index * 4) put: encoding! !!RFBSetEncodings methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:14'!nEncodings	"Answer the number of encodings stored in the receiver."	^self unsignedShortAt: 3! !!RFBSetEncodings methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:15'!nEncodings: anInteger	"Set the number of encodings stored in the receiver."	^self unsignedShortAt: 3 put: anInteger! !!RFBSetPixelFormat class methodsFor: 'instance creation' stamp: 'ikp 2/28/2004 03:27'!new	"RFBSetPixelFormat new"	^super		new: 20					"type + pad[3] + pixelFormat"		type: RfbSetPixelFormat! !!RFBSetPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:12'!pixelFormat	"Answer the pixel format stored in the pixel format message represented by the receiver."	^RFBPixelFormat fromByteArray: (self copyFrom: 5 to: 20)! !!RFBSetPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:13'!pixelFormat: pixelFormat	"Set the pixel format in the message represented by the receiver."	self replaceFrom: 5 to: 20 with: pixelFormat asByteArray! !!RFBXCursorColoursHeader class methodsFor: 'class initialisation' stamp: 'ikp 2/28/2004 03:21'!initialize	"RFBXCursorColoursHeader initialize"	StandardCursorColours := self new		foreRed: 0 foreGreen: 0 foreBlue: 0		backRed: 255 backGreen: 255 backBlue: 255! !!RFBXCursorColoursHeader class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:59'!new	"Answer a new, empty cursor colours header message."	^self new: 6! !!RFBXCursorColoursHeader class methodsFor: 'constants' stamp: 'ikp 3/8/2004 02:59'!standardColours	"Answer a cursor colours header message describing the standard cursor colours: white background, black foreground."	^StandardCursorColours! !!RFBXCursorColoursHeader methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:00'!foreRed: fr foreGreen: fg foreBlue: fb backRed: br backGreen: bg backBlue: bb	"Set the receiver's foreground and background pixel colours."	self		byteAt: 1 put: fr;		byteAt: 2 put: fg;		byteAt: 3 put: fb;		byteAt: 4 put: br;		byteAt: 5 put: bg;		byteAt: 6 put: bb! !!RFBZRLEHeader class methodsFor: 'instance creation' stamp: 'ikp 3/16/2004 19:41'!new	"Answer a new, empty ZRLE encoding header message."	^super new: 4! !!RFBZRLEHeader methodsFor: 'accessing' stamp: 'ikp 3/18/2004 04:05'!length	"Answer the length of zlib-compressed RLE data following this message."	^self unsignedLongAt: 1! !!RFBZRLEHeader methodsFor: 'accessing' stamp: 'ikp 3/16/2004 19:42'!length: n	"Set the length of zlib-compressed RLE data following this message."	self unsignedLongAt: 1 put: n! !!RFBZLibReadStream methodsFor: 'initialise-release' stamp: 'ikp 3/24/2004 03:52'!continueOn: aCollection	"Restart the stream with new compressed data but do not clear the previous encoding dictionary."	source := aCollection.	sourcePos := bitPos := 0.	sourceLimit := aCollection size! !!RFBZLibReadStream methodsFor: 'initialise-release' stamp: 'ikp 3/23/2004 12:01'!getPixel: pixelSelector getCPixel: cpixelSelector	"Set the accessors for pixels and compressed pixels."	getPixel := pixelSelector.	getCPixel := cpixelSelector.	pixelBuffer := ByteArray new: 4! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/23/2004 10:27'!next16	"Answer a 16-bit pixel in natural byte order."	self next: 2 into: pixelBuffer.	^(			(pixelBuffer at: 1) bitShift: 8)		bitOr: 	(pixelBuffer at: 2)! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/23/2004 10:27'!next24	"Answer a 24-bit pixel in natural byte order."	self next: 3 into: pixelBuffer.	^((			(pixelBuffer at: 1) bitShift: 16)		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 3)! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/23/2004 10:28'!next32	"Answer a 32-bit pixel in natural byte order."	self next: 4 into: pixelBuffer.	^(((			(pixelBuffer at: 1) bitShift: 24)		bitOr: (	(pixelBuffer at: 2) bitShift: 16))		bitOr: (	(pixelBuffer at: 3) bitShift: 8))		bitOr: 	(pixelBuffer at: 4)! !!RFBZLibReadStream methodsFor: 'accessing' stamp: 'ikp 3/23/2004 12:01'!nextCPixel	"Answer the next compressed pixel."	^self perform: getCPixel! !!RFBZLibReadStream methodsFor: 'accessing' stamp: 'ikp 3/23/2004 12:01'!nextPixel	"Answer the next pixel."	^self perform: getPixel! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/24/2004 04:08'!nextSwap16	"Answer a 16-bit pixel in unnatural byte order."	self next: 2 into: pixelBuffer.	^(			(pixelBuffer at: 2) bitShift: 8)		bitOr: 	(pixelBuffer at: 1)! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/23/2004 10:28'!nextSwap24	"Answer a 24-bit pixel in unnatural byte order."	self next: 3 into: pixelBuffer.	^((			(pixelBuffer at: 3) bitShift: 16)		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 1)! !!RFBZLibReadStream methodsFor: 'private' stamp: 'ikp 3/23/2004 10:28'!nextSwap32	"Answer a 32-bit pixel in unnatural byte order."	self next: 4 into: pixelBuffer.	^(((			(pixelBuffer at: 4) bitShift: 24)		bitOr: (	(pixelBuffer at: 3) bitShift: 16))		bitOr: (	(pixelBuffer at: 2) bitShift: 8))		bitOr: 	(pixelBuffer at: 1)! !!RFBDisplayScreen methodsFor: 'private' stamp: 'ikp 3/9/2004 20:17'!argb8888ColourMap	"Answer a ColorMap that clears the alpha channel of all pixels to zero."	^ColorMap shifts: #(0 0 0 0) masks: #(16rFFFFFF 0 0 0)! !!RFBDisplayScreen methodsFor: 'user interface' stamp: 'ikp 3/7/2004 20:25'!beep	"Emit an audible warning sound on the local Display and on all remote Displays."	super beep.	rfbServer isNil ifFalse: [rfbServer beep]! !!RFBDisplayScreen methodsFor: 'user interface' stamp: 'ikp 3/7/2004 20:28'!beepPrimitive	"Emit an audible warning on the local Display and all remote viewers."	super beepPrimitive.	rfbServer isNil ifFalse: [rfbServer beep]! !!RFBDisplayScreen methodsFor: 'private' stamp: 'ikp 3/9/2004 20:17'!bgr233ColourMap	"Answer a ColorMap that maps pixels from 32-bit ARGB8888 space into the BGR233 space used by viewers running in 8-bit 'true colour' mode."	^ColorMap colors:		((Color cachedColormapFrom: 8 to: 32) collect: [:pv |			((((pv bitShift: -16-5)) bitAnd: 7) bitShift: 0)			bitOr: (((((pv bitShift: -8-5)) bitAnd: 7) bitShift: 3)			bitOr: ((((pv bitShift: -0-6)) bitAnd: 3) bitShift: 6))])! !!RFBDisplayScreen methodsFor: 'bordering' stamp: 'ikp 3/7/2004 20:26'!border: rect width: borderWidth rule: rule fillColor: fillColor	"Paint a border in the given rect and propagate the corresponding damage regions to all active remote viewers."	| w h hx vx |	super border: rect width: borderWidth rule: rule fillColor: fillColor.	rfbServer isNil		ifFalse:		[w := rect width.		 h := rect height.		 hx := w @ borderWidth.		 vx := borderWidth @ h.		 rfbServer			invalidate: (rect topLeft extent: hx);			invalidate: (rect topLeft extent: vx);			invalidate: (rect topRight - (borderWidth @ 0) extent: vx);			invalidate: (rect bottomLeft - (0 @ borderWidth) extent: hx)]! !!RFBDisplayScreen methodsFor: 'displaying' stamp: 'ikp 3/7/2004 20:27'!forceToScreen: aRectangle	"Force the contents of the Display within aRectangle to be drawn on the physical screen and in all remote viewers."	super forceToScreen: aRectangle.	rfbServer isNil ifFalse: [rfbServer invalidate: aRectangle]! !!RFBDisplayScreen methodsFor: 'private' stamp: 'ikp 3/9/2004 20:13'!newDepthNoRestore: pixelDepth	"Change the depth of the receiver, propagating the change to all remote viewers."	super newDepthNoRestore: pixelDepth.	self setColourMap.	rfbServer isNil ifFalse: [rfbServer newDepth: pixelDepth]! !!RFBDisplayScreen methodsFor: 'accessing' stamp: 'ikp 3/9/2004 20:13'!rfbServer: server	"Set the receiver's RFB server."	rfbServer := server.	self setColourMap! !!RFBDisplayScreen methodsFor: 'private' stamp: 'ikp 3/9/2004 20:22'!setColourMap	"Set the colourMap of the receiver based on its current depth.  If the depth is 32, use a colour map that clears the alpha channel (see #rgbContents: for the rationale).  If the depth is 8, use a colour map that converts Squeak's indexed pixel values into RFB's BGR233 pixel format."	colourMap := depth == 32		ifTrue: [self argb8888ColourMap]		ifFalse:			[depth == 8				ifTrue: [self bgr233ColourMap]]! !!OldRFBDamageRecorder class methodsFor: 'instance creation' stamp: 'ikp 3/1/2004 07:43'!forDisplay	^self forForm: Display! !!OldRFBDamageRecorder class methodsFor: 'instance creation' stamp: 'ikp 2/29/2004 19:46'!forForm: aForm	^(self extent: aForm extent depth: 1) setCache: aForm! !!OldRFBDamageRecorder class methodsFor: 'class initialisation' stamp: 'ikp 3/3/2004 03:40'!initialize	"RFBDamageRecorder initialize"	DamageWidth := 64.	DamageHeight := 64.! !!OldRFBDamageRecorder methodsFor: 'damage regions' stamp: 'ikp 3/1/2004 05:22'!coalesceDamage: rects	^self coalesceSortedDamage:		(rects asSortedCollection: [:r :s | r top == s top											ifTrue: [r left < s left]											ifFalse: [r top < s top]])			asOrderedCollection"RFBDamageRecorder new coalesceDamage: (OrderedCollection new).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1);	yourself).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1);	add: (2@1 extent: 1@1);	yourself).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1);	add: (3@1 extent: 1@1);	add: (2@1 extent: 1@1);	yourself).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1); add: (3@1 extent: 1@1); add: (2@1 extent: 1@1);	add: (1@2 extent: 3@1);	add: (1@3 extent: 1@3); add: (3@3 extent: 1@3); add: (2@3 extent: 1@3);	yourself).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1); add: (3@1 extent: 1@1); add: (2@1 extent: 1@1);	add: (1@2 extent: 1@1); add: (2@2 extent: 1@1);	yourself).RFBDamageRecorder new coalesceDamage: (OrderedCollection new	add: (1@1 extent: 1@1); add: (4@1 extent: 1@1); add: (2@1 extent: 1@1);	add: (1@2 extent: 1@1); add: (2@2 extent: 1@1); add: (4@2 extent: 1@1); add: (5@2 extent: 1@1);	yourself).| r d s |r := Random new.d := OrderedCollection new.1 to: 100 do: [:y | 1 to: 100 do: [:x | r next < 0.5 ifTrue: [d add: (x@y extent: 1@1)]]].s := RFBDamageRecorder new coalesceDamage: d.^Array with: d with: s with: d size with: s size"! !!OldRFBDamageRecorder methodsFor: 'damage regions' stamp: 'ikp 3/1/2004 05:22'!coalesceSortedDamage: rects	| bands current coalesced |	rects isEmpty ifTrue: [^rects].	bands := OrderedCollection new.	current := rects removeFirst.	rects do: [:rect |		(rect top == current top		 and: [rect left == current right		 and: [rect bottom == current bottom]])			ifTrue:				[current := current origin corner: rect corner]			ifFalse:				[bands addLast: current.				 current := rect]].	bands addLast: current.	coalesced := OrderedCollection new.	current := bands removeFirst.	bands do: [:rect |		(rect left == current left		 and: [rect top == current bottom		 and: [rect right == current right]])			ifTrue:				[current := current origin corner: rect corner]			ifFalse:				[coalesced addLast: current.				 current := rect]].	coalesced addLast: current.	^coalesced! !!OldRFBDamageRecorder methodsFor: 'initialise-release' stamp: 'ikp 2/29/2004 20:00'!colourMapForDeltaOfDepth: d	| colours |	colours := (WordArray new: 256) atAllPut: 1; at: 1 put: 0; yourself.	d == 8 ifTrue: [^ColorMap						colors: colours].	d == 16 ifTrue: [^ColorMap						shifts: #(-8 0 0 0)						masks: #(16rFF00 16r00FF 0 0)						colors: colours].	d == 32 	ifTrue: [^ColorMap						shifts: #(-16 -8 0 0)						masks: #(16rFF0000 16r00FF00 16r0000FF 0)						colors: colours].	^self error: 'Ian is confused'! !!OldRFBDamageRecorder methodsFor: 'damage filter' stamp: 'ikp 3/2/2004 05:02'!computeDamage: aForm in: bounds	deltaBlt sourceForm: aForm sourceAndDestRect: bounds; copyBits.	depthBlt clipRect: bounds; copyBits.	updateBlt sourceForm: aForm sourceAndDestRect: bounds; copyBits"| f d |f := RFBForm fromDisplay: (0@0 corner: 100@100).d := RFBDamageRecorder forForm: f.f fill: (40@40 corner: 48@48) fillColor: Color red.f display.  (Delay forSeconds: 1) wait.d computeDamage: f in: (f boundingBox insetBy: 20).d display.  (Delay forSeconds: 1) wait.Display restore.^d"! !!OldRFBDamageRecorder methodsFor: 'damage regions' stamp: 'ikp 3/3/2004 03:32'!getDamage: aForm inRect: rect	| l r t b damage h w s |	l := rect left.	r := rect right.	t := rect top.	b := rect bottom.	damage := OrderedCollection new.	self computeDamage: aForm in: rect.	t to: b - 1 by: DamageHeight do: [:y |		h := y + DamageHeight >= b ifTrue: [b - y] ifFalse: [DamageHeight].		l to: r - 1 by: DamageWidth do: [:x |			w := x + DamageWidth >= r ifTrue: [r - x] ifFalse: [DamageWidth].			s := x@y corner: (x+w)@(y+h).			(self validateDamageIn: s) ifTrue: [damage addLast: s]]].	^self coalesceSortedDamage: damage! !!OldRFBDamageRecorder methodsFor: 'damage regions' stamp: 'ikp 3/1/2004 04:39'!getDamage: aForm inRegion: rects	| damage |	damage := OrderedCollection new.	rects do: [:rect | damage addAll: (self getDamage: aForm inRect: rect)].	^self coalesceDamage: damage! !!OldRFBDamageRecorder methodsFor: 'initialise-release' stamp: 'ikp 3/2/2004 05:16'!setCache: aForm	cachedForm := aForm contentsOfArea: aForm boundingBox.	deltaBlt := (RFBBitBlt toForm: cachedForm)		combinationRule: Form reverse.	depthBlt := (RFBBitBlt toForm: self)		destRect: self boundingBox;		sourceForm: cachedForm;		combinationRule: Form over;		colorMap: (self colourMapForDeltaOfDepth: aForm depth).	foldBlt := (RFBBitBlt toForm: self)		sourceForm: self;		combinationRule: Form under.	updateBlt := (RFBBitBlt toForm: cachedForm)		combinationRule: Form over! !!OldRFBDamageRecorder methodsFor: 'damage filter' stamp: 'ikp 3/2/2004 05:21'!testDamage: aForm in: bounds	^self		computeDamage: aForm in: bounds;		validateDamageIn: bounds"| d1 d2 |d1 := RFBDamageRecorder forDisplay.d2 := OldRFBDamageRecorder forDisplay.^Array	with: (Time millisecondsToRun: [d1 testDamage: Display in: Display boundingBox])	with: (Time millisecondsToRun: [d2 testDamage: Display in: Display boundingBox])""| f d l t n |n := 128.f := RFBForm fromDisplay: Display boundingBox.d := RFBDamageRecorder forForm: f.f fill: (200@200 corner: 600@600) fillColor: Color red.l := OrderedCollection new.MessageTally spyOn: [t := Time millisecondsToRun: [0 to: f height - n by: n do: [:y | 0 to: f width - n by: n do: [:x |	(d testDamage: f in: (x@y extent: n@n))		ifTrue: [l add: x@y]]].]].^Array with: t with: l""| f d l |f := RFBForm fromDisplay: (0@0 extent: 64@64).d := RFBDamageRecorder forForm: f.0 to: 20 do: [:yy | Smalltalk beepPrimitive.0 to: 20 do: [:xx |1 to: 8 do: [:n |	f colorAt: xx@yy put: ((f colorAt: xx@yy) negated).	l := OrderedCollection new.	0 to: f height - n by: n do: [:y | 0 to: f width - n by: n do: [:x |	(d testDamage: f in: (x@y extent: n@n))		ifTrue: [l add: x@y]]].	l size ~= 1 ifTrue: [self error: 'oops']]]]."! !!OldRFBDamageRecorder methodsFor: 'damage filter' stamp: 'ikp 3/1/2004 05:33'!validateDamageIn: bounds	"Repeatedly fold the bounded area in half, combining pixels with an inclusive or, until only one pixel remains.  Answer whether the remaining pixel is nonzero, which will be the case unless every pixel in the area was initially zero."	| origin x y dd d |	origin := bounds origin.	x := origin x.	y := origin y.	"first reduce to a single line"	foldBlt sourceAndDestRect: bounds.	dd := bounds height.	[dd > 1]		whileTrue:			[d := dd + 1 // 2.			 foldBlt sourceY: y + dd - d height: d; copyBits.			 dd := d].	"then reduce to a single pixel"	foldBlt sourceY: y height: 1.	dd := bounds width.	[dd > 1]		whileTrue:			[d := dd + 1 // 2.			 foldBlt sourceX: x + dd - d width: d; copyBits.			 dd := d].	^(self pixelAt: origin) ~~ 0! !!RFBClientForm methodsFor: 'copying' stamp: 'ikp 3/23/2004 08:04'!applyColourMap: aColorMap in: bounds	"Apply aColorMap destructively to all the pixels in the receiver within bounds."	(RFBBitBlt toForm: self)		sourceForm: self;		sourceAndDestRect: bounds;		combinationRule: Form over;		colorMap: aColorMap;		copyBits! !!RFBClientForm methodsFor: 'decoding-zrle' stamp: 'ikp 3/23/2004 10:17'!bitsPerPackedPixel: paletteSize	"Answer the number of bits required for each pixel index in a palette of the given size."	^paletteSize > 16		ifTrue: [8]		ifFalse: [paletteSize > 4			ifTrue: [4]			ifFalse: [paletteSize > 2 ifTrue: [2] ifFalse: [1]]]! !!RFBClientForm methodsFor: 'decoding-corre' stamp: 'ikp 3/23/2004 08:26'!correDecode: bounds from: aSocket for: client	"Decode a CoRRE update from aSocket.  The receiver is of the correct depth and extent."	| nSubrects pix subrect origin subBounds |	nSubrects := (aSocket receiveData: RFBRREHeader new) nSubrects.	pix := aSocket nextPixel.	subrect := RFBCoRRERectangle new.	self fill pixelsIn: bounds put: pix.	origin := bounds origin.	nSubrects		timesRepeat:			[pix := aSocket nextPixel.			 subBounds := (aSocket receiveData: subrect) bounds translateBy: origin.			 self fill pixelsIn: subBounds put: pix]! !!RFBClientForm methodsFor: 'decoding-hextile' stamp: 'ikp 3/23/2004 07:05'!hextileDecode: bounds from: aSocket for: client	"Decode a hextile update from aSocket.  The receiver is of the correct depth and extent.  If client is nil then simply fill the receiver with the update.  If client is not nil then receive individual subrects and paint them on the receiver via the client."	| w h subOrigin subExtent subBounds l r b bgFg |	l := bounds left.	r := bounds right.	b := bounds bottom.	bgFg := Array new: 2.	bounds top to: b - 1 by: 16 do:		[:y |		 l to: r - 1 by: 16 do:			[:x |			 w := r - x min: 16.			 h := b - y min: 16.			 subOrigin := x@y.			 subExtent := w@h.			 subBounds := subOrigin extent: subExtent.			 client isNil				ifTrue:	"Fast update: fill self."					[self hextileSubrectDecode: subBounds from: aSocket with: bgFg]				ifFalse:	"Slow update: display on self."					[client						display: ((RFBClientForm extent: subExtent depth: depth)									hextileSubrectDecode: (0@0 corner: subExtent)									from: aSocket									with: bgFg)					 	on: self						in: subBounds]]]! !!RFBClientForm methodsFor: 'decoding-hextile' stamp: 'ikp 3/23/2004 07:31'!hextileSubrectDecode: bounds from: aSocket with: bgFg	"Decode a hextile subrectangle from aSocket using the given foreground/background pixel values."	| subEncoding nSubrects bg fg origin |	subEncoding := aSocket next.	(subEncoding anyMask: RfbHextileRaw)		ifTrue: [aSocket receiveForm: self in: bounds]		ifFalse:			[bg := bgFg at: 1.			 fg := bgFg at: 2.			 (subEncoding anyMask: RfbHextileBackgroundSpecified)				ifTrue: [bg := aSocket nextPixel].			 self fill pixelsIn: bounds put: bg.			 (subEncoding anyMask: RfbHextileForegroundSpecified)				ifTrue: [fg := aSocket nextPixel].			 (subEncoding anyMask: RfbHextileAnySubrects)				ifTrue:					[origin := bounds origin.					 nSubrects := aSocket next.					 (subEncoding anyMask: RfbHextileSubrectsColoured)						ifTrue:							[nSubrects timesRepeat:								[fg := aSocket nextPixel.								 self fill pixelsIn: (aSocket nextHextileBounds: origin) put: fg]]						ifFalse:							[nSubrects timesRepeat:								[self fill pixelsIn: (aSocket nextHextileBounds: origin) put: fg]]].			 bgFg				at: 1 put: bg;				at: 2 put: fg]! !!RFBClientForm methodsFor: 'decoding-rre' stamp: 'ikp 3/23/2004 08:21'!rreDecode: bounds from: aSocket for: client	"Decode a CoRRE update from aSocket.  The receiver is of the correct depth and extent."	| nSubrects pix subrect |	nSubrects := (aSocket receiveData: RFBRREHeader new) nSubrects.	pix := aSocket nextPixel.	subrect := RFBRectangle new.	self fill pixelsIn: bounds put: pix.	nSubrects		timesRepeat:			[pix := aSocket nextPixel.			 self fill pixelsIn: (aSocket receiveData: subrect) bounds put: pix]! !!RFBClientForm methodsFor: 'decoding-zrle' stamp: 'ikp 3/24/2004 03:16'!zrleDecode: bounds from: aStream for: client	"Decode a ZRLE update from the decompressed data on aStream.  The receiver is of the correct depth and extent."	| l r t b th tw tile |	l := bounds left.	r := bounds right.	t := bounds top.	b := bounds bottom.	t to: b - 1 by: RfbZrleTileHeight do:		[:ty |		 th := b - ty min: RfbZrleTileHeight.		 l to: r - 1 by: RfbZrleTileWidth do:			[:tx |			 tw := r - tx min: RfbZrleTileWidth.			 tile := RFBClientForm extent: tw@th depth: 32.			 tile zrleDecodeTileFrom: aStream for: client.			 tile displayOn: self at: tx@ty]]! !!RFBClientForm methodsFor: 'decoding-zrle' stamp: 'ikp 3/24/2004 03:57'!zrleDecodeTileFrom: aStream for: client	"Decode a ZRLE update tile from the decompressed data on aStream.  The receiver is depth 32 regardless of the bits per pixel in use."	| mode rle palSize palette bppp mask nBits byte index ptr end pix len |	mode := aStream next.	rle := mode anyMask: 128.	palSize := mode bitAnd: 127.	palette := WordArray new: 128.	1 to: palSize do: [:i | palette at: i put: aStream nextCPixel].	palSize == 1		ifTrue: [bits atAllPut: (palette at: 1)]		ifFalse:			[rle				ifFalse:	"not rle"					[palSize == 0						ifTrue:	"raw pixels"							[1 to: bits size do: [:i | bits at: i put: aStream nextCPixel]]						ifFalse:	"packed pixels"							[bppp := self bitsPerPackedPixel: palSize.							 mask := (1 bitShift: bppp) - 1.							 ptr := 1.							 1 to: height do:								[:j |								 nBits := 0.							 	 1 to: width do:									[:i |									 nBits == 0									 ifTrue:										[byte := aStream next.										 nBits := -8].									 nBits := nBits + bppp.									 index := (byte bitShift: nBits) bitAnd: mask.									 bits at: ptr put: (palette at: 1 + (index bitAnd: 127)).									 ptr := ptr + 1]]]]				ifTrue:	"rle"					[palSize == 0						ifTrue:	"plain rle"							[ptr := 1.							 end := bits size.							 [ptr <= end]								whileTrue:									[pix := aStream nextCPixel.									 len := 1.									 [byte := aStream next.									  len := len + byte.									  byte == 255] whileTrue.									 len timesRepeat:										[bits at: ptr put: pix.										 ptr := ptr + 1]]]						ifFalse:	"palette rle"							[ptr := 1.							 end := bits size.							 [ptr <= end]								whileTrue:									[index := aStream next.									 len := 1.									 (index anyMask: 128)										ifTrue:											[[byte := aStream next.											 len := len + byte.											 byte == 255] whileTrue].									 pix := palette at: 1 + (index bitAnd: 127).									 len timesRepeat:										[bits at: ptr put: pix.										 ptr := ptr + 1]]]]]! !!RFBDamageFilter methodsFor: 'damage containement' stamp: 'ikp 3/7/2004 20:21'!coalesceDamage: rectangleList	"See the comment in #coalesceSortedDamage:."	^self coalesceSortedDamage:		(rectangleList asSortedCollection:			[:r :s | r top == s top					ifTrue: [r left < s left]					ifFalse: [r top < s top]])		asOrderedCollection! !!RFBDamageFilter methodsFor: 'damage containement' stamp: 'ikp 3/7/2004 20:20'!coalesceSortedDamage: rectangleList	"Answer a SequenceableCollection of Rectangles, covering the same overall area as those in rectangleList, but in which adjacent rectangles have been coalesced into maximal y-x bands."	| mergedHorizontalRects currentRect mergedVerticalRects |	rectangleList isEmpty ifTrue: [^rectangleList].	mergedHorizontalRects := OrderedCollection new.	currentRect := rectangleList removeFirst.	rectangleList do: [:rect |		(rect top == currentRect top		 and: [rect left == currentRect right		 and: [rect bottom == currentRect bottom]])			ifTrue:				[currentRect := currentRect origin corner: rect corner]			ifFalse:				[mergedHorizontalRects addLast: currentRect.				 currentRect := rect]].	mergedHorizontalRects addLast: currentRect.	mergedVerticalRects := OrderedCollection new.	currentRect := mergedHorizontalRects removeFirst.	mergedHorizontalRects do: [:rect |		(rect left == currentRect left		 and: [rect top == currentRect bottom		 and: [rect right == currentRect right]])			ifTrue:				[currentRect := currentRect origin corner: rect corner]			ifFalse:				[mergedVerticalRects addLast: currentRect.				 currentRect := rect]].	mergedVerticalRects addLast: currentRect.	^mergedVerticalRects! !!RFBDamageFilter methodsFor: 'damage containement' stamp: 'ikp 3/7/2004 20:18'!getDamageInRect: bounds	"Answer a SequenceableCollection of Rectangles representing validated damage in the given bounds."	| l r t b damagedRects h w subRect |	l := bounds left.  r := bounds right.	t := bounds top.  b := bounds bottom.	damagedRects := OrderedCollection new.	t to: b - 1 by: DamageHeight do: [:y |		h := y + DamageHeight >= b ifTrue: [b - y] ifFalse: [DamageHeight].		l to: r - 1 by: DamageWidth do: [:x |			w := x + DamageWidth >= r ifTrue: [r - x] ifFalse: [DamageWidth].			subRect := x@y corner: (x+w)@(y+h).			(self isDamagedIn: subRect)				ifTrue: [damagedRects addLast: subRect]]].	^self coalesceSortedDamage: damagedRects! !!RFBDamageFilter methodsFor: 'damage containement' stamp: 'ikp 3/7/2004 20:22'!getDamageInRegion: rectangleList	"Answer a SequenceableCollection of Rectangles covering validated damage within the regions covered by rectangleList."	| damagedRects |	damagedRects := OrderedCollection new.	rectangleList do: [:rect | damagedRects addAll: (self getDamageInRect: rect)].	^self coalesceDamage: damagedRects! !!RFBDamageFilter methodsFor: 'damage containement' stamp: 'ikp 3/15/2004 18:05'!updateDamageInRegion: rectangleList	"Invalidate any damage in the region described by the rectangleList."	rectangleList do: [:rect | self updateDamageIn: rect]! !!RFBDamageRecorder class methodsFor: 'instance creation' stamp: 'ikp 3/7/2004 20:24'!forDisplay	"Answer a new DamageRecorder for the current Display object."	^self on: Display! !!RFBDamageRecorder class methodsFor: 'class initialisation' stamp: 'ikp 3/4/2004 06:54'!initialize	"RFBDamageFilter initialize"	DamageWidth := 64.	DamageHeight := 64.! !!RFBDamageRecorder class methodsFor: 'instance creation' stamp: 'ikp 3/7/2004 20:24'!on: aForm	"Answer a new DamageRecorder for aForm."	^(self extent: aForm extent depth: aForm depth)		setTargetForm: aForm! !!RFBDamageRecorder methodsFor: 'testing' stamp: 'ikp 3/14/2004 17:05'!isDamaged	"Answer whether any damage is present in the entire Form covered by the receiver."	^self isDamagedIn: self boundingBox! !!RFBDamageRecorder methodsFor: 'testing' stamp: 'ikp 3/7/2004 20:23'!isDamagedIn: bounds	"Answer whether any damage exists in the receiver's Form within bounds."	| damageFlag |	(targetForm extent = self extent and: [targetForm bits size == bits size])		ifFalse:			[self setExtent: targetForm extent depth: targetForm depth].	(damageFlag := self pvtChangedFrom: targetForm in: bounds)		ifTrue: [self updateDamageIn: bounds].	^damageFlag"| c f g r |c _ OrderedCollection new.#(1 2 4 8 16 32) do: [:d |	f _ RFBDamageRecorder on: (g _ Form extent: 100@100 depth: d).	0 to: 90 by: 10 do: [:o |		r _ o@o extent: 10@10.		g fill: r fillColor: Color red.		c add: d -> (r ->			((f isDamagedIn: (49@49 corner: 51@51))				-> (f isDamagedIn: (49@49 corner: 51@51))))]].^String streamContents: [:s | c do: [:e | e printOn: s.  s cr]]"! !!RFBDamageRecorder methodsFor: 'initialise-release' stamp: 'ikp 3/19/2004 04:26'!release	"Drop references to anything potentially large."	targetForm := nil.	bits := nil! !!RFBDamageRecorder methodsFor: 'private' stamp: 'ikp 3/8/2004 04:29'!setTargetForm: aForm	"Set the Form for which the receiver monitors damage."	(BitBlt toForm: self)        sourceForm: (targetForm := aForm);        combinationRule: Form over;        destRect: self boundingBox;        copyBits.! !!RFBDamageRecorder methodsFor: 'private' stamp: 'ikp 3/7/2004 20:24'!updateDamageIn: bounds	"Update the receiver's cached copy of the targetForm with the given bounds, eliminating any damage that might have been there."	(BitBlt toForm: self)		sourceForm: targetForm;		sourceOrigin: bounds origin;		combinationRule: Form over;		destRect: bounds;		copyBits! !!RFBForm class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:23'!fromDisplay: bounds format: pixelFormat	"Answer a RFBForm containing a copy of the Display in bounds, in viewer byte order and depth (according to the given pixelFormat)."	^(self extent: bounds extent depth: pixelFormat bitsPerPixel)		format: pixelFormat;		fromDisplay: bounds! !!RFBForm class methodsFor: 'class initialisation' stamp: 'ul 7/3/2011 15:25'!initialize	"RFBForm initialize"	RfbHextileRaw					:= 1 << 0.	RfbHextileBackgroundSpecified	:= 1 << 1.	RfbHextileForegroundSpecified	:= 1 << 2.	RfbHextileAnySubrects			:= 1 << 3.	RfbHextileSubrectsColoured		:= 1 << 4.	RfbZrleTileWidth := 64.	RfbZrleTileHeight := 64.	RfbZrleBitsPerPackedPixel := #[0 1 2 2 4 4 4 4 4 4 4 4 4 4 4 4].	IdentityMap16 := ColorMap masks: #(16rFFFFFFFF 0 0 0) shifts: #(0 0 0 0).	NumSmallInts := 0.	NumLargeInts := 0.! !!RFBForm methodsFor: 'copying' stamp: 'ikp 3/15/2004 18:10'!applyColourMap: aColorMap	"Apply aColorMap destructively to all the pixels in the receiver."	(BitBlt toForm: self)		sourceForm: self;		combinationRule: Form over;		width: width;		height: height;		colorMap: aColorMap;		copyBits! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:36'!bounds	"Answer the bounds of the original screen area from which the receiver was copied."	^self boundingBox translateBy: offset! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:32'!bytesPerPixel	"Answer the number of bytes needed to represent one pixel in the receiver."	^depth // 8! !!RFBForm methodsFor: 'encoding-corre' stamp: 'ikp 3/8/2004 20:03'!correSubrectEncodeIn: bounds on: stream	"Encode the region in the receiver covered by the gicen bounds onto the stream using CoRRE encoding."	| maxSize backgroundPixel subrectHeader subForm |	maxSize := bounds area * self bytesPerPixel.	subForm := self pixelFormIn: bounds.	backgroundPixel := subForm dominantPixel."self tallyPixel: backgroundPixel."	stream nextPutPixel: backgroundPixel.	subrectHeader := RFBCoRRERectangle new.	^subForm		rreSubrectsForBackgroundPixel: backgroundPixel		doWithForegroundPixel:			[:subrect :fg |"self tallyPixel: fg."			 stream				nextPutPixel: fg;				nextPutAll: (subrectHeader bounds: subrect).			 stream size < maxSize				ifFalse: [^-1]]! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/14/2004 17:04'!dominantPixel	"Answer the dominant (background) pixel in the receiver.	Assumes: the receiver is 32 bits deep.	Rationale: RFB/VNC server implementations traditionally (and stupidly) return the pixel at the origin for depth 16 or 32, or tally all pixels in the rectangle to find the predominant pixel when the depth is 8.  Both of these lose big when sending the initial screen, since: (1) the desktop background colour, at the origin, tends not to be the same as the window background colour covering most of the screen; and: (2) tallying pixel values in an 8-bit Form of any size, using BitBlt, involves enumerating a large tally array to find the maximum count.  Instead, since most non-background colour in the Squeak display is in narrow horizontal or vertical rectangles, we tally only a 1 pixel wide diagonal line from the origin.  This gives much better results than the traditional 'origin pixel' approach (since it is almost guaranteed to find the true backgound pixel) and speeds up RRE and CoRRE by a factor of three when sending a large update."	| pixels line |	pixels := RFBPixelPopulation new.			"Should use Bag, but can't get at its raw contents."	line := 1.	0 to: (height min: width) - 1 do: [:xy |		pixels add: (bits at: line + xy).		line := line + width].	^pixels dominantPixel					"*much* faster than 'aBag sortedCounts first key'"! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/23/2004 05:42'!fill	"Answer the BitBlt used to fill pixels in the receiver."	^fill! !!RFBForm methodsFor: 'drawing' stamp: 'ikp 3/9/2004 19:54'!fill: aRectangle fillPixel: aPixel	"Fill the region covered by aRectangle in the receiver with aPixel."	fill pixelsIn: aRectangle put: aPixel! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:38'!format	"Answer the RFBPixelFormat of the receiver's pixels."	^format! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/9/2004 19:53'!format: pixelFormat	"Set the pixel format of the receiver."	format := pixelFormat! !!RFBForm methodsFor: 'initialise-release' stamp: 'ikp 3/7/2004 20:33'!fromDisplay: aRectangle	"Answer a RFBForm containing the contents of the Display within aRectangle."	^(super fromDisplay: aRectangle) offset: aRectangle origin"(RFBForm fromDisplay: (100@100 corner: 200@200)) displayAt: 10@10"! !!RFBForm methodsFor: 'encoding-hextile' stamp: 'ikp 3/8/2004 02:21'!hextileColours	"The receiver is a 16x16 pixel Form of depth 32 in viewer byte order.  Answer an Array of size 4 containing: (1) true if the Form is monochrome (or solid), false otherwise; (2) true if the Form is solid (contains a single colour), false otherwise; (3) the background (dominant) pixel; (4) the foreground (first pixel different from the background)."	| tally1 tally2 colour1 colour2 |	tally1 := tally2 := 0.	bits do: [:pixel |		tally1 == 0 ifTrue: [colour1 := pixel].		pixel = colour1			ifTrue: [tally1 := tally1 + 1]			ifFalse:				[tally2 == 0 ifTrue: [colour2 := pixel].				 pixel = colour2					ifTrue: [tally2 := tally2 + 1]					ifFalse: [^Array		"monochrome solid background foreground"								with: false								with: false								with: (tally1 > tally2 ifTrue: [colour1] ifFalse: [colour2])								with: (tally1 > tally2 ifTrue: [colour2] ifFalse: [colour1])]]].	^Array		with: true		with: colour2 == nil		with: (tally1 > tally2 ifTrue: [colour1] ifFalse: [colour2])		with: (tally1 > tally2 ifTrue: [colour2] ifFalse: [colour1])"| f |f _ RFBForm fromUser.f hextileColours"! !!RFBForm methodsFor: 'encoding-hextile' stamp: 'ikp 3/15/2004 18:02'!hextileEncodeOn: stream forClient: rfbClient	"Encode the contents of the receiver on rfbClient using Hextile encoding."	| w h flags rect colours mono solid newBg newFg validBg validFg bg fg flagsPosition subForm bpp |	bpp := self bytesPerPixel.	bg := fg := nil.	validBg := validFg := false.	0 to: height - 1 by: 16 do: [:y |		0 to: width - 1 by: 16 do: [:x |			w := h := 16.			width - x < 16 ifTrue: [w := width - x].			height - y < 16 ifTrue: [h := height - y].			flagsPosition := stream size.			stream nextPut: (flags := 0).			rect := x@y extent: w@h.			subForm := self pixelFormIn: rect.			colours := subForm hextileColours.			mono := colours at: 1.			solid := colours at: 2.			newBg := colours at: 3.			newFg := colours at: 4.			(validBg not or: [newBg ~~ bg])				ifTrue:					[validBg := true.					 bg := newBg.					 flags := flags bitOr: RfbHextileBackgroundSpecified.					 stream nextPutPixel: bg].			solid				ifFalse:					[flags := flags bitOr: RfbHextileAnySubrects.					 mono						ifTrue:							[(validFg not or: [newFg ~~ fg])								ifTrue:									[validFg := true.									 fg := newFg.									 flags := flags bitOr: RfbHextileForegroundSpecified.									 stream nextPutPixel: fg]]						ifFalse:							[validFg := false.							 flags := flags bitOr: RfbHextileSubrectsColoured].					 (subForm hextileSubrectEncodeOn: stream								bg: bg fg: fg mono: mono								bytesPerPixel: bpp) < 0						ifTrue:							[validBg := validFg := false.							 stream								resetTo: flagsPosition;								nextPut: (flags := RfbHextileRaw);							 	nextPutForm: self in: rect]].			 stream at: flagsPosition put: flags].		stream size > rfbClient maximumTransmissionUnit			ifTrue:				[rfbClient sendStream: stream.				 stream resetContents]].	rfbClient sendStream: stream! !!RFBForm methodsFor: 'encoding-hextile' stamp: 'ikp 3/7/2004 20:41'!hextileSubrectEncodeOn: stream bg: bg fg: fg mono: mono bytesPerPixel: bpp	"The receiver is a 16x16 Hextile subrectangle in viewer format, requiring bpp byytes per pixel, and containing 2 (iff mono is true) or more distinct pixel values.  Write its encoding onto the stream using the specified background and foreground pixels."	| initialPosition subrectCount encodedLength maxLength |	initialPosition := stream size.	stream nextPut: (subrectCount := 0).	encodedLength := 1.	maxLength := width * height * bpp.	subrectCount := self		rreSubrectsForBackgroundPixel: bg		doWithForegroundPixel:			[:subrect :foregroundPixel |			 encodedLength := encodedLength + (mono ifTrue: [2] ifFalse: [bpp + 2]).			 encodedLength < maxLength ifFalse: [^-1].			 mono ifFalse: [stream nextPutPixel: foregroundPixel].			 stream				nextPut: ((subrect left bitShift: 4) bitOr: subrect top);				nextPut: ((subrect width - 1 bitShift: 4) bitOr: subrect height - 1)].	stream at: initialPosition put: subrectCount.	^subrectCount! !!RFBForm methodsFor: 'fileIn/Out' stamp: 'ikp 3/7/2004 20:33'!hibernate	"Put the receiver to sleep before storing an image snapshot.  Avoid hibernating the numerous small cached Forms within the RFB server implementation."	bits size > 32 ifTrue: [super hibernate]! !!RFBForm methodsFor: 'initialise-release' stamp: 'ikp 3/9/2004 19:56'!initialiseBitBlts	"Initialise the cached BitBlts."	fill := RFBBitBlt bitFillerToForm: self.! !!RFBForm methodsFor: 'comparing' stamp: 'ikp 3/4/2004 12:21'!isChangedFrom: aForm in: bounds	"Answer whether the receiver differs from aForm within the given bounds."	aForm == self ifTrue: [^false].	(self extent ~= aForm extent or: [self depth ~= aForm depth])		ifTrue: [self error: 'forms must be commensurate'].	^self pvtChangedFrom: aForm in: bounds! !!RFBForm methodsFor: 'private' stamp: 'ikp 3/14/2004 18:45'!pixelFormIn: bounds	"Answer a Form containing contiguous 32-bit pixel values in the area of the receiver covered by the given bounds."	| form w h cmap |	w := bounds width.	h := bounds height.	cmap := depth == 16 ifTrue: [IdentityMap16].	(BitBlt toForm: (form := RFBForm extent: w@h depth: 32))		sourceForm: self;		sourceOrigin: bounds origin;		combinationRule: Form over;		destX: 0 destY: 0 width: w height: h;		colorMap: cmap;		copyBits.	^form! !!RFBForm methodsFor: 'private' stamp: 'ikp 3/4/2004 12:47'!pvtChangedFrom: aForm in: bounds	"Answer whether the receiver differs from aForm within the given bounds.  Assume that aForm is commesurate with the receiver."	| scale source dest l w t extent |	depth > 8		ifTrue:			[scale := self depth // 8.			 extent := width * scale @ height.			 source := Form extent: extent depth: 8 bits: bits.			 dest := Form extent: extent depth: 8 bits: aForm bits]		ifFalse:			[scale := 1.			 source := self.			 dest := aForm].	l := bounds left * scale.	w := bounds width * scale.	t := bounds top.	^0 ~~ ((BitBlt toForm: dest)			sourceForm: source;			sourceX: l;			sourceY: t;			combinationRule: 32;			destX: l destY: t width: w height: bounds height;			copyBits)! !!RFBForm methodsFor: 'encoding-rre' stamp: 'ikp 3/8/2004 02:20'!rreSubrectEncodeOn: encodedStream	"The receiver is a Form in viewer byte order and depth, of arbitrary size.  Encode the contents on encodedStream using rise and run-length (RRE) encoding."	| rawSize subrectHeader backgroundPixel subForm |	rawSize := bits byteSize.	subrectHeader := RFBRectangle new.	subForm := self pixelFormIn: self boundingBox.	backgroundPixel := subForm dominantPixel.	encodedStream nextPutPixel: backgroundPixel.	^subForm		rreSubrectsForBackgroundPixel: backgroundPixel		doWithForegroundPixel:			[:subrect :fg |			 encodedStream nextPutPixel: fg; nextPutAll: (subrectHeader bounds: subrect).			 encodedStream size >= rawSize ifTrue: [^-1]]! !!RFBForm methodsFor: 'encoding-rre' stamp: 'ikp 3/9/2004 19:55'!rreSubrectsForBackgroundPixel: backgroundPixel doWithForegroundPixel: subrectBlock	"Enumerate the RRE (rise and run-length encoded) rectangles within the receiver.  For each rectangle, invoke subrectBlock with the rectangle and its foreground (solid) pixel as arguments.  Answer the number of RRE subrectangles found in the receiver."	| line subrectCount foregroundPixel hy hyflag scan j i vx hx vy hw hh vw vh subrect |	line := 1.	subrectCount := 0.	0 to: height - 1 do: [:y |		0 to: width - 1 do: [:x |			(foregroundPixel := bits at: line + x) ~= backgroundPixel				ifTrue:					[hy := y - 1.					 hyflag := true.					 scan := line.					 j := y.					 [j < height and: [(bits at: scan + x) = foregroundPixel]]						whileTrue:							[i := x.							 [i < width and: [(bits at: scan + i) = foregroundPixel]]								whileTrue: [i := i + 1].							 i := i - 1.							 j == y ifTrue: [vx := hx := i].							 i < vx ifTrue: [vx := i].							 hyflag & (i >= hx)								ifTrue: [hy := hy + 1]								ifFalse: [hyflag := false].							 j := j + 1.							 scan := scan + width].					vy := j - 1.					"Two possible subrects: (x,y,hx,hy) (x,y,vx,vy).  Choose the larger."					hw := hx - x + 1.  hh := hy - y + 1.					vw := vx - x + 1.  vh := vy - y + 1.					subrect := x@y extent: (((hw*hh) > (vw*vh)) ifTrue: [hw@hh] ifFalse: [vw@vh]).					subrectBlock value: subrect value: foregroundPixel.					subrectCount := subrectCount + 1.					"Mark subrect as done."					self fill: subrect fillPixel: backgroundPixel]].		line := line + width].	^subrectCount! !!RFBForm methodsFor: 'private' stamp: 'ikp 3/7/2004 20:32'!setExtent: extent depth: bitDepth	"Set the extent and depth of the receiver."	super setExtent: extent depth: bitDepth.	self initialiseBitBlts! !!RFBForm methodsFor: 'copying' stamp: 'ikp 3/8/2004 02:22'!subForm: bounds	"Answer a copy of the portion of the receiver in bounds, at the same depth."	| subForm |	subForm := RFBForm extent: bounds extent depth: depth.	(BitBlt toForm: subForm)		sourceForm: self;		sourceOrigin: bounds origin;		combinationRule: Form over;		width: bounds width;		height: bounds height;		copyBits.	^subForm! !!RFBForm methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:39'!width: w height: h	"Set the width and height of the receiver without changing its bits."	width := w.	height := h.! !!RFBForm methodsFor: 'encoding-zrle' stamp: 'ikp 3/16/2004 19:29'!zrleEncodeOn: aStream	"Encode the contents of the receiver on aStream for rfbClient using ZRLE encoding."	| th tw |	0 to: height - 1 by: RfbZrleTileHeight do:		[:ty |		 th := RfbZrleTileHeight.		 th > (height - ty) ifTrue: [th := height - ty].		 0 to: width - 1 by: RfbZrleTileWidth do:			[:tx |			 tw := RfbZrleTileWidth.			 tw > (width - tx) ifTrue: [tw := width - tx].			 (self pixelFormIn: (tx@ty extent: tw@th))				zrleEncodeTileOn: aStream]]! !!RFBForm methodsFor: 'encoding-zrle' stamp: 'klub 5/17/2010 02:29'!zrleEncodeTileOn: aStream	"Encode the contents of the receiver on aStream for rfbClient using ZRLE encoding.  Assumes: the receiver is depth 32, regardless of the 'depth' of each pixel value stored in its Bitmap."	| palette runs singlePixels ptr end pix usePalette estimatedBytes plainRleBytes useRle paletteRleBytes packedBytes runStart len index bppp nbits byte eol bpcp |	palette := RFBPalette new.	bpcp := aStream bytesPerCompressedPixel.	"Built the palette and count the number of single pixels and runs."	runs := 0.	singlePixels := 0.	ptr := 1.	end := bits size + 1.	[ptr < end]		whileTrue:			[pix := bits at: ptr.			 ((ptr := ptr + 1) = end or: [pix ~= (bits at: ptr)])				ifTrue: [singlePixels := singlePixels + 1]				ifFalse:					[[(ptr := ptr + 1) < end and: [(bits at: ptr) = pix]] whileTrue.					 runs := runs + 1].			 palette insert: pix].	"Solid tile (palette contains only one pixel) is a special case."	palette size = 1		ifTrue:			[^aStream				nextPut: 1;				nextPutCPixel: palette pixels first].	"Determine whether to use RLE and/or the palette.  We do this by	 estimating the number of uncompressed bytes that will be generated	 and choosing the method that generates the fewest.  Of course, this	 may not result in the fewest bytes after compression."	usePalette := false.	estimatedBytes := width * height * bpcp.		"Raw encoding size."	plainRleBytes := bpcp + 1 * (runs + singlePixels).	(useRle := plainRleBytes < estimatedBytes)		ifTrue: [estimatedBytes := plainRleBytes].	palette size < 128		ifTrue:			[paletteRleBytes := (bpcp * palette size) + (2 * runs) + singlePixels.			 paletteRleBytes < estimatedBytes				ifTrue:					[useRle := true.					 usePalette := true.					 estimatedBytes := paletteRleBytes].			 palette size < 17				ifTrue:					[packedBytes := bpcp * palette size						+ (width * height * (RfbZrleBitsPerPackedPixel at: palette size) // 8).			 packedBytes < estimatedBytes				ifTrue:					[useRle := false.					 usePalette := true.					 estimatedBytes := packedBytes]]].	usePalette ifFalse: [palette size: 0].	aStream nextPut: ((useRle ifTrue: [128] ifFalse: [0]) bitOr: palette size).	1 to: palette size do: [:i | aStream nextPutCPixel: (palette pixels at: i)].	useRle		ifTrue:			[ptr := 1.			 end := 1 + (width * height).			 [ptr < end]				whileTrue:					[runStart := ptr.					 pix := bits at: ptr.					 ptr := ptr + 1.					 [ptr < end and: [(bits at: ptr) = pix]] whileTrue: [ptr := ptr + 1].					 len := ptr - runStart.					(usePalette and: [ len <= 2 ]) 						ifTrue:							[index := palette lookup: pix.							 len = 2 ifTrue: [aStream nextPut: index].							 aStream nextPut: index]						ifFalse:							[usePalette								ifTrue:									[index := palette lookup: pix.									 aStream nextPut: (index bitOr: 128)]								ifFalse:									[aStream nextPutCPixel: pix].							 len := len - 1.							 [len >= 255]								whileTrue:									[aStream nextPut: 255.									 len := len - 255].							 aStream nextPut: len]]]		ifFalse:			[usePalette				ifTrue:					[ptr := 1.					 bppp := RfbZrleBitsPerPackedPixel at: palette size.					 0 to: height - 1 do:						[:i |						 nbits := 0.						 byte := 0.						 eol := ptr + width.						 [ptr < eol]							whileTrue:								[pix := bits at: ptr.								 ptr := ptr + 1.								 index := palette lookup: pix.								 byte := (byte bitShift: bppp) bitOr: index.								 nbits := nbits + bppp.								 nbits >= 8									ifTrue:										[aStream nextPut: byte.										 nbits := byte := 0]].						 nbits > 0							ifTrue:								[byte := byte bitShift: 8 - nbits.								 aStream nextPut: byte]]]				ifFalse:	"raw"					[bits do: [:pixel | aStream nextPutCPixel: pixel]]]! !!RFBZLibWriteStream methodsFor: 'encoding' stamp: 'ikp 3/18/2004 02:32'!commit	"Flush all pending data onto the encodedStream."	blockPosition < position ifTrue: [self deflateBlock; flushBlock: false].	self sendSynchronisationBlock.	encoder commit.	blockStart := blockPosition.! !!RFBZLibWriteStream methodsFor: 'stored blocks' stamp: 'ikp 3/18/2004 02:40'!sendSynchronisationBlock	"Send a synchronisation marker: a non-final, non-compressed, empty block.  When the block is encountered in an incoming compressed data stream, the inflation process guarantees that all data read before it will be inflated and presented to the client for consumption."	encoder		nextBits: 3 put: StoredBlock << 1 + 0;		"Non-final, non-compressed block header."		flushBits;								"Align to byte boundary."		nextBits: 16 put: 0;						"Length of non-compressed literal data to follow (zero bytes)."		nextBits: 16 put: 16rFFFF;				"One's complement of data length."		flushBits! !!RFBZLibWriteStream methodsFor: 'encoding' stamp: 'ikp 3/18/2004 02:39'!synchronisedContents	"Flush all pending data, write an inflation synchronisation marker onto the encodedStream, and answer the contents of the encodedStream.  Reset the encodedStream to empty in the process."	| compressedData |	self commit.	compressedData := self encodedStream contents.	self encodedStream position: 0.	^compressedData! !!RFBBitBlt class methodsFor: 'instance creation' stamp: 'ikp 3/23/2004 05:22'!bitFillerToForm: destForm	"Answer a BitBlt suitable for filling regions of destForm with pixel values (not Colors, regardless of the destForm depth)."	destForm unhibernate.	^self		destForm: destForm	 	sourceForm: nil		halftoneForm: (Form extent: 1@1 depth: destForm depth)		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: 0@0		extent: 1@1		clipRect: destForm boundingBox! !!RFBBitBlt class methodsFor: 'instance creation' stamp: 'ikp 3/7/2004 20:15'!bitPeekerFromForm: destForm	"Answer a BitBlt suitable for peeking pixel values out of destForm."	^(super bitPeekerFromForm: destForm) colorMap: nil! !!RFBBitBlt class methodsFor: 'instance creation' stamp: 'ikp 3/23/2004 04:19'!bitPokerToForm: destForm	"Answer a BitBlt suitable for poking pixel values into destForm."	^(super bitPokerToForm: destForm) colorMap: nil! !!RFBBitBlt methodsFor: 'copying' stamp: 'ikp 3/23/2004 05:29'!pixelsIn: aRectangle put: aPixel	"Fill aRectangle in destForm with aPixel."	| depth pv |	depth := halftoneForm depth.	pv := aPixel.	depth < 32		ifTrue:			[pv := pv bitOr: (pv bitShift: 16).			 depth < 16 ifTrue: [pv := pv bitOr: (pv bitShift: 8)]].	halftoneForm bits at: 1 put: pv.	self destRect: aRectangle; copyBits! !!RFBBitBlt methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:13'!sourceAndDestRect: aRectangle	"Set source and destination rectangles in one operation.  Avoids additional message sends."	| origin corner x y |		origin := aRectangle origin.	corner := aRectangle corner.	sourceX := destX := (x := origin x).	sourceY := destY := (y := origin y).	width := corner x - x.	height := corner y - y.! !!RFBBitBlt methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:11'!sourceForm: aForm sourceAndDestRect: aRectangle	"Set the source form and the source and destination Ractangles.  Avoids several message sends."	| origin corner x y |	origin := aRectangle origin.	corner := aRectangle corner.	sourceForm := aForm.	sourceX := destX := x := origin x.	sourceY := destY := y := origin y.	width := corner x - x.	height := corner y - y.! !!RFBBitBlt methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:12'!sourceX: x width: w	"Set the horizontal source position and the width.  Avoids an additional message send from inner loops."	sourceX := x.	width := w! !!RFBBitBlt methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:12'!sourceY: y height: h	"Set the vertical source position and the height.  Avoids an additional message send from inner loops."	sourceY := y.	height := h! !!RFBBitBlt methodsFor: 'fileIn/Out' stamp: 'ikp 3/7/2004 20:11'!unhibernate	"Unhibernate my destForm when coming back from snapshot.  Avoids a problem with pixelAt: storing zero in the first field of destForm bits, which might be a ByteArray when the form is hibernating."	destForm isNil ifFalse: [destForm unhibernate]! !!RFBClientMorph methodsFor: 'connecting' stamp: 'ar 11/8/2004 18:40'!abort	^rfbClient abort! !!RFBClientMorph methodsFor: 'private' stamp: 'ikp 3/4/2011 14:00'!aboutString	"Answer the contents of the about window."	^'		*** RFBClient: a RFB/VNC viewer written entirely in Squeak. ***  (If you don''t know what RFB and VNC are, go look at "http://www.realvnc.com"  and/or "http://www.tightvnc.com".)	Copyright (C) 2004--2011 by Ian Piumarta	All Rights Reserved.	Permission is hereby granted, free of charge, to any person obtaining a	copy of this software and associated documentation files (the "Software"),	to deal in the Software without restriction, including without limitation	the rights to use, copy, modify, merge, publish, distribute, and/or sell	copies of the Software, and to permit persons to whom the Software is	furnished to do so, provided that the above copyright notice(s) and this	permission notice appear in all copies of the Software and that both the	above copyright notice(s) and this permission notice appear in supporting	documentation.	THE SOFTWARE IS PROVIDED "AS IS".  USE ENTIRELY AT YOUR OWN RISK.  Enjoy!!'! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:27'!blueButtonDown: anEvent	"Override to avoid halo."	rfbClient mouseDown: anEvent.	^true! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:27'!blueButtonUp: anEvent	"Override to avoid halo."	rfbClient mouseUp: anEvent.	^true! !!RFBClientMorph methodsFor: 'connecting' stamp: 'ar 11/8/2004 18:20'!connect	"Open a new connection."	rfbClient connect.! !!RFBClientMorph methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:04'!contentBounds	^scrollPane contentBounds! !!RFBClientMorph methodsFor: 'connecting' stamp: 'ar 11/8/2004 18:20'!disconnect	"Close the new connection."	rfbClient disconnect.! !!RFBClientMorph methodsFor: 'menu' stamp: 'ul 7/3/2011 15:16'!getMenu: shiftState	"Answer the menu attached to the yellow button (and to the scrollbar button if visible)."	| menu |	(menu := RFBMenuMorph new)		"We're NOT a text holder.  Grrr...!!"		defaultTarget: self.	self isConnected		ifTrue: [menu add: 'disconnect...' action: #disconnect help: 'Disconnect from the server.']		ifFalse: [menu add: 'connect...' action: #connect help: 'Connect to a server.'].	menu		addLine;		add: 'options' subMenu: rfbClient optionsMenu;		add: 'encodings' subMenu: rfbClient encodingsMenu;		add: 'performance' subMenu: rfbClient performanceMenu;		addLine;		add: 'help...' action: #showHelpWindow help: 'Open a window describing this menu in detail.';		add: 'about...' action: #showAboutWindow help: 'Open the Cheezoid About Window.';		addLine;		add: 'inspect...' action: #inspect;		add: 'explore...' action: #explore.			^menu! !!RFBClientMorph methodsFor: 'private' stamp: 'ar 11/8/2004 18:04'!helpString	"Answer the contents of the help window."	^'Everything you need is on the window menu (the button at the top of the scrollbar).*** Menu contents** connect... / disconnect...Depending on whether the viewer is already connected, this item lets you connect or disconnect.  When connecting, you will be asked for the IP address or name of the machine to which you want to connect.  If the machine requires a password, you will be asked for it too.  When disconnecting, you will be given a chance to change your mind.  (Disconnecting accidentally is no big deal anyway: you just connect again. ;-)** optionsEverything to do with viewer options.* sharedIf this is set then the viewer will request a shared connection.  If this is not set then the viewer will request exclusive access to the remote framebuffer.  Whether or not it gets that access depends on the server''s policy.* local cursorIf this is enabled then the viewer will request that the server send cursor shape updates so that the viewer can track it locally.* view-onlyIf this is enabled then the viewer will not send mouse or keyboard events to the server.* 8-bit pixelsIf this is enabled then the viewer will ask the server to send data using 8-bit deep pixels to reduce network traffic.** encodingsEverything about selecting the encoding you''d like to use.* autoIf enabled then the viewer will pick the most appropriate encoding for you.  Currently this means ''Raw'' encoding if the server is on the same machine, ''Hextile'' encoding otherwise.* ZRLE* Hextile* CoRRE* RRE* RAWIf any of these are set then the viewer will ask the server to perform updates using that encoding.  Note that ZRLE currently has problems with some Windows VNC server implementations.  (Running it between two Squeak images works fine.)Note that if you change the encoding while the viewer is connected, the new encoding preference will take effect immediately.  (Any other open viewers will not be affected.)** performance* fast updateIf this is set then the viewer will consume more memory and will hog the CPU during updates to ensure the lowest possible update latencies.  In particular, while an update is in progress, no other userSchedulingPriority processes will be allowed to run.  If this option is not set then the viewer will attempt to minimise the amount of memory consumed during updates, and will yield the processor often (usually after each ''subrectangle'' in the update message).  This makes for slower update processing, and increased CPU usage while Morphic tries to catch up with screen updates at each yield, but does give other user-priority processes a chance to run.** help...You already know about.** about...Opens the Cheezoid About Window containing absolutely nothing of interest (other than an email address to which you can send bug reports or suggestions for improvements).*** Bugs and caveat empori* ZRLE is broken when talking to Windows servers.  I have no idea why.  The ZLibInflateStream in the image becomes hopelessly confused with the second update message that is received.  ZRLE works just fine between a Squeak server and a Unix client (or between Squeak server and Squeak viewer.* Some of the menu options are currently unimplemented.  (The viewer was written for fun to occupy a rainy weekend and isn''t really meant to be a production-quality artefact.)  In particular, 8-bit pixels and view-only options are ignored when setting up the connection.* The viewer currently always uses the server''s pixel format.  There should be an option to use the local pixel format instead.* Some improvements to the way focus and mouse ''first clicks'' are handled are certainly warranted.* The scroll bars sould vanish when the window is expanded to cover its entire contents.  The vertical scroll bar is stuck on the left too;  don''t blame me -- blame whoever wrote TwoWayScrollPane.'! !!RFBClientMorph methodsFor: 'private' stamp: 'ar 11/8/2004 18:04'!inATwoWayScrollPane	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction."	| widget |	(widget := TwoWayScrollPane new)		extent: ((self width min: 300 max: 100) @ (self height min: 150 max: 100));		borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	widget color: self color darker.	^widget! !!RFBClientMorph methodsFor: 'testing' stamp: 'ar 11/8/2004 18:20'!isActive	^rfbClient isActive! !!RFBClientMorph methodsFor: 'testing' stamp: 'ar 11/8/2004 18:20'!isConnected	"Answer whether the receiver is currently connected."	^rfbClient isConnected! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:27'!keyDown: anEvent	"Note: this event should be followed by a corresponding keyStroke, so we ignore the key value."	rfbClient keyDown: anEvent.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:27'!keyStroke: anEvent	"Send a key press to the server."	rfbClient keyStroke: anEvent! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:28'!keyUp: anEvent	"Send a key release to the server."	rfbClient keyUp: anEvent.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:28'!mouseDown: anEvent	"Send a mouse down event to the server."	"Note: Morphic doesn't really give us any chance to turn off button mapping.  So Ctrl+button1 yields button2, rather than button1 with the control modifier on.  While this is hunk-dory for Squeak, it's kind of a bummer when you need the vt menu in an xterm..."	rfbClient mouseDown: anEvent.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:28'!mouseEnter: anEvent	"The mouse just entered the window.  Remember that we now have control of the cursor.  If the server had previously installed a cursor in the receiver, set the Squeak cursor accordingly."	rfbClient mouseEnter: anEvent.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:28'!mouseLeave: anEvent	"The mouse has just left the window.  Note the fact that we no longer have control of the cursor.  If a cursor was saved on entry to the window, restore it now."	rfbClient mouseLeave: anEvent.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:30'!mouseMove: evt	"Send a motion event to the server."	| inside |	"Compensate for Morphic failing to send #mouseEnter:/Leave: correctly."	inside := scrollPane contentBounds containsPoint: evt position.	inside & rfbClient hasCursor not ifTrue: [rfbClient mouseEnter: evt].	inside not & rfbClient hasCursor ifTrue: [rfbClient mouseLeave: evt].	rfbClient mouseMove: evt.! !!RFBClientMorph methodsFor: 'events' stamp: 'ar 11/8/2004 18:04'!mouseUp: anEvent	"Send a button release event to the server."	self mouseMove: anEvent! !!RFBClientMorph methodsFor: 'opening' stamp: 'ar 11/8/2004 18:31'!open	"Open a RFBClient window."	(scrollPane := RFBScrollPane new)		extent: ((self width min: 300 max: 100) @ (self height min: 150 max: 100));		borderWidth: 0.	scrollPane scroller addMorph: self.	scrollPane		setScrollDeltas;		color: self color darker;		model: self.	window := (RFBSystemWindow labelled: 'SqueakVNC') model: self.	window addMorph: scrollPane frame: (0@0 corner: 1@1).	window openInWorld! !!RFBClientMorph methodsFor: 'client' stamp: 'klib 2/27/2012 14:54'!requestPassword: label	"this is never called from the main ui process"	| sema pass |	sema := Semaphore new.	WorldState addDeferredUIMessage:[		pass := UIManager default requestPassword: label.		sema signal.	].	sema wait.	^pass! !!RFBClientMorph methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:14'!rfbClient	^rfbClient! !!RFBClientMorph methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:36'!rfbClient: aClient	rfbClient := aClient.	rfbClient ifNotNil:[rfbClient target: self].! !!RFBClientMorph methodsFor: 'client' stamp: 'ar 11/8/2004 21:42'!rfbImage: aForm	"Indicates new image"	WorldState addDeferredUIMessage:[self updateImage: aForm].! !!RFBClientMorph methodsFor: 'client' stamp: 'ar 11/8/2004 21:42'!rfbInvalidate: aRectangle	"Indicates invalid rectangle"	WorldState addDeferredUIMessage:[self invalidRect: (aRectangle translateBy: bounds origin)].! !!RFBClientMorph methodsFor: 'private' stamp: 'ar 11/8/2004 18:45'!sendFullUpdateRequestForRegion: rectangles	^rfbClient sendFullUpdateRequestForRegion: rectangles! !!RFBClientMorph methodsFor: 'menu' stamp: 'ar 11/8/2004 18:04'!showAboutWindow	"Display a cheesy about window."	(StringHolder new contents: self aboutString)		openLabel: 'About the RFB/VNC Client (viewer)'! !!RFBClientMorph methodsFor: 'menu' stamp: 'ar 11/8/2004 18:04'!showHelpWindow	"Display a help window."	(StringHolder new contents: self helpString)		openLabel: 'Help for the RFB/VNC Client (viewer)'! !!RFBClientMorph methodsFor: 'client' stamp: 'ar 11/8/2004 21:42'!updateImage: aForm	self image: aForm.	scrollPane ifNotNil:[scrollPane setScrollDeltas].! !!RFBSystemWindow methodsFor: 'event handling' stamp: 'ikp 3/23/2004 12:00'!blueButtonDown: anEvent	"Pass the event to the client.  Override to avoid halo."	(model isActive and: [model blueButtonDown: anEvent])		ifFalse: [^super blueButtonDown: anEvent]! !!RFBSystemWindow methodsFor: 'event handling' stamp: 'ikp 3/23/2004 11:59'!blueButtonUp: anEvent	"Pass the event to the client only if active."	(model isActive and: [model blueButtonUp: anEvent])		ifFalse: [^super blueButtonDown: anEvent]! !!RFBSystemWindow methodsFor: 'nil' stamp: 'cao 2/20/2011 19:37'!buildWindowMenu	| aMenu |	aMenu := super buildWindowMenu.	aMenu addLine.	aMenu add: 'VNC' subMenu: (model getMenu: false).	^aMenu! !!RFBSystemWindow methodsFor: 'submorphs' stamp: 'ikp 3/23/2004 12:00'!delete	"Abort the client's connection before closing the window."	model abort.	^super delete! !!RFBPixelPopulation methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:54'!dominantPixel	"Answer the dominant pixel in the population represented by the receiver.  Since the receiver is a kind of Bag, this is just the key associated with the largest value.  Avoids the (very) expensive equivalent: aBag sortedContents first key."	| max dominant |	max := 0.	contents associationsDo: [:assoc |		assoc value > max			ifTrue:				[max := (dominant := assoc) value]].	^dominant isNil ifTrue: [0] ifFalse: [dominant key]! !!RFBStream class methodsFor: 'instance creation' stamp: 'ikp 3/16/2004 04:34'!forDepth: depth mask: pixelMask byteSwapped: swapped	"Answer a new RFBStream suitable for storing pixels at the given depth with natural or swapped byte order."	depth == 8 ifTrue: [^RFBStream new].	depth == 16 ifTrue: [^(swapped ifTrue: [RFBStreamSwap16] ifFalse: [RFBStream16]) new].	depth == 32 ifFalse: [self error: 'this cannot happen'].	^pixelMask < 16r01000000		ifTrue: [(swapped ifTrue: [RFBStreamSwap24] ifFalse: [RFBStream24]) new]		ifFalse: [(swapped ifTrue: [RFBStreamSwap32] ifFalse: [RFBStream32]) new]! !!RFBStream class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 03:04'!new	"Answer an empty stream suitable for storing 8-, 16- or 32-bit pixel values, with or without byte order swapping, depending on the receiver."	^super on: (ByteArray new: 256)! !!RFBStream methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:05'!at: index put: aByte	"Store a byte in the receiver at the given index (which must be less than the current write position) without changing the write position."	self		position: index;		nextPut: aByte;		setToEnd! !!RFBStream methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:46'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^1! !!RFBStream methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:36'!nextPutCPixel: pv	"Store an individual 'compressed' pixel value on the receiver."	^self nextPutPixel: pv! !!RFBStream methodsFor: 'accessing' stamp: 'ikp 3/14/2004 17:18'!nextPutForm: aForm in: bounds	"Write the contents of aForm to the receiver.  Note: this is VERY inefficient.  Encoders generally convert their Form to a ByteArray (using a BitBlt) and then write the resulting ByteArray (which is much faster).  See RFBForm>>asByteArray."	| peek |	peek := RFBBitBlt bitPeekerFromForm: aForm.	bounds top to: bounds bottom - 1 do:		[:y | bounds left to: bounds right - 1 do:			[:x | self nextPutPixel: (peek pixelAt: x@y)]]! !!RFBStream methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:08'!nextPutPixel: pv	"Store an individual 8-bit pixel value on the receiver."	^self nextPut: pv! !!RFBStream methodsFor: 'positioning' stamp: 'ikp 3/8/2004 03:09'!resetTo: offset	"Set the current write position to the given offset."	position := readLimit := offset.! !!RFBStream16 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:46'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^2! !!RFBStream16 methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:03'!nextPutPixel: pv	"Write a 16-bit pixel value to the receiver, in natural (big-endian) order."	^self		nextPut: ((pv bitShift: -8) bitAnd: 255);		nextPut: (pv  bitAnd: 255)! !!RFBStream24 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:47'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^3! !!RFBStream24 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:27'!nextPutCPixel: pv	"Write a 24-bit 'compressed' pixel to the receiver, in natural (big-endian) order."	^pv class == LargePositiveInteger		ifTrue:			[self				nextPut: (pv at: 3);				nextPut: (pv at: 2);				nextPut: (pv at: 1)]		ifFalse:			[self				nextPut: ((pv bitShift: -16) bitAnd: 255);				nextPut: ((pv bitShift: -8) bitAnd: 255);				nextPut: (pv  bitAnd: 255)]! !!RFBStream32 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:47'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^4! !!RFBStream32 methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:02'!nextPutPixel: pv	"Write a 32-bit pixel to the receiver, in natural (big-endian) order."	^pv class == LargePositiveInteger		ifTrue:			[self				nextPut: (pv at: 4);				nextPut: (pv at: 3);				nextPut: (pv at: 2);				nextPut: (pv at: 1)]		ifFalse:			[self				nextPut: ((pv bitShift: -24) bitAnd: 255);				nextPut: ((pv bitShift: -16) bitAnd: 255);				nextPut: ((pv bitShift: -8) bitAnd: 255);				nextPut: (pv  bitAnd: 255)]! !!RFBStreamSwap16 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:47'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^2! !!RFBStreamSwap16 methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:02'!nextPutPixel: pv	"Write a 16-bit pixel to the receiver, in little-endian order."	^self		nextPut: (pv  bitAnd: 255);		nextPut: ((pv bitShift: -8) bitAnd: 255)! !!RFBStreamSwap24 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:47'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^3! !!RFBStreamSwap24 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:28'!nextPutCPixel: pv	"Write a 24-bit 'compressed' pixel to the receiver, in little-endian order."	^pv class == LargePositiveInteger		ifTrue:			[self				nextPut: (pv at: 1);				nextPut: (pv at: 2);				nextPut: (pv at: 3)]		ifFalse:			[self				nextPut: (pv  bitAnd: 255);				nextPut: ((pv bitShift: -8) bitAnd: 255);				nextPut: ((pv bitShift: -16) bitAnd: 255)]! !!RFBStreamSwap32 methodsFor: 'accessing' stamp: 'ikp 3/16/2004 04:47'!bytesPerCompressedPixel	"Answer the minimum number of bytes required to represent just the bits covered by the RGB channels in the pixels stored by the receiver."	^4! !!RFBStreamSwap32 methodsFor: 'accessing' stamp: 'ikp 3/8/2004 03:01'!nextPutPixel: pv	"Write a 32-bit pixel to the receiver, in little-endian order."	^pv class == LargePositiveInteger		ifTrue:			[self				nextPut: (pv at: 1);				nextPut: (pv at: 2);				nextPut: (pv at: 3);				nextPut: (pv at: 4)]		ifFalse:			[self				nextPut: (pv  bitAnd: 255);				nextPut: ((pv bitShift: -8) bitAnd: 255);				nextPut: ((pv bitShift: -16) bitAnd: 255);				nextPut: ((pv bitShift: -24) bitAnd: 255)]! !!RFBZLibFakeStream class methodsFor: 'READ ME' stamp: 'ikp 3/17/2004 20:07'!readMe	"The following demontrates how this stream is used.  'Compressed' data generated from this method can be piped directly into the C implementation of zlib and will correctly reconstruct the origin input data."	"RFBZLibFakeStream readMe"	| zlib a b |	zlib := RFBZLibFakeStream on: (ByteArray new: 100).	zlib nextPutAll: 'Hello' asByteArray.	zlib nextPutAll: '...' asByteArray.	"signal a possible pause in the compressed data stream"	zlib synchronise.		"at this point the consumer will be guaranteed to receive all preceding data"	a := zlib contents.		"output data to send down the wire"	zlib position: 0.			"empty the output buffer"	"send some more data (maybe after a pause)..."	zlib nextPutAll: 'Goodbye!!' asByteArray.	zlib synchronise.		"as above"	b := zlib contents.		"idem"	^Array with: a with: b! !!RFBZLibFakeStream methodsFor: 'accessing' stamp: 'ikp 3/24/2004 02:04'!commit	"Write an empty, non-final, non-compressed block onto the receiver."	"Note:  This kind of empty block is a marker informing zlib of a potential 'pause' in the incoming compressed data stream.  It is detected by zlib's 'inflate_sync()' function which will subsequently ensure that all previously-read compressed data is fully inflated and made available to the final consumer.  It shows up in the compressed data stream as a sequence of five bytes: 0 0 0 255 255."	self nextPutBlock: (ByteArray new)! !!RFBZLibFakeStream methodsFor: 'accessing' stamp: 'ikp 3/17/2004 19:45'!nextPut16: anInteger	"Encode a 16-bit integer, LSB first."	self		nextPut: (anInteger bitAnd: 255);		nextPut: (anInteger bitShift: -8)! !!RFBZLibFakeStream methodsFor: 'accessing' stamp: 'ikp 3/17/2004 19:56'!nextPutAll: bytes	"Encode bytes onto the receiver as a sequence of one or more non-compressed blocks."	| in |	in := ReadStream on: bytes.	[in position < in size]		whileTrue:			[self nextPutBlock: (in next: (in size min: 65535))]! !!RFBZLibFakeStream methodsFor: 'accessing' stamp: 'ikp 3/17/2004 19:57'!nextPutBlock: bytes	"Write a non-compressed block containing bytes onto the receiver."	"Assumes: bytes size < 65536."	"NOTE:  If bytes is empty then an empty block is written on the receiver (see #synchronise)."	| len |	len := bytes size.	self		nextPut: 0;						"BFINAL, BTYPE: non-final, non-compressed; align(8)"		nextPut16: len;					"LEN"		nextPut16: (len bitXor: 16rFFFF).	"NLEN"	super nextPutAll: bytes				"literal data"! !!RFBZLibFakeStream methodsFor: 'initialise-release' stamp: 'ikp 3/17/2004 20:00'!on: aCollection	"Initialise the receiver and prepend a feasible 2-byte zlib stream header."	super on: aCollection.	self		nextPut: 120;		"32K dictionary window (irrelevant since we only send non-compressed blocks)"		nextPut: 1			"no presets, check sum (irrelevant since this stream *never* terminates)"! !!RFBZLibFakeStream methodsFor: 'accessing' stamp: 'ikp 3/24/2004 02:05'!synchronisedContents	"Flush all pending data, write an inflation synchronisation marker onto the encodedStream, and answer the contents of the encodedStream.  Reset the encodedStream to empty in the process."	| compressedData |	self commit.	compressedData := self contents.	self position: 0.	^compressedData! !!RFB3DES class methodsFor: 'examples' stamp: 'ul 7/3/2011 15:23'!example1	"Encrypts the password 'squeak' and verifies that the result is as expected.	Note: if you use 'squeak' as your real password then: (1) you are crazy to think such an obvious word is secure; and: (2) anybody who gains access to your image for more than 10 seconds will be in a position to look at the stored (encrypted) VNC password, compare it with the expected result below, and know instantly that your password is 'squeak'.  You have been warned."	"RFB3DES example1"	| data des |	data := (ByteArray new: 8) replaceFrom: 1 to: 6 with: 'squeak'.	des := RFB3DES new encryptionKey: #[23 82 107 6 35 78 88 7].	des des: data to: data.	data = #[252 108 241 14 193 201 46 62]		ifFalse: [self error: 'something rotten in the works'].	^data! !!RFB3DES class methodsFor: 'class initialisation' stamp: 'ul 7/3/2011 15:24'!initialize	"Initialise the various magic tables used for DES encryption."	"RFB3DES initialize"	BigByte := #(		16r800000	16r400000	16r200000	16r100000		16r080000	16r040000	16r020000	16r010000		16r008000	16r004000	16r002000	16r001000		16r000800	16r000400 	16r000200 	16r000100		16r000080	16r000040	16r000020	16r000010		16r000008	16r000004	16r000002	16r000001).	ByteBit := #[1 2 4 8 16 32 64 128].	"Key schedule [ANSI X3.92-1981]."	PC1 := #[		56 48  40 32 24 16  8		 0 57 49 41 33 25 17		 9   1 58 50 42 34 26		18 10  2 59 51 43 35		62 54  46 38 30 22 14		 6 61 53 45 37 29 21		13   5 60 52 44 36 28		20 12  4 27 19 11  3].	PC2 := #[	 	13 16 10 23  0  4  2 27 14  5 20  9		22 18 11  3 25  7 15  6 26 19 12  1		40 51 30 36 46 54 29 39 50 44 32 47		43 48 38 55 33 52 45 41 49 35 28 31].	TotRot := #[1 2 4 6 8 10 12 14 15 17 19 21 23 25 27 28].	SP1 := #(		16r01010400 16r00000000 16r00010000 16r01010404		16r01010004 16r00010404 16r00000004 16r00010000		16r00000400 16r01010400 16r01010404 16r00000400		16r01000404 16r01010004 16r01000000 16r00000004		16r00000404 16r01000400 16r01000400 16r00010400		16r00010400 16r01010000 16r01010000 16r01000404		16r00010004 16r01000004 16r01000004 16r00010004		16r00000000 16r00000404 16r00010404 16r01000000		16r00010000 16r01010404 16r00000004 16r01010000		16r01010400 16r01000000 16r01000000 16r00000400		16r01010004 16r00010000 16r00010400 16r01000004		16r00000400 16r00000004 16r01000404 16r00010404		16r01010404 16r00010004 16r01010000 16r01000404		16r01000004 16r00000404 16r00010404 16r01010400		16r00000404 16r01000400 16r01000400 16r00000000		16r00010004 16r00010400 16r00000000 16r01010004).	SP2 := #(		16r80108020 16r80008000 16r00008000 16r00108020		16r00100000 16r00000020 16r80100020 16r80008020		16r80000020 16r80108020 16r80108000 16r80000000		16r80008000 16r00100000 16r00000020 16r80100020		16r00108000 16r00100020 16r80008020 16r00000000		16r80000000 16r00008000 16r00108020 16r80100000		16r00100020 16r80000020 16r00000000 16r00108000		16r00008020 16r80108000 16r80100000 16r00008020		16r00000000 16r00108020 16r80100020 16r00100000		16r80008020 16r80100000 16r80108000 16r00008000		16r80100000 16r80008000 16r00000020 16r80108020		16r00108020 16r00000020 16r00008000 16r80000000		16r00008020 16r80108000 16r00100000 16r80000020		16r00100020 16r80008020 16r80000020 16r00100020		16r00108000 16r00000000 16r80008000 16r00008020		16r80000000 16r80100020 16r80108020 16r00108000).	SP3 := #(		16r00000208 16r08020200 16r00000000 16r08020008		16r08000200 16r00000000 16r00020208 16r08000200		16r00020008 16r08000008 16r08000008 16r00020000		16r08020208 16r00020008 16r08020000 16r00000208		16r08000000 16r00000008 16r08020200 16r00000200		16r00020200 16r08020000 16r08020008 16r00020208		16r08000208 16r00020200 16r00020000 16r08000208		16r00000008 16r08020208 16r00000200 16r08000000		16r08020200 16r08000000 16r00020008 16r00000208		16r00020000 16r08020200 16r08000200 16r00000000		16r00000200 16r00020008 16r08020208 16r08000200		16r08000008 16r00000200 16r00000000 16r08020008		16r08000208 16r00020000 16r08000000 16r08020208		16r00000008 16r00020208 16r00020200 16r08000008		16r08020000 16r08000208 16r00000208 16r08020000		16r00020208 16r00000008 16r08020008 16r00020200).	SP4 := #(		16r00802001 16r00002081 16r00002081 16r00000080		16r00802080 16r00800081 16r00800001 16r00002001		16r00000000 16r00802000 16r00802000 16r00802081		16r00000081 16r00000000 16r00800080 16r00800001		16r00000001 16r00002000 16r00800000 16r00802001		16r00000080 16r00800000 16r00002001 16r00002080		16r00800081 16r00000001 16r00002080 16r00800080		16r00002000 16r00802080 16r00802081 16r00000081		16r00800080 16r00800001 16r00802000 16r00802081		16r00000081 16r00000000 16r00000000 16r00802000		16r00002080 16r00800080 16r00800081 16r00000001		16r00802001 16r00002081 16r00002081 16r00000080		16r00802081 16r00000081 16r00000001 16r00002000		16r00800001 16r00002001 16r00802080 16r00800081		16r00002001 16r00002080 16r00800000 16r00802001		16r00000080 16r00800000 16r00002000 16r00802080).	SP5 := #(		16r00000100 16r02080100 16r02080000 16r42000100		16r00080000 16r00000100 16r40000000 16r02080000		16r40080100 16r00080000 16r02000100 16r40080100		16r42000100 16r42080000 16r00080100 16r40000000		16r02000000 16r40080000 16r40080000 16r00000000		16r40000100 16r42080100 16r42080100 16r02000100		16r42080000 16r40000100 16r00000000 16r42000000		16r02080100 16r02000000 16r42000000 16r00080100		16r00080000 16r42000100 16r00000100 16r02000000		16r40000000 16r02080000 16r42000100 16r40080100		16r02000100 16r40000000 16r42080000 16r02080100		16r40080100 16r00000100 16r02000000 16r42080000		16r42080100 16r00080100 16r42000000 16r42080100		16r02080000 16r00000000 16r40080000 16r42000000		16r00080100 16r02000100 16r40000100 16r00080000		16r00000000 16r40080000 16r02080100 16r40000100).	SP6 := #(		16r20000010 16r20400000 16r00004000 16r20404010		16r20400000 16r00000010 16r20404010 16r00400000		16r20004000 16r00404010 16r00400000 16r20000010		16r00400010 16r20004000 16r20000000 16r00004010		16r00000000 16r00400010 16r20004010 16r00004000		16r00404000 16r20004010 16r00000010 16r20400010		16r20400010 16r00000000 16r00404010 16r20404000		16r00004010 16r00404000 16r20404000 16r20000000		16r20004000 16r00000010 16r20400010 16r00404000		16r20404010 16r00400000 16r00004010 16r20000010		16r00400000 16r20004000 16r20000000 16r00004010		16r20000010 16r20404010 16r00404000 16r20400000		16r00404010 16r20404000 16r00000000 16r20400010		16r00000010 16r00004000 16r20400000 16r00404010		16r00004000 16r00400010 16r20004010 16r00000000		16r20404000 16r20000000 16r00400010 16r20004010).	SP7 := #(		16r00200000 16r04200002 16r04000802 16r00000000		16r00000800 16r04000802 16r00200802 16r04200800		16r04200802 16r00200000 16r00000000 16r04000002		16r00000002 16r04000000 16r04200002 16r00000802		16r04000800 16r00200802 16r00200002 16r04000800		16r04000002 16r04200000 16r04200800 16r00200002		16r04200000 16r00000800 16r00000802 16r04200802		16r00200800 16r00000002 16r04000000 16r00200800		16r04000000 16r00200800 16r00200000 16r04000802		16r04000802 16r04200002 16r04200002 16r00000002		16r00200002 16r04000000 16r04000800 16r00200000		16r04200800 16r00000802 16r00200802 16r04200800		16r00000802 16r04000002 16r04200802 16r04200000		16r00200800 16r00000000 16r00000002 16r04200802		16r00000000 16r00200802 16r04200000 16r00000800		16r04000002 16r04000800 16r00000800 16r00200002).	SP8 := #(		16r10001040 16r00001000 16r00040000 16r10041040		16r10000000 16r10001040 16r00000040 16r10000000		16r00040040 16r10040000 16r10041040 16r00041000		16r10041000 16r00041040 16r00001000 16r00000040		16r10040000 16r10000040 16r10001000 16r00001040		16r00041000 16r00040040 16r10040040 16r10041000		16r00001040 16r00000000 16r00000000 16r10040040		16r10000040 16r10001000 16r00041040 16r00040000		16r00041040 16r00040000 16r10041000 16r00001000		16r00000040 16r10040040 16r00001000 16r00041040		16r10001000 16r00000040 16r10000040 16r10040000		16r10040040 16r10000000 16r00040000 16r10001040		16r00000000 16r10041040 16r00040040 16r10000040		16r10040000 16r10001000 16r10001040 16r00000000		16r10041040 16r00041000 16r00041000 16r00001040		16r00001040 16r00040040 16r10000000 16r10041000).! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 12:21'!cookey: raw	"Answer a cooked version of the given raw key."	| raw1 dough cook raw0 cooked |	raw1 := 1.	dough := WordArray new: 32.	cook := 1.	16 timesRepeat:		[raw0 := raw1.		 raw1 := raw1 + 1.		 cooked :=				(((raw at: raw0) bitAnd: 16r00FC0000) bitShift: 6).		 cooked := cooked bitOr:	(((raw at: raw0) bitAnd: 16r00000FC0) bitShift: 10).		 cooked := cooked bitOr:	(((raw at: raw1) bitAnd: 16r00FC0000) bitShift: -10).		 cooked := cooked bitOr:	(((raw at: raw1) bitAnd: 16r00000FC0) bitShift: -6).		 dough at: cook put: cooked.		 cook := cook + 1.		 cooked :=				(((raw at: raw0) bitAnd: 16r0003F000) bitShift: 12).		 cooked := cooked bitOr:	(((raw at: raw0) bitAnd: 16r0000003F) bitShift: 16).		 cooked := cooked bitOr:	(((raw at: raw1) bitAnd: 16r0003F000) bitShift: -4).		 cooked := cooked bitOr:	(((raw at: raw1) bitAnd: 16r0000003F)).		 dough at: cook put: cooked.		 cook := cook + 1.		 raw1 := raw1 + 1].	self useKey: dough! !!RFB3DES methodsFor: 'accessing' stamp: 'ikp 3/5/2004 12:17'!decryptionKey: newKey	"Set the internal DES key to newKey, in a form appropriate for data decryption."	self desKey: newKey mode: #DE1! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 13:26'!des: block key: keyArray	"Perform DES en/decryption on the given data block using the keys stored in keyArray.  Update the data block in-place with the result."	| leftt right work keys fval |	leftt := block at: 1.	right := block at: 2.	work := ((leftt bitShift: -4) bitXor: right) bitAnd: 16r0F0F0F0F.	right := right bitXor: work.	leftt := leftt bitXor: (work bitShift: 4).	work := ((leftt bitShift: -16) bitXor: right) bitAnd: 16r0000FFFF.	right := right bitXor: work.	leftt := leftt bitXor: (work bitShift: 16).	work := ((right bitShift: -2) bitXor: leftt) bitAnd: 16r33333333.	leftt := leftt bitXor: work.	right := right bitXor: (work bitShift: 2).	work := ((right bitShift: -8) bitXor: leftt) bitAnd: 16r00FF00FF.	leftt := leftt bitXor: work.	right := right bitXor: (work bitShift: 8).	right := ((right bitShift: 1) bitOr: ((right bitShift: -31) bitAnd: 1)) bitAnd: 16rFFFFFFFF.	work := (leftt bitXor: right) bitAnd: 16rAAAAAAAA.	leftt := leftt bitXor: work.	right := right bitXor: work.	leftt := ((leftt bitShift: 1) bitOr: ((leftt bitShift: -31) bitAnd: 1)) bitAnd: 16rFFFFFFFF.	keys := ReadStream on: keyArray.	8 timesRepeat:		[work := ((right bitShift: 28) bitOr: (right bitShift: -4)) bitAnd: 16rFFFFFFFF.		work := work bitXor: keys next.		fval :=				(SP7 at: 1 + ((work)				bitAnd: 16r3F)).		fval := fval bitOr:	(SP5 at: 1 + ((work bitShift: -8)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP3 at: 1 + ((work bitShift: -16)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP1 at: 1 + ((work bitShift: -24)	bitAnd: 16r3F)).		work := right bitXor: keys next.		fval := fval bitOr:	(SP8 at: 1 + ((work)				bitAnd: 16r3F)).		fval := fval bitOr:	(SP6 at: 1 + ((work bitShift: -8)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP4 at: 1 + ((work bitShift: -16)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP2 at: 1 + ((work bitShift: -24)	bitAnd: 16r3F)).		leftt := leftt bitXor: fval.		work := ((leftt bitShift: 28) bitOr: (leftt bitShift: -4)) bitAnd: 16rFFFFFFFF.		work := work bitXor: keys next.		fval := 				(SP7 at: 1 + ((work)				bitAnd: 16r3F)).		fval := fval bitOr:	(SP5 at: 1 + ((work bitShift:  -8)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP3 at: 1 + ((work bitShift: -16)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP1 at: 1 + ((work bitShift: -24)	bitAnd: 16r3F)).		work := leftt bitXor: keys next.		fval := fval bitOr:	(SP8 at: 1 + ((work)				bitAnd: 16r3F)).		fval := fval bitOr:	(SP6 at: 1 + ((work bitShift:  -8)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP4 at: 1 + ((work bitShift: -16)	bitAnd: 16r3F)).		fval := fval bitOr:	(SP2 at: 1 + ((work bitShift: -24)	bitAnd: 16r3F)).		right := right bitXor: fval].	right := ((right bitShift: 31) bitOr: (right bitShift: -1)) bitAnd: 16rFFFFFFFF.	work := (leftt bitXor: right) bitAnd: 16rAAAAAAAA.	leftt := leftt bitXor: work.	right := right bitXor: work.	leftt := ((leftt bitShift: 31) bitOr: (leftt bitShift: -1)) bitAnd: 16rFFFFFFFF.	work := ((leftt bitShift: -8) bitXor: right) bitAnd: 16r00FF00FF.	right := right bitXor: work.	leftt := leftt bitXor: (work bitShift: 8).	work := ((leftt bitShift: -2) bitXor: right) bitAnd: 16r33333333.	right := right bitXor: work.	leftt := leftt bitXor: (work bitShift: 2).	work := ((right bitShift: -16) bitXor: leftt) bitAnd: 16r0000FFFF.	leftt := leftt bitXor: work.	right := right bitXor: (work bitShift: 16).	work := ((right bitShift: -4) bitXor: leftt) bitAnd: 16r0F0F0F0F.	leftt := leftt bitXor: work.	right := right bitXor: (work bitShift: 4).	block		at: 1 put: right;		at: 2 put: leftt! !!RFB3DES methodsFor: 'accessing' stamp: 'ikp 3/5/2004 13:28'!des: inBlock to: outBlock	"Encrypt or decrypt 8 bytes of data from inBlock, storing the result in outBlock.	Note: inBlock can == outBlock (which is useful for implicitly destroying plaintext data during encryption)."	| workArray |	workArray := WordArray new: 2.	1 to: inBlock size - 7 by: 8 do:		[:offset | self			scrunch: inBlock to: workArray startingAt: offset;			des: workArray key: knl;			unscrunch: workArray to: outBlock startingAt: offset]! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 12:25'!desKey: newKey mode: mode	"Set the internal en/decryption key based a raw newKey.  If mode is #EN0 then the internally-set key will be suitable for encryption; if mode == #DE1 then it will be suitable for decryption."	| pcr kn pc1m m n l |	pcr := ByteArray new: 56.	kn := WordArray new: 32.	pc1m := (PC1 collect: [:i |				m := i bitAnd: 7.				((newKey at: 1 + (i bitShift: -3)) bitAnd: (ByteBit at: 1 + m)) ~~ 0					ifTrue: [1]					ifFalse: [0]])		asByteArray.	0 to: 15 do: [:i |		m := (mode == #DE1				ifTrue: [15 - i]				ifFalse: [i])			 bitShift: 1.		n := m + 1.		kn at: 1 + m put: (kn at: 1 + n put: 0).		0 to: 27 do: [:j |			l := j + (TotRot at: 1 + i).			pcr at: 1 + j put: (pc1m at: 1 + (l < 28 ifTrue: [l] ifFalse: [l - 28]))].		28 to: 55 do: [:j |			l := j + (TotRot at: 1 + i).			pcr at: 1 + j put: (pc1m at: 1 + (l < 56 ifTrue: [l] ifFalse: [l - 28]))].		0 to: 23 do: [:j |			0 ~~ (pcr at: 1 + (PC2 at: 1 + j))				ifTrue: [kn at: 1 + m put: ((kn at: 1 + m) bitOr: (BigByte at: 1 + j))].			0 ~~ (pcr at: 1 + (PC2 at: 1 + j + 24))				ifTrue: [kn at: 1 + n put: ((kn at: 1 + n) bitOr: (BigByte at: 1 + j))]]].	self cookey: kn! !!RFB3DES methodsFor: 'accessing' stamp: 'ikp 3/5/2004 12:17'!encryptionKey: newKey	"Set the internal DES key to newKey, in a form appropriate for data encryption."	self desKey: newKey mode: #EN0! !!RFB3DES methodsFor: 'initialise-release' stamp: 'ul 7/8/2011 22:37'!initialize	"Default conditions: ready to en/decrypt, but with useless (null) keys."	super initialize.	knl := WordArray new: 32.	knr := WordArray new: 32.	kn3 := WordArray new: 32! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 13:32'!scrunch: bytes to: block	"Create a 2-word DES data block from 8 bytes of user data."	^self scrunch: bytes to: block startingAt: 1! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 13:31'!scrunch: bytes to: block startingAt: index	"Create a 2-word DES data block from 8 bytes of user data."	| tmp |	tmp :=				((bytes at: index + 0) bitShift: 24).	tmp := tmp bitOr:	((bytes at: index + 1) bitShift: 16).	tmp := tmp bitOr:	((bytes at: index + 2) bitShift: 8).	tmp := tmp bitOr:	((bytes at: index + 3)).	block at: 1 put: tmp.	tmp :=				((bytes at: index + 4) bitShift: 24).	tmp := tmp bitOr:	((bytes at: index + 5) bitShift: 16).	tmp := tmp bitOr:	((bytes at: index + 6) bitShift: 8).	tmp := tmp bitOr:	((bytes at: index + 7)).	block at: 2 put: tmp! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 13:32'!unscrunch: block to: bytes	"Create 8 bytes of user data from a 2-word DES data block."	^self unscrunch: block to: bytes startingAt: 1! !!RFB3DES methodsFor: 'private' stamp: 'ikp 3/5/2004 13:32'!unscrunch: block to: bytes startingAt: index	"Create 8 bytes of user data from a 2-word DES data block."	| tmp |	tmp := block at: 1.	bytes at: index + 0 put: ((tmp bitShift: -24)	bitAnd: 16rFF).	bytes at: index + 1 put: ((tmp bitShift: -16)	bitAnd: 16rFF).	bytes at: index + 2 put: ((tmp bitShift: -8)	bitAnd: 16rFF).	bytes at: index + 3 put: ((tmp 			)	bitAnd: 16rFF).	tmp := block at: 2.	bytes at: index + 4 put: ((tmp bitShift: -24)	bitAnd: 16rFF).	bytes at: index + 5 put: ((tmp bitShift: -16)	bitAnd: 16rFF).	bytes at: index + 6 put: ((tmp bitShift: -8)	bitAnd: 16rFF).	bytes at: index + 7 put: ((tmp 			)	bitAnd: 16rFF)! !!RFB3DES methodsFor: 'accessing' stamp: 'ikp 3/5/2004 12:20'!useKey: cookedKey	"Set the internal DES key to cookedKey.	Note: you almost certainly don't want to invoke this method directly (use #de/encryptionKey: instead), but if you do then you are responsible for cooking your own raw key beforehand."	knl := cookedKey! !!RFBClient class methodsFor: 'class initialisation' stamp: 'ar 11/8/2004 18:35'!initialiseConstants	"RFBClient initialiseConstants"	ProtocolMajor := 3.	ProtocolMinor := 7.	MessageTypes := #(		"0"	rfbFramebufferUpdate		"1"	rfbSetColourMapEntries		"2"	rfbBell		"3"	rfbServerCutText).	RfbEncodingAuto := -1.	(Encodings := Dictionary new)				"allow for gaps and LargeInts"		"version 3.3"		at: (RfbEncodingRaw		:= 0) put: #rfbEncodingRaw:;		at: (RfbEncodingCopyRect	:= 1) put: #rfbEncodingCopyRect:;		at: (RfbEncodingRRE			:= 2) put: #rfbEncodingRRE:;		at: (RfbEncodingCoRRE		:= 4) put: #rfbEncodingCoRRE:;		at: (RfbEncodingHextile		:= 5) put: #rfbEncodingHextile:;		"tight vnc"		at: (RfbEncodingZlib			:= 6) put: #rfbEncodingZlib:;		at: (RfbEncodingTight		:= 7) put: #rfbEncodingTight:;		at: (RfbEncodingZlibHex		:= 8) put: #rfbEncodingZlibHex:;		"version 3.7"		at: (RfbEncodingZRLE		:= 16) put: #rfbEncodingZRLE:;		"special encodings"		at: (RfbEncodingXCursor		:= 16rFFFFFF10) put: #rfbEncodingXCursor:;		at: (RfbEncodingRichCursor	:= 16rFFFFFF11) put: #rfbEncodingRichCursor:;		at: (RfbEncodingPointerPos	:= 16rFFFFFF18) put: #rfbEncodingPointerPos:;		at: (RfbEncodingLastRect	:= 16rFFFFFF20) put: #rfbEncodingLastRect:! !!RFBClient class methodsFor: 'class initialisation' stamp: 'ul 8/8/2012 02:43'!initialiseKeySyms	"Initialise the tables used to map MacRoman key event codes to X11 keysyms, and local modifier key bits to server modifier bits."	"RFBClient initialiseKeySyms"	"The viewer sends 16-bit X11R6 keysyms.  There are hundreds of these.  The following are just the most common."	KeySyms := Array new: 256.	#(	(16rFF08 8)		"bs"		(16rFF09 9)		"tab"		(16rFF0A 10)		"lf"		(16rFF0D 13)		"cr"		(16rFF1B 27)		"esc"		(16rFF50 1)		"home"		(16rFF51 28)		"left"		(16rFF52 30)		"up"		(16rFF53 29)		"right"		(16rFF54 31)		"down"		(16rFF55 11)		"prior"		(16rFF56 12)		"next"		(16rFF57 4)		"end"		(16rFFFF 127)	"del"	) do: [:symKey | KeySyms at: symKey second put: symKey first].	"The following works well for Apple keyboards.  Anyone who doesn't have an Apple keyboard may well suffer from a classic case of garbage-in, garbage-out"	ShiftKeySym		:= 16rFFE1.	"shift_l"	CtrlKeySym			:= 16rFFE3.	"control_l"	CommandKeySym	:= 16rFFE7.	"meta_l"	OptionKeySym		:= 16rFFE9.	"alt_l"	(ModifierMap := Array new: 5)		at: 1 put: ShiftKeySym;		at: 2 put: CtrlKeySym;		at: 3 put: OptionKeySym;		at: 4 put: CommandKeySym;		at: 5 put: CommandKeySym! !!RFBClient class methodsFor: 'class initialisation' stamp: 'ikp 3/23/2004 07:12'!initialisePreferences	"RFBClient initialisePreferences"	DefaultEncoding := RfbEncodingAuto.		"Automatically select encoding."	Enable8Bit := false.						"Default is local screen depth."	EnableShared := true.					"Default is to share connections."	EnableExpandOnBell := false.	EnableExpandOnConnection := false.		"For listen mode only."	EnableViewOnly := false.	EnableXCursor := true.	FastUpdate := false! !!RFBClient class methodsFor: 'class initialisation' stamp: 'ikp 3/24/2004 05:53'!initialize	"RFBClient initialize"	self		initialiseConstants;		initialisePreferences;		initialiseKeySyms;		registerInOpenMenu! !!RFBClient class methodsFor: 'opening' stamp: 'ikp 3/23/2004 11:53'!open	"Open a RFBClient window."	^self new open! !!RFBClient class methodsFor: 'private' stamp: 'ar 11/10/2004 16:56'!registerInOpenMenu	"Add RFBClient to the World open menu."	"RFBClient registerInOpenMenu"	Smalltalk at: #TheWorldMenu ifPresent:		[:theWorldMenu |  theWorldMenu registerOpenCommand:			{ 'RFB/VNC Viewer' . { RFBClient . #open } .			  'Open a VNC viewer to access a remote Squeak desktop (or any other kind of VNC server).' }]! !!RFBClient class methodsFor: 'class initialisation' stamp: 'ikp 3/24/2004 05:53'!unload	"RFBClient is being removed from the image."	self unregisterInOpenMenu! !!RFBClient class methodsFor: 'private' stamp: 'ikp 3/24/2004 05:56'!unregisterInOpenMenu	"Remove RFBClient from the World open menu."	"RFBClient unregisterInOpenMenu"	Smalltalk at: #TheWorldMenu ifPresent:		[:theWorldMenu |		 theWorldMenu unregisterOpenCommandWithReceiver: RFBClient].! !!RFBClient methodsFor: 'private' stamp: 'ar 11/8/2004 21:27'!abort	"Abort the connection."	self isConnected		ifTrue:			[socket closeAndDestroy.			 socket := nil.			 zlibStream := nil.			 process ~~ Processor activeProcess ifTrue: [process terminate].			 serverExtent := 0@0.			 self setExtent.			 currentCursor := nil.			 hasCursor := false.			 savedCursor isNil ifFalse: [savedCursor beCursor].			 savedCursor := nil]! !!RFBClient methodsFor: 'private' stamp: 'cao 2/20/2011 20:22'!asMorph	| m |	m := RFBClientMorph new.	m initializeExtension.	m isOpaque: true.	m rfbClient: self.	m rfbImage: image.	^m! !!RFBClient methodsFor: 'client process' stamp: 'ar 11/8/2004 21:41'!clientPriority	"Answer the scheduling priority at which the client should run."	"Note: since the client performs Morphic screen updates, it is highly likely that it will break Morphic if it runs at anything higher than userSchedulingPriority."	^Processor userInterruptPriority! !!RFBClient methodsFor: 'client process' stamp: 'ikp 3/22/2004 04:44'!clientRunLoop	"Run the loop in which the client sends and receives messages."	state := #rfbProtocolVersion.	socket runSafely:		[socket waitForData.		 self perform: state]! !!RFBClient methodsFor: 'private' stamp: 'ar 11/10/2004 11:56'!confirm: aString	^(target ifNil:[PopUpMenu]) confirm: aString! !!RFBClient methodsFor: 'connecting' stamp: 'ar 11/8/2004 18:07'!connect	"Open a new connection."	self isConnected ifTrue: [^self inform: 'This viewer is already connected.'].	self connectTo: RFBClientSocket connectedToServer.! !!RFBClient methodsFor: 'connecting' stamp: 'ar 11/8/2004 18:07'!connectTo: aSocket	"Open a new connection."	self isConnected ifTrue:[^self].	socket := aSocket ifNil:[^self].	process := [self clientRunLoop] forkAt: self clientPriority.! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/20/2004 09:44'!connectionFailed	"The server failed the connection attempt in an orderly fashion.  Read the failure reason then inform the user that the connection attemp failed and bail."	| message count |	message := socket receiveData: (RFBMessage new: 4).	count := message opcode.	message := socket receiveData: (String new: count).	self connectionFailed: message! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/20/2004 23:05'!connectionFailed: reason	"Inform the user that the connection attemp failed, then bail."	| message |	message := 'Connection failed: ', reason.	self log: message; inform: message.	self abort! !!RFBClient methodsFor: 'testing' stamp: 'ul 7/3/2011 15:24'!connectionIsLocal	"Answer whether the receiver is connected to a server on the same machine."	| peer |	peer := socket remoteAddress.	^peer = #[127 0 0 1] or: [peer = NetNameResolver localHostAddress]! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:08'!contentBounds	^0@0 extent: image extent! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 20:04'!contentsOfArea: aRectangle	^image contentsOfArea: aRectangle! !!RFBClient methodsFor: 'connecting' stamp: 'ikp 3/23/2004 10:33'!disconnect	"Close the new connection."	self isConnected ifFalse: [^self inform: 'This viewer is not connected.'].	(self confirm: 'Really disconnect?') ifTrue: [self abort]! !!RFBClient methodsFor: 'private' stamp: 'ar 11/8/2004 18:36'!display: sourceForm on: destForm in: destBounds	"Display the sourceForm on the destForm within destBounds and invalidate the Display accordingly.  If fast updates are disabled then yield the Processor to give other interactive processes a chance to run."	serverFormat display: sourceForm on: destForm at: destBounds origin.	target ifNotNil:[target rfbInvalidate: destBounds].	FastUpdate ifFalse: [Processor yield]! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/22/2004 04:23'!encodeButtons: buttonMask	"Answer a RFB button mask equivalent to the Squeak buttonMask."	| buttons |	buttons := 0.	#((1 2) (2 0) (4 -2)) do:		[:maskShift |		 buttons := buttons bitOr: ((buttonMask bitAnd: maskShift first) bitShift: maskShift second)].	^buttons! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/23/2004 03:23'!encodeKey: keyCode	"Answer a key sym corresponding to the given Squeak keyCode.  Note: if the Control key is down we don't encode.  This ensures that C-l (ascii 12) remains C-l (keysym 12) rather than 'page down' (MacRoman 12) which would be 'Next' (keysym #ff56)."	| keySym |	(modifierState anyMask: CtrlKeyBit) ifFalse: [keySym := KeySyms at: keyCode].	keySym isNil ifTrue: [keySym := keyCode].	^keySym! !!RFBClient methodsFor: 'menu' stamp: 'ar 11/8/2004 18:21'!encodingsMenu	"Answer the encodings submenu."	^RFBMenuMorph new		add: 'auto' get: [DefaultEncoding == RfbEncodingAuto]			set: [self setDefaultEncoding: RfbEncodingAuto]			help: 'Automatically select the most appropriate encoding.';		addLine;		add: 'Hextile' get: [DefaultEncoding == RfbEncodingHextile]			set: [self setDefaultEncoding: RfbEncodingHextile]			help: 'Use Hextile encoding.';		add: 'CoRRE' get: [DefaultEncoding == RfbEncodingCoRRE]			set: [self setDefaultEncoding: RfbEncodingCoRRE]			help: 'Use Compressed Rise and Run-length Encoding.';		add: 'RRE' get: [DefaultEncoding == RfbEncodingRRE]			set: [DefaultEncoding := RfbEncodingRRE]			help: 'Use Rise and Run-length Encoding.';		add: 'Raw' get: [DefaultEncoding == RfbEncodingRaw]			set: [self setDefaultEncoding: RfbEncodingRaw]			help: 'Use Raw encoding.';		add: 'ZRLE' get: [DefaultEncoding == RfbEncodingZRLE]			set: [self setDefaultEncoding: RfbEncodingZRLE]			help: 'Use Zlib Run-Length Encoding.';		yourself! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/20/2004 10:15'!encryptChallenge: challenge with: password	"Encrypt the 16-byte challenge with the given password.  Answer the encrypted challenge."	| block |	block := ByteArray new: 8.	1 to: (password size min: 8) do: [:i | block at: i put: (password at: i) asciiValue].	password atAllPut: (Character value: 0).	RFB3DES new		encryptionKey: block;		des: challenge to: challenge.	block atAllPut: 0.	^challenge! !!RFBClient methodsFor: 'accessing' stamp: 'ikp 3/23/2004 06:25'!fastUpdate	"Answer whether updates should be fast (uses more memory and impacts interactive response in other processes) or not (uses less memory and yields the Processor often)."	^FastUpdate! !!RFBClient methodsFor: 'testing' stamp: 'ar 11/8/2004 18:30'!hasCursor	^hasCursor! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 20:15'!image	^image! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 20:15'!image: newImage	image := newImage.! !!RFBClient methodsFor: 'private' stamp: 'ar 11/10/2004 11:55'!inform: aString	^(target ifNil:[PopUpMenu]) inform: aString! !!RFBClient methodsFor: 'initialise-release' stamp: 'ul 7/8/2011 22:37'!initialize	"Initial conditions."		super initialize.	image := RFBClientForm extent: 1@1 depth: Display depth.	serverExtent := 1@1.	sendLock := Semaphore forMutualExclusion.	updateRequestPending := true.	currentCursor := nil.	savedCursor := nil.	hasCursor := false.	modifierState := 0.	logClient := Transcript.! !!RFBClient methodsFor: 'testing' stamp: 'ikp 3/22/2004 10:54'!isActive	"Answer whether the receiver is currently connected and ready to send normal protocol messages."	^socket notNil and: [state == #rfbNormal]! !!RFBClient methodsFor: 'testing' stamp: 'ikp 3/20/2004 22:47'!isConnected	"Answer whether the receiver is currently connected."	^socket notNil! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/22/2004 09:57'!keyDown: anEvent	"Note: this event should be followed by a corresponding keyStroke, so we ignore the key value."	self processModifiers: anEvent buttons! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/22/2004 10:09'!keyStroke: anEvent	"Send a key press to the server."	self		processModifiers: anEvent buttons;		sendKeyEvent: (self encodeKey: anEvent keyValue) down: true;		sendPeriodicUpdateRequest! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/22/2004 10:09'!keyUp: anEvent	"Send a key release to the server."	self		processModifiers: anEvent buttons;		sendKeyEvent: (self encodeKey: anEvent keyValue) down: false! !!RFBClient methodsFor: 'private' stamp: 'ar 11/10/2004 14:06'!log: aMessage 	"Write aMessage to the client log."	logClient ifNotNil:[logClient cr; show: '[', thisContext sender printString,'] ', aMessage]! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:10'!logClient	^logClient! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:10'!logClient: aStream	logClient := aStream.! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/22/2004 11:17'!mouseDown: anEvent	"Send a mouse down event to the server."	"Note: Morphic doesn't really give us any chance to turn off button mapping.  So Ctrl+button1 yields button2, rather than button1 with the control modifier on.  While this is hunk-dory for Squeak, it's kind of a bummer when you need the vt menu in an xterm..."	self		processModifiers: anEvent buttons;		sendPointerEvent: anEvent buttons position: anEvent position! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/23/2004 03:01'!mouseEnter: anEvent	"The mouse just entered the window.  Remember that we now have control of the cursor.  If the server had previously installed a cursor in the receiver, set the Squeak cursor accordingly."	hasCursor		ifFalse:			[savedCursor := Cursor currentCursor.			 hasCursor := true.			 currentCursor isNil ifFalse: [currentCursor beCursor]]! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/23/2004 03:01'!mouseLeave: anEvent	"The mouse has just left the window.  Note the fact that we no longer have control of the cursor.  If a cursor was saved on entry to the window, restore it now."	hasCursor		ifTrue:			[hasCursor := false.			 savedCursor isNil ifFalse: [savedCursor beCursor]]! !!RFBClient methodsFor: 'events' stamp: 'ar 11/8/2004 18:48'!mouseMove: evt	"Send a motion event to the server."	self		processModifiers: evt buttons;		sendPointerEvent: evt buttons position: evt position! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/23/2004 11:51'!mousePoint: aPoint	"Answer a sanitised mouse point: truncated and constrained to lie within the viewer's inner bounds."	^((aPoint max: 0@0) min: image extent) truncated! !!RFBClient methodsFor: 'events' stamp: 'ikp 3/22/2004 05:52'!mouseUp: anEvent	"Send a button release event to the server."	self mouseMove: anEvent! !!RFBClient methodsFor: 'initialise-release' stamp: 'ar 11/8/2004 18:37'!open	^self asMorph open! !!RFBClient methodsFor: 'menu' stamp: 'ar 11/8/2004 18:21'!optionsMenu	"Answer the options submenu."	^RFBMenuMorph new		add: 'shared' get: [EnableShared] set: [EnableShared := EnableShared not]			help: 'Share the connection with other clients.';		add: 'local cursor' get: [EnableXCursor] set: [EnableXCursor := EnableXCursor not]			help: 'Local cursor shape tracks server cursor shape.';		add: 'view-only' get: [EnableViewOnly] set: [EnableViewOnly := EnableViewOnly not]			help: 'Do not send mouse and keyboard events to the server.';		add: '8-bit pixels' get: [Enable8Bit] set: [Enable8Bit := Enable8Bit not]			help: 'Use 8-bit depth to reduce bandwidth requirements.';		yourself! !!RFBClient methodsFor: 'menu' stamp: 'ar 11/8/2004 18:22'!performanceMenu	"Answer the performance submenu."	^RFBMenuMorph new		add: 'fast update' get: [FastUpdate] set: [FastUpdate := FastUpdate not]			help: 'Trade resources for update speed.  When enabled, updates will use more memory and the Processor will be devoted to processing the update (reducing interactive response in other windows).  When disabled, updates will use very little memory and the Processor will yield often (preserving response in other windows).';		yourself! !!RFBClient methodsFor: 'accessing' stamp: 'ikp 3/21/2004 03:41'!preferredEncoding	"Answer the preferred encoding, according to the current preferences."	DefaultEncoding == RfbEncodingAuto ifFalse: [^DefaultEncoding].	self connectionIsLocal		ifTrue: [^RfbEncodingRaw]		ifFalse: [^RfbEncodingHextile]! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/22/2004 11:14'!processModifiers: buttonMask	"Check for modifier key press/release and fake the corresponding events."	| prevState pressed released |	prevState := modifierState.	modifierState := buttonMask bitShift: -3.	pressed := (prevState bitXor: -1) bitAnd: modifierState.	released := (modifierState bitXor: -1) bitAnd: prevState.	self sendModifiers: released down: false.	self sendModifiers: pressed down: true! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/22/2004 01:56'!processUpdate: updateHeader	"Process a framebuffer update rectangle."	| type |	self		perform: (Encodings at: (type := updateHeader type) ifAbsent: [#rfbEncodingUnknown:])		with: updateHeader! !!RFBClient methodsFor: 'receiving' stamp: 'ikp 3/22/2004 05:35'!receiveCursorForm: aForm extent: extent	"Receive aForm from the connection."	| w h bits bytes byteRow wordRow |	w := extent x.	h := extent y.	bits := aForm bits.	bytes := ByteArray new: w * h.	socket receiveData: bytes.	1 to: h do: [:y |		byteRow := y - 1 * w.		wordRow := y - 1 * 4.		1 to: w do: [:x | bits byteAt: wordRow + x put: (bytes at: byteRow + x)]].	^aForm! !!RFBClient methodsFor: 'receiving' stamp: 'ikp 3/22/2004 05:24'!receiveForm: aForm	"Read the contents of aForm from the connection."	| bytesPerLine bytesPerScan byte buf |	bytesPerLine := aForm width * aForm bytesPerPixel.	bytesPerScan := bytesPerLine + 3 bitAnd: -4.	buf := ByteArray new: bytesPerScan * aForm height.	bytesPerLine == bytesPerScan		ifTrue:			[socket receiveData: buf]		ifFalse:			[byte := 1.			 1 to: aForm height do: [:y |				socket receiveData: buf startingAt: byte count: bytesPerLine.				byte := byte + bytesPerScan]].	(RFBForm new hackBits: buf) displayOn: (RFBForm new hackBits: aForm bits).	serverFormat swapBytesIfNeeded: aForm.! !!RFBClient methodsFor: 'private' stamp: 'klib 2/27/2012 14:54'!requestPassword: label	^(target ifNil:[UIManager default]) requestPassword: label! !!RFBClient methodsFor: 'message dispatching' stamp: 'ar 11/10/2004 11:53'!rfbAuthentication	"Read and process an incoming authentication challenge.  Prompt the user for a password and send back the encrypted response."	| message password |	message := socket receiveData: (RFBMessage new: 16).	password := self requestPassword: 'password?'.	message := self encryptChallenge: message with: password.	socket sendData: message.	"Read the authentication response immediately."	message := socket receiveData: (RFBMessage new: 4).	message opcode == RFBMessage rfbVncAuthOK ifTrue: [^self sendClientInitialisation].	self connectionFailed: 'permission denied'! !!RFBClient methodsFor: 'message dispatching' stamp: 'ikp 3/22/2004 11:15'!rfbAuthenticationType	"We're in version 3.3 handshake.  Read a 4-byte authentication type message from the server."	| message type |	message := socket receiveData: (RFBMessage new: 4).	type := message opcode.	type == RFBMessage rfbNoAuth ifTrue: [^self sendClientInitialisation].	type == RFBMessage rfbVncAuth ifTrue: [^state := #rfbAuthentication].	self connectionFailed: 'unknown authentication type: ', type printString! !!RFBClient methodsFor: 'server messages' stamp: 'ikp 3/22/2004 04:42'!rfbBell	"Read and process a bell message".	Display beepPrimitive! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/23/2004 08:22'!rfbEncodingCoRRE: updateHeader	"Process a compressed rise and run-length encoding update."	| form updateBounds |	updateBounds := updateHeader bounds.	form := RFBClientForm extent: updateBounds extent depth: serverFormat bitsPerPixel.	form correDecode: (0@0 extent: updateBounds extent) from: socket for: nil.	self display: form on: image in: updateBounds.	FastUpdate ifFalse: [Processor yield]! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingCopyRect: updateHeader	"Process a copy rect encoding update."	self log: 'rfbEncodingCopyRect: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/23/2004 07:36'!rfbEncodingHextile: updateHeader	"Process a hextile encoding update."	| form updateBounds |	updateBounds := updateHeader bounds.	FastUpdate		ifTrue:			[form := RFBClientForm extent: updateBounds extent depth: serverFormat bitsPerPixel.			 form hextileDecode: (0@0 extent: updateBounds extent) from: socket for: nil.			 self display: form on: image in: updateBounds]		ifFalse:			[image hextileDecode: updateBounds from: socket for: self]! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingLastRect: updateHeader	"Process a last rectangle update."	self log: 'rfbEncodingLastRect: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingPointerPos: updateHeader	"Process a pointer position update."	self log: 'rfbEncodingPointerPos: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/23/2004 08:12'!rfbEncodingRRE: updateHeader	"Process a rise and run-length encoding update."	| form updateBounds |	updateBounds := updateHeader bounds.	form := RFBClientForm extent: updateBounds extent depth: serverFormat bitsPerPixel.	form rreDecode: (0@0 extent: updateBounds extent) from: socket for: nil.	self display: form on: image in: updateBounds.	FastUpdate ifFalse: [Processor yield]! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/23/2004 06:51'!rfbEncodingRaw: updateHeader	"Process a raw encoding update."	| form updateBounds |	updateBounds := updateHeader bounds.	form := RFBForm extent: updateBounds extent depth: serverFormat bitsPerPixel.	self receiveForm: form.	self display: form on: image in: updateBounds! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingRichCursor: updateHeader	"Process a rich cursor update."	self log: 'rfbEncodingRichCursor: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingTight: updateHeader	"Process a tight encoding update."	self log: 'rfbEncodingTight: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/22/2004 03:40'!rfbEncodingUnknown: updateHeader	"Process an unknown encoding update."	self log: 'rfbEncodingUnknown: ', updateHeader printString.	self connectionFailed: 'protocol error'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/22/2004 05:35'!rfbEncodingXCursor: updateHeader	"Process a X11-style cursor update."	| hotSpot extent cursor mask cursorExtent realCursor realMask |	hotSpot := updateHeader cursorHotSpot.	extent := updateHeader cursorExtent.	cursorExtent := extent + (7@0) // (8@1).	socket receiveData: (RFBXCursorColoursHeader new).	"IGNORED."	cursor := Form extent: extent depth: 1.	mask := Form extent: extent depth: 1.	self receiveCursorForm: cursor extent: cursorExtent.	self receiveCursorForm: mask extent: cursorExtent.	realCursor := CursorWithMask extent: 16@16 depth: 1.	realMask := Form extent: 16@16 depth: 1.	cursor displayOn: realCursor.	mask displayOn: realMask.	realCursor setMaskForm: realMask.	realCursor offset: hotSpot negated.	currentCursor := realCursor.	hasCursor ifTrue: [realCursor beCursor]! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/24/2004 04:05'!rfbEncodingZRLE: updateHeader	"Process a zlib run-length encoding update."	| length updateBounds bytes form |	updateBounds := updateHeader bounds.	length := (socket receiveData: RFBZRLEHeader new) length.	bytes := socket receiveData: (ByteArray new: length).	zlibStream isNil		ifTrue: [(zlibStream := RFBZLibReadStream on: bytes)					getPixel: socket getPixel getCPixel: socket getCPixel]		ifFalse: [zlibStream continueOn: bytes].	form := RFBClientForm extent: updateBounds extent depth: serverFormat bitsPerPixel.	form zrleDecode: (0@0 extent: updateBounds extent)		from: zlibStream		for: nil.	self display: form on: image in: updateBounds.	FastUpdate ifFalse: [Processor yield]! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:56'!rfbEncodingZlib: updateHeader	"Process a zlib encoding update."	self log: 'rfbEncodingZlib: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'updating' stamp: 'ikp 3/21/2004 04:57'!rfbEncodingZlibHex: updateHeader	"Process a zlib hextile encoding update."	self log: 'rfbEncodingZlibHex: ', updateHeader printString.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'server messages' stamp: 'ikp 3/22/2004 04:48'!rfbFramebufferUpdate	"Read and process a framebuffer update message."	| header update |	header := RFBFramebufferUpdateRectHeader new.	update := socket receiveNew: RFBFramebufferUpdate.	update nRects timesRepeat: [self processUpdate: (socket receiveData: header)]! !!RFBClient methodsFor: 'message dispatching' stamp: 'ar 11/8/2004 18:35'!rfbInitialisation	"Read and process an incoming server initialisation message."	| message |	message := socket receiveData: RFBServerInitialisation new.	serverExtent := message width @ message height.	serverFormat := message pixelFormat setReverseMaps.	self log: 'server pixel format ', serverFormat printString.	serverName := socket receiveString.	self sendSetEncodings.	self setExtent.	socket		initialiseForDepth: serverFormat bitsPerPixel		mask: serverFormat pixelMask		byteSwapped: serverFormat bigEndian not.	state := #rfbNormal.	updateRequestPending := false.	self sendFullUpdateRequest! !!RFBClient methodsFor: 'message dispatching' stamp: 'ikp 3/22/2004 04:55'!rfbNormal	"Receive and process an incoming normal protocol message."	| type |	type := (socket receiveData: (RFBMessage new: 1)) byteAt: 1.	(type < 0) | (type >= MessageTypes size)		ifTrue:			[self log: 'illegal message type ' , type printString , ' received'.			 ^self abort].	self perform: (MessageTypes at: 1 + type).	updateRequestPending := true.	self sendPeriodicUpdateRequest! !!RFBClient methodsFor: 'message dispatching' stamp: 'ikp 3/22/2004 11:14'!rfbProtocolVersion	"Receive and process an incoming protocol version message.  Check compatibility and reply with our protocol version, then expect an authentication type message (3.3) or a security types message (3.7)."	| message protocolMajor |	message := socket receiveData: (String new: 12).	protocolMajor := (message copyFrom: 5 to: 7) asInteger.	protocolMinor := (message copyFrom: 9 to: 11) asInteger.	self log: 'server version ', protocolMajor printString, '.', protocolMinor printString.	self log: 'viewer version ', ProtocolMajor printString, '.', ProtocolMinor printString.	protocolMinor := protocolMinor min: ProtocolMinor.	(protocolMinor < 7 and: [protocolMinor > 3]) ifTrue: [protocolMinor := 3].	socket sendData: (RFBMessage protocolVersionMajor: ProtocolMajor minor: protocolMinor).	protocolMajor == ProtocolMajor		ifTrue:			[protocolMinor == 3 ifTrue: [^state := #rfbAuthenticationType].			 protocolMinor == 7 ifTrue: [^state := #rfbSecurityTypes]].	self connectionFailed: 'incompatible protocol version'! !!RFBClient methodsFor: 'message dispatching' stamp: 'ikp 3/22/2004 11:14'!rfbSecurityTypes	"We're in version 3.7 handshake.  Read a list of supported security schemes and reply with the one we prefer."	| message count |	message := socket receiveData: (RFBMessage new: 1).	count := message type.	count == 0 ifTrue: [^self connectionFailed].	message := socket receiveData: (RFBMessage new: count).	(message indexOf: RFBMessage rfbNoAuth) ~~ 0		ifTrue:			[socket sendData: (RFBMessage with: RFBMessage rfbNoAuth).			 ^self sendClientInitialisation].	(message indexOf: RFBMessage rfbVncAuth) ~~ 0		ifTrue:			[socket sendData: (RFBMessage with: RFBMessage rfbVncAuth).			 ^state := #rfbAuthentication].	^self connectionFailed: ['no supported security type']! !!RFBClient methodsFor: 'server messages' stamp: 'ikp 3/22/2004 04:27'!rfbServerCutText	"Read and process a server cut text message"	| length string |	length := (socket receiveNew: RFBClientCutText) length.	string := socket receiveData: (String new: length).	Clipboard clipboardText: string asText! !!RFBClient methodsFor: 'server messages' stamp: 'ikp 3/20/2004 23:09'!rfbSetColourMapEntries	"Read and process a set colourmap entries message".self log: 'rfbSetColourMapEntries'.	self connectionFailed: 'unimplemented'! !!RFBClient methodsFor: 'client messages' stamp: 'ikp 3/21/2004 03:33'!sendClientInitialisation	"Send a client initialisation message to the server.  This is a 1-byte flag indicating whether the connection should be shared."	socket sendData: (RFBMessage with: (EnableShared ifTrue: [1] ifFalse: [0])).	state := #rfbInitialisation! !!RFBClient methodsFor: 'sending' stamp: 'ar 11/10/2004 13:54'!sendData: aMessage	"Send aMessage to the server.  Assure mutually-exclusive access to the socket."	sendLock critical:		[[socket sendData: aMessage]			on: Exception			do: [:ex| self log: ex printString; abort]]! !!RFBClient methodsFor: 'client messages' stamp: 'ikp 3/21/2004 03:32'!sendFramebufferUpdateRequest: updateBounds incremental: incrementalFlag	"Send a framebufferUpdateRequest to the server."	self sendData: (RFBFramebufferUpdateRequest						bounds: updateBounds						incremental: incrementalFlag)! !!RFBClient methodsFor: 'private' stamp: 'ar 11/8/2004 18:08'!sendFullUpdateRequest	"Send a full framebuffer update request for the visible area."	self sendFramebufferUpdateRequest: self contentBounds incremental: false! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/23/2004 13:11'!sendFullUpdateRequestForRegion: rectangles	"Send a full framebuffer update request for the given rectangles."	rectangles do:		[:rect | self sendFramebufferUpdateRequest: rect incremental: false]! !!RFBClient methodsFor: 'client messages' stamp: 'ikp 3/23/2004 11:53'!sendKeyEvent: keyCode down: downFlag	"Send a key event with keyCode to keySym translation."	self		sendData: (RFBKeyEvent key: keyCode down: downFlag);		sendPeriodicUpdateRequest! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/22/2004 10:12'!sendModifiers: modifiers down: downFlag	"Send fake key press/release events for modifier keys."	| mask |	mask := 1.	ModifierMap do:		[:keySym |		 (modifiers bitAnd: mask) ~~ 0			ifTrue: [self sendKeyEvent: keySym down: downFlag].		 mask := mask bitShift: 1]! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/22/2004 10:22'!sendPeriodicUpdateRequest	"Send an incremental framebuffer update request for the visible area only if a protocol message has been received since the last such request."	updateRequestPending		ifTrue:			[self sendUpdateRequest.			 updateRequestPending := false]! !!RFBClient methodsFor: 'client messages' stamp: 'ikp 3/23/2004 11:50'!sendPointerEvent: buttonMask position: aPoint	"Send a pointer event."	self		sendData: (RFBPointerEvent						buttonMask: (self encodeButtons: buttonMask)						position: (self mousePoint: aPoint));		sendPeriodicUpdateRequest! !!RFBClient methodsFor: 'client messages' stamp: 'ikp 3/24/2004 04:39'!sendSetEncodings	"Send a set encodings message to the server according to the current preferences."	| encodings preferred setEncodings |	preferred := self preferredEncoding.	(preferred == RfbEncodingZRLE and: [protocolMinor < 7])		ifTrue: [preferred := RfbEncodingHextile].	(encodings := OrderedCollection new)		add: preferred;		add: RfbEncodingHextile;		add: RfbEncodingCoRRE;		add: RfbEncodingRRE;		add: RfbEncodingRaw.	EnableXCursor ifTrue: [encodings add: RfbEncodingXCursor].	setEncodings := RFBSetEncodings new: encodings size.	encodings doWithIndex: [:encoding :index | setEncodings encodingAt: index put: encoding].	self sendData: setEncodings! !!RFBClient methodsFor: 'private' stamp: 'ar 11/8/2004 18:08'!sendUpdateRequest	"Send an incremental framebuffer update request for the visible area."	self sendFramebufferUpdateRequest: self contentBounds incremental: true! !!RFBClient methodsFor: 'accessing' stamp: 'ikp 3/23/2004 07:56'!serverFormat	"Answer the pixel format in use on the server."	^serverFormat! !!RFBClient methodsFor: 'private' stamp: 'ikp 3/24/2004 04:40'!setDefaultEncoding: encodingNumber	"Set the default encoding.  If the client is connected, change the encoding in use for the session."	DefaultEncoding := encodingNumber.	self isActive ifTrue: [self sendSetEncodings]! !!RFBClient methodsFor: 'private' stamp: 'ar 11/8/2004 18:36'!setExtent	"Set the extent of the server desktop."	serverFormat isNil		ifFalse:			[image := RFBClientForm extent: serverExtent depth: serverFormat bitsPerPixel.			target ifNotNil:[target rfbImage: image].			self isActive ifTrue: [self sendFullUpdateRequest]]! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:36'!target	^target! !!RFBClient methodsFor: 'accessing' stamp: 'ar 11/8/2004 18:36'!target: newTarget	target := newTarget.! !!RFBPalette class methodsFor: 'class initialisation' stamp: 'ikp 3/15/2004 19:22'!initialize	"RFBPalette initialize"	RfbPaletteMaxSize := 127.! !!RFBPalette methodsFor: 'initialise-release' stamp: 'ul 7/8/2011 22:37'!initialize	"RFBPalette new"	super initialize.	pixels := WordArray new: RfbPaletteMaxSize.	index := ByteArray new: (RfbPaletteMaxSize + 4096).	key := WordArray new: RfbPaletteMaxSize + 4096.	index atAllPut: 255.	size := 0! !!RFBPalette methodsFor: 'accessing' stamp: 'ul 7/8/2011 22:50'!insert: pixelValue	"Add pixelValue to the palette if not already present, retaining its reverse index."	| i |	size < RfbPaletteMaxSize		ifTrue:			[i := (self zrleHash: pixelValue) + 1.			 [(index at: i) = 255] whileFalse: [				(key at: i) = pixelValue ifTrue: [ ^self ].				i := i + 1].			 index at: i put: size.			 key at: i put: pixelValue.			 pixels at: 1 + size put: pixelValue].	size := size + 1! !!RFBPalette methodsFor: 'accessing' stamp: 'ul 8/16/2012 17:42'!lookup: pixelValue	"Answer the palette index associated with pixelValue."	| i result |	i := (self zrleHash: pixelValue) + 1.	[		(result := index at: i) = 255 ifTrue: [ ^-1 ].		(key at: i) = pixelValue ] whileFalse: [ i := i + 1 ].	^result! !!RFBPalette methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:32'!pixels	"Answer the pixel values stored in the receiver."	^pixels! !!RFBPalette methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:32'!size	"Answer the number of pixel values stored in the receiver."	^size! !!RFBPalette methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:32'!size: anInteger	"Set the number of pixels stored in the receiver."	size := anInteger! !!RFBPalette methodsFor: 'private' stamp: 'klub 5/17/2010 02:39'!zrleHash: pixelValue	"Return a SmallInteger hash for pixelValue, in the range 0..4095."	^(pixelValue bitXor: (pixelValue // 131072)) bitAnd: 4095! !!RFBPixelFormat class methodsFor: 'instance creation' stamp: 'ikp 2/19/2007 21:07'!forForm: aForm	"Answer a pixel format describing the pixels in aForm, in host byte order."	^self new forForm: aForm bigEndian: SmalltalkImage current isBigEndian! !!RFBPixelFormat class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:52'!forForm: aForm bigEndian: endianFlag	"Answer a pixel format that describes the pixels in aForm, in the specified byte order."	^self new forForm: aForm bigEndian: endianFlag! !!RFBPixelFormat class methodsFor: 'instance creation' stamp: 'ikp 3/8/2004 02:53'!fromByteArray: aByteArray	"Answer a new pixel format initialised from the wire representation in aByteArray."	^(self new fromByteArray: aByteArray) setMaps! !!RFBPixelFormat class methodsFor: 'instance creation' stamp: 'ikp 2/29/2004 05:41'!serverFormat	"RFBPixelFormat serverFormat"	^self forForm: Display! !!RFBPixelFormat methodsFor: 'converting' stamp: 'ikp 3/8/2004 02:51'!asByteArray	"Answer a ByteArray containing the wire representation of the receiver, suitable for inclusion in a protocol message."	^(ByteArray new: 16)		byteAt: 1 put: bitsPerPixel;		byteAt: 2 put: depth;		byteAt: 3 put: (bigEndian ifTrue: [1] ifFalse: [0]);		byteAt: 4 put: (trueColour ifTrue: [1] ifFalse: [0]);		unsignedShortAt: 5 put: redMax bigEndian: true;		unsignedShortAt: 7 put: greenMax bigEndian: true;		unsignedShortAt: 9 put: blueMax bigEndian: true;		byteAt: 11 put: redShift;		byteAt: 12 put: greenShift;		byteAt: 13 put: blueShift;		yourself! !!RFBPixelFormat methodsFor: 'colour maps' stamp: 'ikp 3/8/2004 02:46'!bgr233ColourMap	"Answer a ColorMap that maps pixels from 32-bit ARGB8888 space into the BGR233 space used by viewers running in 8-bit 'true colour' mode."	^ColorMap colors:		((Color cachedColormapFrom: 8 to: 32) collect: [:pv |			((((pv bitShift: -16-5)) bitAnd: 7) bitShift: 0)			bitOr: (((((pv bitShift: -8-5)) bitAnd: 7) bitShift: 3)			bitOr: ((((pv bitShift: -0-6)) bitAnd: 3) bitShift: 6))])! !!RFBPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:44'!bigEndian	"Answer whether pixels in the format described by the receiver are big-endian (have most significant byte first in memory order)."	^bigEndian! !!RFBPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:47'!bigEndian: aBoolean	"Set the flag indicating that the format represented by the receiver stores pixels with the most significant byte first in memory order."	bigEndian := aBoolean! !!RFBPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:48'!bitsPerPixel	"Answer the number of bits required to store a single pixel in the format described by the receiver.  This will always be 8, 16 or 32."	^bitsPerPixel! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/8/2004 02:49'!bppForDepth: squeakDepth	"Answer the number of bits per pixel for a pixel format corresponding to the given Squeak display depth."	squeakDepth <= 8 ifTrue: [^8].	squeakDepth == 16 ifTrue: [^16].	squeakDepth == 32 ifTrue: [^32].	self error: 'Ian is confused'! !!RFBPixelFormat methodsFor: 'colour maps' stamp: 'ikp 3/8/2004 02:38'!colormapFromARGB	"Answer a ColorMap that converts ARGB8888 into the pixel format described by the receiver."	^trueColour		ifTrue: [ColorMap mappingFromARGB: self rgbMasks]		ifFalse: [(Form extent: 0@0 depth: depth) colormapFromARGB]! !!RFBPixelFormat methodsFor: 'accessing' stamp: 'ikp 3/8/2004 02:43'!colourMap	"Answer the ColorMap used to convert pixels from server format to the viewer format described by the receiver."	^colourMap! !!RFBPixelFormat methodsFor: 'printing' stamp: 'ikp 3/8/2004 02:36'!description	"Answer a terse, human-readable description of the receiver."	^String streamContents: [:s | s		nextPutAll: bitsPerPixel printString;		nextPutAll: 'bpp, depth ';		nextPutAll: depth printString;		nextPutAll: ' ';		nextPutAll: (bigEndian ifTrue: ['BE, '] ifFalse: ['LE, ']);		nextPutAll: (trueColour ifTrue: ['true'] ifFalse: ['pseudo']); nextPutAll: ' colour';		nextPutAll: ' ';		nextPutAll: redMax printString; nextPutAll: ',';		nextPutAll: greenMax printString; nextPutAll: ',';		nextPutAll: blueMax printString; nextPutAll: ' ';		nextPutAll: redShift printString; nextPutAll: '+';		nextPutAll: greenShift printString; nextPutAll: '+';		nextPutAll: blueShift printString]! !!RFBPixelFormat methodsFor: 'encoding' stamp: 'ikp 3/21/2004 08:41'!display: sourceForm on: destForm at: destOrigin	"Display the sourceForm on the destForm at destOrigin with pixels converted from the format described by the receiver."	"Note: pixel zero is transparent, so first fill the affected region with black (#000001) and then combine with Form paint instead of Form over."	destForm fill: (destOrigin extent: sourceForm extent) fillColor: Color black.	(BitBlt toForm: destForm)		sourceForm: sourceForm;		combinationRule: Form paint;		destOrigin: destOrigin;		colorMap: colourMap;		copyBits! !!RFBPixelFormat methodsFor: 'encoding' stamp: 'ikp 3/14/2004 15:08'!displayContents: bounds	"Answer a Form containing a copy of the Display within the given bounds, with pixels stored in the format described by the receiver."	| form |	form := RFBForm fromDisplay: bounds format: self.	colourMap isNil		ifFalse:			[(BitBlt toForm: form)				sourceForm: form;				combinationRule: 3;				colorMap: colourMap;				copyBits]."	orderMap isNil		ifFalse:			[(BitBlt toForm: form)				sourceForm: form;				combinationRule: 3;				colorMap: orderMap;				copyBits]."	^form! !!RFBPixelFormat methodsFor: 'initialise-release' stamp: 'ikp 3/8/2004 02:42'!forForm: aForm bigEndian: endianFlag	"Initialise the contents of the receiver to represent pixels as stored in aForm and with the specified byte order."	bitsPerPixel := self bppForDepth: (depth := aForm depth).	bigEndian := endianFlag.	bitsPerPixel == 8		ifTrue:			[trueColour := false.			 redMax := greenMax := blueMax := 0.			 redShift := greenShift := blueShift := 0].	bitsPerPixel == 16		ifTrue:			[trueColour := true.			 redMax := greenMax := blueMax := (1 bitShift: 5) - 1.			 redShift := 10.			 greenShift := 5.			 blueShift := 0].	bitsPerPixel == 32		ifTrue:			[trueColour := true.			 redMax := greenMax := blueMax := (1 bitShift: 8) - 1.			 redShift := 16.			 greenShift := 8.			 blueShift := 0]! !!RFBPixelFormat methodsFor: 'initialise-release' stamp: 'ikp 3/8/2004 02:36'!fromByteArray: bytes	"Initialise the contents of the receiver from a pixel format received in a protocol message."	bitsPerPixel := bytes byteAt: 1.	depth := bytes byteAt: 2.	bigEndian := (bytes byteAt: 3) ~~ 0.	trueColour := (bytes byteAt: 4) ~~ 0.	redMax := bytes unsignedShortAt: 5 bigEndian: true.	greenMax := bytes unsignedShortAt: 7 bigEndian: true.	blueMax := bytes unsignedShortAt: 9 bigEndian: true.	redShift := bytes byteAt: 11.	greenShift := bytes byteAt: 12.	blueShift := bytes byteAt: 13.! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/16/2004 04:33'!pixelMask	"Answer a mask covering all three RGB channels in the format described by the receiver."	^((redMax bitShift: redShift)		bitOr: (greenMax bitShift: greenShift))		bitOr: (blueMax bitShift: blueShift)! !!RFBPixelFormat methodsFor: 'printing' stamp: 'ikp 3/8/2004 02:39'!printOn: aStream	"Print a description of the receiver on aStream."	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self description;		nextPut: $).! !!RFBPixelFormat methodsFor: 'encoding' stamp: 'ikp 3/16/2004 04:31'!rfbStream	"Answer a new RFBStream suitable for writing bytes and pixels in the format described by the receiver."	^RFBStream forDepth: bitsPerPixel mask: self pixelMask byteSwapped: bigEndian not! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 2/25/2004 11:28'!rgbMasks	"RFBPixelFormat serverFormat rgbMasks collect: [:m | m hex8]"	"ColorMap mappingFrom: RFBPixelFormat serverFormat rgbMasks to: #(16rFF0000 16r00FF00 16r0000FF 0)"	"ColorMap mappingFrom: RFBPixelFormat serverFormat rgbMasks to:  #(16r7C00 16r3E0 16r1F 0)"	^Array		with: (redMax bitShift: redShift)		with: (greenMax bitShift: greenShift)		with: (blueMax bitShift: blueShift)		with: 0! !!RFBPixelFormat methodsFor: 'private' stamp: 'ikp 3/14/2004 18:34'!setColourMap: serverFormat	"Set the ColorMap used to convert screen pixels to viewer pixels in local byte order.  For depth 32, ensure that the map clears (sets to zero) the alpha channel."	"Rationale:  Remote viewers ignore the alpha channel in 32-bit pixels.  Locally it is stored in the top 8 bits of each word, and is almost always fully-opaque (i.e., 255) for pixels in the Display.  The vast majority of pixels in the underlying Bitmap are therefore LargePositiveIntegers.  Clearing the alpha to zero means the resulting Bitmap contains only SmallIntegers, eliminating entirely the creation of temporary LargeInts (along with any subsequent LargeInt arithmetic on them and the consequent GC overheads) during encoding.  This reduces the overall cost (in processor time) of encoding by at least 30% for all non-raw encodings."	| form |	form := Form extent: 0@0 depth: bitsPerPixel.	(trueColour and: [(self rgbMasks = form rgbaBitMasks) not])		ifTrue:			[colourMap := bitsPerPixel == 8				ifTrue: [self bgr233ColourMap]				ifFalse: [form colormapFromARGB mappingTo: self colormapFromARGB]].	(colourMap notNil and: [colourMap masks notNil])		ifTrue:			[colourMap masks at: 4 put: 0.			 colourMap shifts at: 4 put: 0]! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/21/2004 07:35'!setMaps	"The receiver describes a remote pixel format.  Initialise the cached ColorMaps used for local->remote pixel format conversion."	^self setMaps: self species serverFormat! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/14/2004 16:19'!setMaps: serverFormat	"Set the receiver's ColorMaps that describe the mapping from screen pixels to viewer pixels."	"Note that this involves up to two corrections: pixel format conversion (mask and shift to resize and/or reposition each RGB channel) and byte order reversal (to correct for server/client endian differences).  Both corrections could be combined into a single operation (a single ColorMap), but are kept seperate such that encoding is always performed on pixels in *viewer* format but *server* byte order (RFBPixelFormat>>displayContents:), with any required byte order correction being delayed until pixels are actually sent down the wire (RFBSession>>nextPutForm:in:).  See RFBPixelFormat>>setColourMap: for an explanation of the rationale behind this."	self		setColourMap: serverFormat;		"pixel format conversion (if needed)"		setOrderMap: serverFormat		"byte order reversal (if needed)"! !!RFBPixelFormat methodsFor: 'private' stamp: 'ikp 2/19/2007 21:07'!setOrderMap: serverFormat	"Set the ColorMap used to convert local byte order to viewer byte order.  This map is effective only when sending an entire Bitmap to the remote viewer.  (Individual pixel values are always sent in big-endian order; see RFBStream{16,32}>>nextPutPixel:.)"	orderMap := bigEndian == SmalltalkImage current isBigEndian	"no map if byte order is commensurate"		ifFalse:			[bitsPerPixel == 16				ifTrue: [ColorMap							masks: #(16r00FF 16rFF00 0 0)							shifts: #(8 -8 0 0)]				ifFalse: [bitsPerPixel == 32					ifTrue: [ColorMap								masks: #(16r000000FF 16r0000FF00 16r00FF0000 16rFF000000)								shifts: #(24 8 -8 -24)]]]! !!RFBPixelFormat methodsFor: 'private' stamp: 'ikp 3/23/2004 05:27'!setReverseColourMap: serverFormat	"Set the ColorMap used to convert viewer pixels to screen pixels in local byte order."	| form |	form := Form extent: 0@0 depth: bitsPerPixel.	(trueColour and: [(self rgbMasks = form rgbaBitMasks) not])		ifTrue:			[colourMap := bitsPerPixel == 8				ifTrue: [self bgr233ColourMap]				ifFalse: [self colormapFromARGB mappingTo: form colormapFromARGB]]! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/21/2004 07:58'!setReverseMaps	"The receiver describes a remote pixel format.  Initialise the cached ColorMaps used for remote->local pixel format conversion."	^self setReverseMaps: self species serverFormat! !!RFBPixelFormat methodsFor: 'pixel formats' stamp: 'ikp 3/21/2004 07:39'!setReverseMaps: serverFormat	"Set the receiver's ColorMaps that describe the mapping from viewer pixels to screen pixels."	self		setReverseColourMap: serverFormat;		"pixel format conversion (if needed)"		setOrderMap: serverFormat				"byte order reversal (if needed)"! !!RFBPixelFormat methodsFor: 'encoding' stamp: 'ikp 3/15/2004 18:11'!swapBytesIfNeeded: aForm	"Swap the byte order of all pixels within aForm, if the pixel format described by the receiver requires it."	orderMap isNil ifTrue: [^aForm].	^aForm applyColourMap: orderMap! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/4/2011 13:58'!aboutString	"Answer the contents of the about window."	^'		*** RFBServer: a RFB/VNC server written entirely in Squeak. ***  (If you don''t know what RFB and VNC are, go look at "http://www.realvnc.com"  and/or "http://www.tightvnc.com".)	Copyright (C) 2004--2011 by Ian Piumarta	All Rights Reserved.	Permission is hereby granted, free of charge, to any person obtaining a	copy of this software and associated documentation files (the "Software"),	to deal in the Software without restriction, including without limitation	the rights to use, copy, modify, merge, publish, distribute, and/or sell	copies of the Software, and to permit persons to whom the Software is	furnished to do so, provided that the above copyright notice(s) and this	permission notice appear in all copies of the Software and that both the	above copyright notice(s) and this permission notice appear in supporting	documentation.	THE SOFTWARE IS PROVIDED "AS IS".  USE ENTIRELY AT YOUR OWN RISK.  Enjoy!!'! !!RFBServer class methodsFor: 'authentication' stamp: 'klib 2/27/2012 14:52'!askForPassword: type	"Ask for a password.  If the user refuses to supply one, try insisting.  Answer the password (if one is supplied) or an empty String (if the user wants no password) or nil (if the user gives up)."	"RFBServer askForPassword: 'testing'"	| pass |	pass := (UIManager default  requestPassword: 'Password for ' , type , ' VNC connections?').	pass isEmpty		ifTrue: [(self confirm: 'Do you really want to allow anyone to connect to this image?')					ifTrue: [^pass]					ifFalse:						[self inform: 'Password unchanged.'.						 ^nil]].	^pass! !!RFBServer class methodsFor: 'private' stamp: 'ul 8/16/2012 16:09'!clipboardContentChanged: newContent source: source	"Update the local clipboard of all clients when the server's clipboard changes."		source == #rfbClientCutText ifTrue: [ ^self ]. "Avoid updating the local clipboard of all clients when a client updates its own local clipboard."	Server ifNotNil: [ Server setClipboardText: newContent ]! !!RFBServer class methodsFor: 'private' stamp: 'ul 8/13/2012 18:05'!closeMenuMorphs	RFBMenuMorph allInstancesDo: [ :each | each delete ]! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 00:56'!debugging	"Answer whether the RFBServer is currently in 'debugging' or 'production' mode."	^EnableDebugging! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 00:56'!debugging: debugFlag	"Set the debugging/production mode flag."	EnableDebugging := debugFlag! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/20/2004 07:47'!displayNumberFromPortNumber: portNumber	"Answer the RFB display number corresponding to the given IP portNumber."	^portNumber - RFBSocket serverPortOffset! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 09:39'!doCloseAllConnections	"Close all active connections.  (This message is sent from the server menu.)"	Server isNil ifTrue: [^self].	Server sessions isEmpty ifTrue: [^self].	(self confirm: 'Really close the ', Server sessions size printString, ' active connection(s)?')		ifTrue: [Server terminateSessions]! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/20/2004 07:49'!doReverseConnection	"Open a reverse connection to a remote, listening viewer."	| clientSocket |	Server isNil ifTrue: [^self inform: 'The RFBServer is not running.'].	(clientSocket := RFBSocket connectedToViewer) isNil ifTrue: [^self].	self log: 'reverse connection to ', clientSocket peerName.	EnableLogging ifTrue: [Transcript endEntry].	(RFBSession withServer: Server socket: clientSocket reverse: true) start! !!RFBServer class methodsFor: 'user interface' stamp: 'klib 2/27/2012 14:53'!doStartServer	"Start the server."	| display |	display := UIManager default request: 'Display number?' initialAnswer: '0'.	display isEmpty ifTrue: [^self].	display := display asInteger.	display isNil ifTrue: [^self].	^self start: display! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/18/2004 23:21'!doStartStop	"Start or stop the server."	^Server isNil ifTrue: [self doStartServer] ifFalse: [self doStopServer]! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 00:15'!doStopServer	"Stop the server."	Server sessions isEmpty		ifFalse:			[(self confirm: 'Really stop the server?  (All connections will be closed.)')				ifFalse: [^self]].	^self stop! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 04:33'!doViewConnections	"Open a window containing a summary of the currently active connections.  (This message is sent from the server menu.)"	| details |	Server isNil ifTrue: [^self].	Server sessions isEmpty ifTrue: [^self inform: 'There are no connections at this time.'].	details := String streamContents: [:stream |		Server sessions do: [:session |			stream nextPutAll: session description; cr]].	(StringHolder new contents: details)		openLabel: 'Current RFB/VNC connections' ! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 06:06'!doViewLog	"Open a window containing the current contents of the server log."	(StringHolder new contents: self log)		openLabel: 'Current RFB/VNC server log' ! !!RFBServer class methodsFor: 'authentication' stamp: 'ikp 3/19/2004 03:58'!encryptPassword: newPassword	"Encrypt the newPassword."	"RFBServer encryptPassword: Time millisecondClockValue printString"	| block |	newPassword isNil ifTrue: [^nil].	newPassword isString ifFalse: [^self error: 'password must be a String'].	newPassword isEmpty ifTrue: [^nil].	block := ByteArray new: 8.	1 to: (newPassword size min: 8) do: [:i | block at: i put: (newPassword at: i) asciiValue].	newPassword atAllPut: (Character value: 0).	RFB3DES new		encryptionKey: FixedKey;		des: block to: block.	^block! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 08:34'!helpString	"Answer the contents of the help window."	^'*** Configuration and controlTo open the configuration/control menu, evaluate the following expression:	RFBServer openLimited configuration and control is possible via messages to RFBServer.  See the RFBServer class comment (included below) for more information.*** Menu items** Title barThe title includes an indication of the server status.  If it shows "(stopped)" then the server isn''t running.  If it shows ":<n>" for some integer <n> then the server is running and is accepting connections for display number <n>.** start/stop server...This item toggles the server between running and stopped.  If the server is running and there are no connections, it will be labeled simply "stop server".  If there are active connections it will labeled "stop server..." to indicate a subsequent confirmation panel that gives you a chance to change your mind.** Sub menu: passwordsEverything to do with configuring server passwords.* Set full password...Opens a prompter in which you can enter a password for "full" (interactive) connections.  If you leave the password blank then you will be prompted whether you really mean to let absolutely anyone connect.  If you say "yes" then the password will be cleared.  If you say no then the password will remain unchanged.* Set view password...As above but concerns the password that is used for view-only (non-interactive) connections.  The (remote) viewer is asked only once for a password, and the (local) server tries to authenticate it twice: once for a full connection and if that fails once again for a view-only connection.* allow empty passwordsWhen selected, this option will permit connections even when there is no password set.  Be very careful if you enable this: if you have no interactive password then this option will allow anyone on the planet (who is able to reach your machine via the Internet) to connect to your running image and interact with it.  (Note that this includes opening a fie list and/or a "command shell" to do arbitrary damage to your machine.  You Have Been Warned.)** Sub menu: connectionsEverything to do with connection management.* allow local connectionsIf enabled then connections coming from the loopback address (or the IP address of the local interface) will be allowed.* allow remote connectionsIf enabled then connections coming from non-local addresses will be allowed.  If both this and "allow local connections" are disabled then (obviously) nobody will be able to connect.* allow interactive connectionsIf this is set then connections can be fully-interactive (mouse and keyboard events will be processed).  If this is not set then incoming mouse and keyboard events will be ignored (regardless of whether the remote user managed to guess the "full connection" password or not).* view current connections...Pops open a window containing a list of the currently-active connections.* close all connections...Closes all active connections without restarting the server.  You will be required to confirm that you really mean to do this.* open reverse connection...Opens an outgoing connection from the server to some remote viewer.  The viewer must have been started in "listen" mode (it sits there waiting for a server to contact it, then pops open its viewer window).  You will be asked for the IP address or host name of the machine on which the listening viewer is running.** Sub menu: sharingEverything to do with managing multiple connections.  The following three options are mutually-exclusive (and they will behave like "radio buttons").* automatically share connectionsIf this is set then incoming connections that are not explicitly "shared" (willing to coexist with other remote viewers) will be implicitly shared.  There will be no restriction on how many concurrent connections can be active at any one time.* disconnect existing clientsAn incoming connection that is not explicitly "shared" will cause all existing connections to be closed.  This guarantees exclusive access for the most recent non-shared connection.* refuse concurrent connectionsAny incoming connection will be refused systematically if there is already an active connection.  This guarantees exclusive access on a first-come first-served basis.** Sub menu: performanceEverything to do with stuff you can tweak to trade CPU time and memory against bandwidth and speed.* allow ZRLE encodingZRLE encoding is the most compact of all encodings defined by the RFB protocol.  It constructs a colour palette (so that pixels can be represented by 1, 2, 4 or 8 bits rather than up to 32 bits of true-colour), and then run-length encodes the update region using the palette.  It then "zip" compresses the result before sending it to the remote viewer.  In other words, it is very CPU-intensive.  This option gives you a chance to refuse to supply ZRLE updates to a remote viewer, should you value your CPU time more highly than their response time.* conserve memoryWhen sending an update to a remote viewer, the server generally captures the entire update region from the screen into a single Form.  This Form might be huge (e.g., during the initial screen update or when you''re dragging a window around).  If you select this option then updates will always be chopped up so that they do not exceed 16384 pixels (64 Kbytes at depth 32).  This will mean slower updates, less efficient encoding, and slightly more data being sent down the wire.  On the other hand, it spares you from potential transient peak memory usage measured in megabytes for a very large screen update.* enable damage filteringMorphic is really bad at repainting only damaged areas.  The World damage recorder (usually) manages to eliminate duplicated damage rectangles, but it makes no attempt to verify that the damage is real.  Selecting this option enables an algorithm in the server that verifies the validity of all damage reported by Morphic.  It does this by retaining a copy of the entire Display and then comparing the ostensibly-damaged regions with that copy.  Only areas in which differences are found are retained for subsequent screen update messages.  This is very effective, but will cost you a verbatim copy of your Display object (which might be an additional 7Mbytes of memory overhead, if your screen is 1600x1200x32).* filter damage for raw encodingRaw encoding (in which updates are just rectangles of raw pixels) are generally only used when the viewer and server are running on the same machine.  In such cases, the damage filtering described above may well be pointless since the time taken to just send the (undamaged) pixels down the wire might be less than the time required to verify the damage.  This option lets you choose whether to filter the damage (option set) or just send everything that Morphic reports as damage (option not set).  Note that this only applies when using raw encoding and with the previous option (enable damage filtering) turned on.** Sub menu: debuggingEverything to keep the determined hacker happy.* enable debuggingError conditions are normally dealt with silently: the error is squashed, the offending connection closed, and the associated server processes terminated.  This is what happens when this option is not enabled.  Conversely, if this option is set, then any error condition (including a broken or closed connection) will cause a Debugger window to pop open.  This is very useful if you think you''ve found a bug in the RFBServer code and you want to track it down.* enable loggingSetting this option will cause connection and disconnection information to be written to a server log (and probably to the Transcript too, if you have one of those open).* enable verbose loggingSetting this increases the level of detail in the information written to the server log.  (For example, it will include most of the interesting information exchanged during connection handshake including preferred encodings, server and client pixel formats, etc.)  This option has no effect unless the previous option (enable logging) is set.* monitor memory useIf this is selected then the server will measure (approximately) the amount of CPU time consumed and transient heap memory allocated when sending screen updates.  The information is displayed along with each connection in the "view current connections..." window described above.  This option is only intended to be used to adjust the "performance" options to a confortable level.  Leaving it turned on is not recommended.  (For example: when this option is set, for every screen update message sent to the viewer, the server performs a garbage collection and then disables any allocation count-based triggering of collections for the duration of the update.  You probably don''t want to run your image for long with this kind of abuse happening.)** help...You already know about this one (otherwise you wouldn''t be reading this text).** about...Displays a cheesy little "about" window.  It doesn''t contain anything of interest, except maybe for an email address where you can report bugs and/or confusion.*** The RFBServer class commentAs promised at the beginning off this tirade, below is a copy of the class comment for RFBServer.  It includes some performance/aesthetics considerations as well as information about how to control the server by sending it messages.  Here it comes, verbatim:' , RFBServer comment! !!RFBServer class methodsFor: 'class initialisation' stamp: 'ul 7/3/2011 15:29'!initialisePreferences	"RFBServer initialisePreferences"	AllowEmptyPasswords := false.	AllowInputEvents := true.	AllowLocalConnections := true.	AllowRemoteConnections := false.	AllowZRLE := true.	ConnectionPriority := #shared.	EnableDebugging := false.	EnableLogging := false.	EnableMemoryLog := false.	self shouldConserveMemory		ifTrue:			[ConserveMemory := true.			 EnableDamageFilter := false.			 EnableRawFilter := false]		ifFalse:			[ConserveMemory := false.			 EnableDamageFilter := true.			 EnableRawFilter := true].! !!RFBServer class methodsFor: 'class initialisation' stamp: 'ul 8/13/2012 18:23'!initialize	"RFBServer initialize"	FixedKey := #[23 82 107 6 35 78 88 7].	LoopbackAddress := #[127 0 0 1].	VNCPasswords := Array new: 2.	self		initialisePreferences;		initializeServerLog;		registerInOpenMenu;		registerForClipboardChanges! !!RFBServer class methodsFor: 'private' stamp: 'ul 8/13/2012 18:22'!initializeServerLog	ServerLog := (String new: 32) writeStream! !!RFBServer class methodsFor: 'private' stamp: 'ikp 2/27/2004 17:37'!log	"RFBServer log"	^ServerLog contents! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 02:52'!log: messageString	"RFBServer log: 'hello, world'"	EnableLogging ifTrue: [Transcript nextPut: Character cr; nextPutAll: 'RFB: ' , messageString].	^ServerLog nextPutAll: messageString; cr! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 02:52'!logging	"Answer whether server activity is logged."	^EnableLogging! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/19/2004 02:52'!logging: logFlag	"Set the flag that controls whether server activity is logged."	EnableLogging := logFlag! !!RFBServer class methodsFor: 'user interface' stamp: 'ul 7/9/2009 15:09'!menu	"RFBServer open"	^(RFBMenuMorph new)		defaultTarget: self;		addTitle: '' updatingSelector: #menuTitle updateTarget: self;		add: #startStopLabel action: #doStartStop help: 'Start or stop the server.';		addLine;		add: 'passwords' subMenu: ((RFBMenuMorph new)			defaultTarget: self;			add: 'set interactive password...' action: #setFullPassword				help: 'Set the password required for full (interactive) connections.';			add: 'set view-only password...' action: #setViewPassword				help: 'Set the password required for view-only (non-interactive) connections.';			addLine;			add: 'allow empty passwords'				get: [AllowEmptyPasswords] set: [AllowEmptyPasswords := AllowEmptyPasswords not]				help: 'Allow connections even when no server passwords are set.';			yourself);		add: 'connections' subMenu: ((RFBMenuMorph new)			defaultTarget: self;			add: 'allow local connections'				get: [AllowLocalConnections] set: [AllowLocalConnections := AllowLocalConnections not]				help: 'Allow connections from local clients (the loopback address).';			add: 'allow remote connections'				get: [AllowRemoteConnections] set: [AllowRemoteConnections := AllowRemoteConnections not]				help: 'Allow connections from remote clients (non-loopback addresses).';			add: 'allow interactive connections'				get: [AllowInputEvents] set: [AllowInputEvents := AllowInputEvents not]				help: 'Allow remote viewers to send mouse and keyboard events.';			addLine;			add: 'view current connections...' action: #doViewConnections				help: 'View a list of the current connections.';			add: 'close all connections...' action: #doCloseAllConnections				help: 'Close all open connections (without restarting the server).';			addLine;			add: 'open reverse connection...' action: #doReverseConnection				help: 'Open a connection from this server to a listening viewer.  (The viewer needs to have been started in "listen" mode and you need to know its host IP address or name.)';			yourself);		add: 'sharing' subMenu: ((RFBMenuMorph new)			defaultTarget: self;			add: 'automatically share connections'				get: [ConnectionPriority == #shared] set: [ConnectionPriority := #shared]				help: 'New connections are automatically shared with existing connections.';			add: 'disconnect exising clients'				get: [ConnectionPriority == #disconnect] set: [ConnectionPriority := #disconnect]				help: 'Disconnect all existing connections whenever a new connection is accepted.';			add: 'refuse concurrent connections'				get: [ConnectionPriority == #refuse] set: [ConnectionPriority := #refuse]				help: 'Refuse new connections if a client is already connected.';			yourself);		add: 'performance' subMenu: ((RFBMenuMorph new)			defaultTarget: self;			add: 'allow ZRLE encoding'				get: [AllowZRLE] set: [AllowZRLE := AllowZRLE not]				help: 'Allow clients to use ZRLE encoding (very CPU instensive on the server).';			add: 'conserve memory'				get: [ConserveMemory] set: [ConserveMemory := ConserveMemory not]				help: 'Conserve memory by splitting large updates into many smaller ones.';			add: 'enable damage filtering'				get: [EnableDamageFilter] set: [EnableDamageFilter := EnableDamageFilter not]				help: 'Try hard to avoid updating undamaged screen areas.  This consumes vast quantities of memory.';			add: 'filter damage for raw encoding'				get: [EnableRawFilter] set: [EnableRawFilter := EnableRawFilter not]				help: 'Use damage filering (if enabled) even with raw encoding.';			yourself);		add: 'debugging' subMenu: ((RFBMenuMorph new)			defaultTarget: self;			add: 'enable debugging' get: [EnableDebugging] set: [EnableDebugging := EnableDebugging not]				help: 'Open a Debugger if an error occurs.  (If this optionis not set then errors are silently ignoredand the offending connection is closed.)';			add: 'enable logging' get: [EnableLogging] set: [self logging: EnableLogging not]				help: 'Retain a log of client connections.  (Reset each time the server is started.)';			add: 'enable verbose logging' get: [RFBSession logging] set: [RFBSession logging: RFBSession logging not]				help: 'Write detailed information to the server log.';			add: 'monitor memory use' get: [EnableMemoryLog] set: [EnableMemoryLog := EnableMemoryLog not]				help: 'Monitor memory usage.  To see the results, choose "view current connections".  (Data reset each time the connections are viewed.)';			addLine;			add: 'view server log...' action: #doViewLog			help: 'Open a window containing the current contents of the server log.';			yourself);		addLine;		add: 'help...' action: #showHelpWindow help: 'Open a window describing this menu in detail.';		add: 'about...' action: #showAboutWindow help: 'Open the Cheezoid About Window.';		addStayUpItem;		stayUp: false! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 09:46'!menuTitle	"Answer a suitable title for the server control panel, depending on whether a server is running at this time."	^'RFBServer ', (Server isNil						ifTrue: ['(stopped)']						ifFalse: [':', Server displayNumber printString])! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 04:54'!open	"RFBServer open"	self menu openInHand! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/20/2004 07:47'!portNumberFromDisplayNumber: displayNumber	"Answer the IP port number associated with the given RFB displayNumber."	^RFBSocket serverPortOffset + displayNumber! !!RFBServer class methodsFor: 'private' stamp: 'ul 8/16/2012 15:26'!registerForClipboardChanges	Clipboard default		when: #contentChanged		send: #clipboardContentChanged:source:		to: self! !!RFBServer class methodsFor: 'private' stamp: 'ar 11/10/2004 16:56'!registerInOpenMenu	"Add RFBServer to the World open menu."	"RFBServer registerInOpenMenu"	Smalltalk at: #TheWorldMenu ifPresent:		[:theWorldMenu |  theWorldMenu registerOpenCommand:			{ 'RFB/VNC Server' . { RFBServer . #open } .			  'Configure access to this Squeak desktop from remote VNC viewers.' }]! !!RFBServer class methodsFor: 'controlling' stamp: 'ul 8/13/2012 18:22'!restart: displayNumber	"RFBServer start"	Server isNil		ifTrue:			[self initializeServerLog.			 Server := self new start: (self portNumberFromDisplayNumber: displayNumber).			 Smalltalk				addToStartUpList: self;				addToShutDownList: self]		ifFalse:			[self log: 'server already running?'].	^Server! !!RFBServer class methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:32'!server	"Answer the currently active RFBServer or nil."	^Server! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/8/2004 04:17'!sessions	"Answer a collection of the currently active sessions."	^Server sessions! !!RFBServer class methodsFor: 'authentication' stamp: 'ikp 3/19/2004 01:04'!setFullPassword	"RFBServer setFullPassword."	| password |	password := self askForPassword: 'interactive'.	password isNil ifFalse: [VNCPasswords at: 1 put: (self encryptPassword: password)]! !!RFBServer class methodsFor: 'authentication' stamp: 'ikp 3/19/2004 01:04'!setViewPassword	"RFBServer setViewPassword."	| password |	password := self askForPassword: 'view-only'.	password isNil ifFalse: [VNCPasswords at: 2 put: (self encryptPassword: password)]! !!RFBServer class methodsFor: 'private' stamp: 'ul 7/3/2011 15:28'!shouldConserveMemory	"Answer whether the server should try to conserve memory at all costs."	^false"	^self confirm:'Would you like to conserve memory at all costs?(Answer ''yes'' and the server should never use more than a few hundred Kbytes.If you answer ''no'' then transient memory usage might peak at several Mbytes.If in doubt, answer ''yes'' and then review the performance settings in the serverconfiguration menu to tweak things until remote response is acceptable.)'"! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 07:27'!showAboutWindow	"Display a cheesy about window."	(StringHolder new contents: self aboutString)		openLabel: 'About the RFB/VNC Server'! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/19/2004 07:27'!showHelpWindow	"Display a help window."	(StringHolder new contents: self helpString)		openLabel: 'Help for the RFB/VNC Server'! !!RFBServer class methodsFor: 'snapshot' stamp: 'ikp 3/19/2004 01:02'!shutDown: quitting	"We're about to snapshot and quit: invite the user to shut down the server if running."	Server notNil ifTrue:		[(self confirm:'The RFBServer is running.  Would you like to shut it down now?(WARNING:  If you answer "no" then the server will still beaccepting connections every time the saved image is restarted.)')			ifTrue: [self stop]]! !!RFBServer class methodsFor: 'controlling' stamp: 'ikp 2/23/2004 18:38'!start	"RFBServer start"	^self start: 0! !!RFBServer class methodsFor: 'controlling' stamp: 'ikp 3/19/2004 01:00'!start: displayNumber	"RFBServer start"	^self restart: displayNumber! !!RFBServer class methodsFor: 'user interface' stamp: 'ikp 3/18/2004 23:18'!startStopLabel	"RFBServer open"	^Server isNil		ifTrue: ['start server...']		ifFalse: ['stop server' , (Server sessions isEmpty ifTrue: [''] ifFalse: ['...'])]! !!RFBServer class methodsFor: 'snapshot' stamp: 'ikp 3/7/2004 16:43'!startUp: resuming	"We're coming back from snapshot and quit.  Restart the server if it was running."	| port |	resuming		ifTrue:			[port := Server port.			 self stop; restart: (self displayNumberFromPortNumber: port)]! !!RFBServer class methodsFor: 'controlling' stamp: 'ikp 3/18/2004 05:00'!stop	"RFBServer stop"	Server isNil		ifTrue:			[self log: 'server not running?']		ifFalse:			[Server := Server stop.			 Smalltalk				removeFromStartUpList: self;				removeFromShutDownList: self].	^nil! !!RFBServer class methodsFor: 'controlling' stamp: 'ikp 2/23/2004 18:19'!terminateSessions	"RFBServer terminateSessions"	Server isNil		ifTrue: [self log: 'server not running?']		ifFalse: [Server terminateSessions].! !!RFBServer class methodsFor: 'class initialisation' stamp: 'ul 8/13/2012 18:05'!unload	"RFBServer is being removed from the image."	self		stop;		closeMenuMorphs;		unregisterFromClipboardChanges;		unregisterInOpenMenu! !!RFBServer class methodsFor: 'private' stamp: 'ul 8/13/2012 03:09'!unregisterFromClipboardChanges	Clipboard default removeActionsWithReceiver: self! !!RFBServer class methodsFor: 'private' stamp: 'ikp 3/24/2004 05:50'!unregisterInOpenMenu	"Remove RFBServer from the World open menu."	"RFBServer unregisterInOpenMenu"	Smalltalk at: #TheWorldMenu ifPresent:		[:theWorldMenu |		 theWorldMenu unregisterOpenCommandWithReceiver: RFBServer].! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/8/2004 04:23'!addSession: rfbSession	"Add rfbSession to the list of active sessions."	sessionsSema critical: [sessions add: rfbSession]! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/19/2004 03:53'!allowConnection: clientSocket	"Answer whether the connection from clientSocket should be allowed."	| peer |	(sessions notEmpty and: [ConnectionPriority == #refuse])		ifTrue: [^false].	AllowLocalConnections & AllowRemoteConnections		ifTrue: [^true].	peer := clientSocket remoteAddress.	(peer = LoopbackAddress or: [peer = NetNameResolver localHostAddress])		ifTrue: [^AllowLocalConnections]		ifFalse: [^AllowRemoteConnections]! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 01:18'!allowInteractive	"Answer whether the server allows clients to send mouse and keyboard events."	^AllowInputEvents! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 01:35'!allowZRLE	"Answer whether the server allows clients to use the ZRLE encoding."	^AllowZRLE! !!RFBServer methodsFor: 'authenticating' stamp: 'ikp 3/24/2004 01:41'!authenticateChallenge: authChallenge response: authResponse	"Authenticate the response to the given challenge.  Answer true if authentication succeeds for an interactive connection, false if it succeeds for a view-only connection, or nil if the authentication fails for any reason."	| password encryptedChallenge |	self hasPassword ifFalse: [^nil].		"We should not be here."	1 to: 2 do: [:type |		(VNCPasswords at: type) isNil			ifFalse:				[password := ByteArray new: 8.				 encryptedChallenge := ByteArray new: 16.				 RFB3DES new					decryptionKey: FixedKey;					des: (VNCPasswords at: type) to: password;					encryptionKey: password;					des: authChallenge to: encryptedChallenge.				 password atAllPut: 0.				 encryptedChallenge = authResponse ifTrue: [^type == 1]]].	^nil! !!RFBServer methodsFor: 'server events' stamp: 'ikp 3/8/2004 04:19'!beep	"The Display just beeped.  Tell all sessions to ring their viewer's bell."	sessionsSema critical: [sessions do: [:session | session beep]]! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:46'!conserveMemory	"Answer whether the session should try to conserve memory by splitting large screen updates into a series of smaller upodates.  Note that this is a space/speed tradeoff: when not conserving memory, large updates might require (very briefly) temporary objects toalling three times the size of the Display screen."	^ConserveMemory! !!RFBServer methodsFor: 'server events' stamp: 'ikp 3/8/2004 04:23'!currentCursor: newCursor	"Squeak just changed the cursor shape.  Inform the sessions."	sessionsSema critical: [sessions do: [:session | session currentCursor: newCursor]]! !!RFBServer methodsFor: 'private' stamp: 'ikp 3/19/2004 00:56'!debugging	"Answer whether the RFBServer is currently in 'debug' or 'production' mode."	^EnableDebugging! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/18/2004 04:56'!displayNumber	"Answer the display number on which this server is listening."	^RFBServer displayNumberFromPortNumber: port! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 04:43'!enableDamageFilter	"Answer whether the session should use a damage filter to eliminate bogus screen damage.  Note that this is a space/speed tradeoff: the damage filter hangs onto a verbatim copy of the entire Display screen."	^EnableDamageFilter! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 06:23'!enableMemoryLog	"Answer whether the session should monitor how much memory it is using when sending screen updates."	^EnableMemoryLog! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/19/2004 06:58'!enableRawFilter	"Answer whether the session should use a damage filter to eliminate bogus screen damage even when using raw encoding (and presumably running on the local host)."	^EnableRawFilter! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/19/2004 03:21'!enforcePriorityFor: rfbSession shared: sharedFlag	"The rfbSession has just been authenticated.  According to the connection priority in effect either disconnect existing clients or do nothing."	(sharedFlag or: [ConnectionPriority == #shared]) ifTrue: [^self].	(sessions reject: [:session | session == rfbSession]) do: [:session | session stop]! !!RFBServer methodsFor: 'private' stamp: 'ikp 3/8/2004 04:26'!fixedKey	"Return the fixed key used to encode the session password before storing it."	^FixedKey! !!RFBServer methodsFor: 'authenticating' stamp: 'ikp 3/19/2004 00:55'!hasPassword	"Answer whether the server has one or both passwords set."	^AllowEmptyPasswords not or: [(VNCPasswords at: 1) notNil or: [(VNCPasswords at: 2) notNil]]! !!RFBServer methodsFor: 'initialise-release' stamp: 'ul 7/8/2011 22:37'!initialize	"Set the initial state of the server."	super initialize.	sessions := IdentitySet new.	sessionsSema := Semaphore forMutualExclusion.	localHostName := NetNameResolver localHostName.	self installDisplay.	self log: 'initialised'! !!RFBServer methodsFor: 'private' stamp: 'kb 5/25/2010 13:18'!installDisplay	"The RFBServer has just been started.  Install replacement, RFB-aware equivalents of the Display (for screen updates) and Sensor (for keyboard, mouse and cursor)."	((Display isMemberOf: RFBDisplayScreen) and: [Sensor isMemberOf: RFBEventSensor])		ifTrue:			[Display rfbServer: self.			 ^Sensor rfbServer: self].	"((Display isMemberOf: DisplayScreen) and: [Sensor isMemberOf: EventSensor])		ifFalse: [^self error: 'Cowardly refusing to start RFB server over '								, Display printString , ' '								, Sensor printString]."	(Display := RFBDisplayScreen new copyFrom: Display) rfbServer: self; beDisplay.	Sensor become: ((RFBEventSensor new copyFrom: Sensor) rfbServer: self).	self log: 'RFBDisplayScreen, RFBEventSensor installed'! !!RFBServer methodsFor: 'server events' stamp: 'ikp 3/8/2004 04:21'!invalidate: damagedRectangle	"The Display just changed in the given damageRectangle.  Inform each session."	sessionsSema critical: [sessions do: [:session | session invalidate: damagedRectangle]]! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/15/2004 18:12'!localHostName	"Answer the name of the host on which the server is running."	^localHostName! !!RFBServer methodsFor: 'logging' stamp: 'ar 11/10/2004 14:07'!log: messageString	"Write a messageString on the server log."	^RFBServer log: '[', thisContext sender printString,'] ', messageString! !!RFBServer methodsFor: 'server events' stamp: 'ikp 3/8/2004 04:21'!mousePosition: mousePoint	"The pointer just moved.  Inform each session."	sessionsSema critical: [sessions do: [:session | session mousePosition: mousePoint]]! !!RFBServer methodsFor: 'server events' stamp: 'ikp 3/8/2004 04:25'!newDepth: depth	"Squeak just changed the Display depth.  Warn the sessions."	sessionsSema critical: [sessions do: [:session | session newDepth: depth]]! !!RFBServer methodsFor: 'accessing' stamp: 'ikp 3/8/2004 04:22'!port	"Answer the port on which this server is listening."	^port! !!RFBServer methodsFor: 'initialise-release' stamp: 'ikp 3/8/2004 04:25'!release	"Release resources associated with the server.  This method is mainly to ensure that the runLoop process doesn't try to touch any of the following again..."	self removeDisplay.	sessions := nil.	sessionsSema := nil.	process := nil.	self log: 'released'! !!RFBServer methodsFor: 'private' stamp: 'ikp 3/8/2004 04:22'!removeDisplay	"The RFB server is shutting down.  Remove our fake Display and Sensor, replacing them with the originals."	((Display isMemberOf: RFBDisplayScreen) and: [Sensor isMemberOf: RFBEventSensor])		ifFalse: [^self].	(Display := DisplayScreen new copyFrom: Display) beDisplay.	Sensor become: (Sensor copyTo: EventSensor new).	self log: 'RFBDisplayScreen. RFBEventSensor removed'! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/19/2004 02:53'!removeSession: rfbSession	"Remove a rfbSession from the list of active sessions."	sessionsSema critical: [sessions remove: rfbSession].	EnableLogging ifTrue: [Transcript endEntry].! !!RFBServer methodsFor: 'server process' stamp: 'ikp 3/8/2004 04:19'!runLoop	"Run the server's connection accept loop."	| newConnection |	self log: 'running'.	[socket isValid]		whileTrue:			[[newConnection := socket waitForAcceptFor: 10]				on: ConnectionTimedOut				do: [:ex | newConnection := nil].			 newConnection isNil				ifFalse:					[self runSession: newConnection]]! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/22/2004 05:21'!runSession: clientSocket	"Start a new session for the viewer connected on clientSocket."	| peer |	peer := clientSocket peerName.	peer isNil ifTrue: [peer := NetNameResolver stringFromAddress: clientSocket remoteAddress].	self log: 'connection from ', peer.	EnableLogging ifTrue: [Transcript endEntry].	(self allowConnection: clientSocket)		ifTrue:			[(RFBSession withServer: self socket: clientSocket reverse: false) start]		ifFalse:			[self log: 'connection refused because of server policy'.			 clientSocket closeAndDestroy]! !!RFBServer methodsFor: 'scheduling priorities' stamp: 'ikp 3/19/2004 08:55'!serverPriority	"Answer the scheduling priority at which the RFB server should run."	^Processor lowIOPriority"		Processor userSchedulingPriority		+ Processor userInterruptPriority		// 2"! !!RFBServer methodsFor: 'scheduling priorities' stamp: 'ikp 3/19/2004 08:54'!sessionPriority	"Answer the priotity at which each viewer session should run."	^Processor lowIOPriority"		Processor userSchedulingPriority		+ Processor userInterruptPriority		// 2"! !!RFBServer methodsFor: 'private' stamp: 'ikp 3/8/2004 04:25'!sessions	"Answer an Array of all the active sessions."	^sessions asArray! !!RFBServer methodsFor: 'server events' stamp: 'kb 10/15/2008 16:18'!setClipboardText: aStringOrText	"Update the clients clipboad text"	sessionsSema critical: [		sessions do: [ :session |			session sendClipboardText: aStringOrText ] ]! !!RFBServer methodsFor: 'controlling' stamp: 'ikp 3/8/2004 04:18'!start: portNumber	"Start an RFB server listening on the given portNumber."	self log: 'start'.	port := portNumber.	socket := RFBSocket newTCP.	socket listenOn: portNumber backlogSize: 5.	socket isValid ifFalse: [^self error: 'Could not create RFB server socket'].	process := [self runLoop] forkAt: self serverPriority.	self log: 'started'! !!RFBServer methodsFor: 'controlling' stamp: 'ikp 3/19/2004 02:27'!stop	"Stop the RFB server, closing all open viewer connections."	process terminate.	socket closeAndDestroy.	self log: 'stopped'.	self terminateSessions.	self release.	^nil! !!RFBServer methodsFor: 'sessions' stamp: 'ikp 3/19/2004 02:26'!terminateSessions	"Close down all active sessions."	| moribund |	[sessions isEmpty]		whileFalse:			[sessionsSema critical: [moribund := sessions copy].			 moribund do: [:session | session stop]].	sessions := IdentitySet new! !!RFBSession class methodsFor: 'class initialisation' stamp: 'ul 8/8/2012 02:42'!initialiseKeyCodes	"Initialise the tables used to map incoming key event codes to MacRoman characters, and the viewer's modifier key bits to local modifier bits."	"RFBSession initialize"	"The viewer sends 16-bit X11R6 keysyms.  There are hundreds of these.  The following are just the most common."	KeyCodesFF := Array new: 256.	#(	(16r08 8)	"bs"		(16r09 9)	"tab"		(16r0A 10)	"lf"		(16r0D 13)	"cr"		(16r1B 27)	"esc"		(16r50	1)	"home"		(16r51 28)	"left"		(16r52 30)	"up"		(16r53 29)	"right"		(16r54 31)	"down"		(16r55 11)	"prior"		(16r56 12)	"next"		(16r57 4)	"end"		(16rE1 -1)	"shift_l"		(16rE2 -1)	"shift_r"		(16rE3 -2)	"control_l"		(16rE4 -2)	"control_r"		(16rE5 -3)	"caps lock"		(16rE7 -4)	"meta_l"		(16rE8 -4)	"meta_r"		(16rE9 -5)	"alt_l"		(16rEA -5)	"alt_r"		(16rFF 127)	"del"	) do: [:posKey | KeyCodesFF at: posKey first put: posKey second].	"The following works well for Apple keyboards.  Anyone who doesn't have an Apple keyboard may well suffer from a classic case of garbage-in, garbage-out"	(ModifierMap := Array new: 5)		at: 1 put: ShiftKeyBit;		at: 2 put: CtrlKeyBit;		at: 3 put: 0;		at: 4 put: CommandKeyBit;		at: 5 put: CommandKeyBit 	"Should be OptionKeyBit, but Windoze is broken."! !!RFBSession class methodsFor: 'class initialisation' stamp: 'ikp 3/20/2004 08:44'!initialize	"RFBSession initialize"	ProtocolMajor := 3.	ProtocolMinor := 7.	ProtocolVersion := RFBMessage protocolVersionMajor: ProtocolMajor minor: ProtocolMinor.	Logging := false.	MessageTypes := #(		"0"	rfbSetPixelFormat		"1"	rfbFixColourMapEntries		"2"	rfbSetEncodings		"3"	rfbFramebufferUpdateRequest		"4"	rfbKeyEvent		"5"	rfbPointerEvent		"6"	rfbClientCutText).	(Encodings := Dictionary new)				"allow for gaps and LargeInts"		"rfb 3.3"		at: (RfbEncodingRaw		:= 0) put: #rfbEncodingRaw;		at: (RfbEncodingCopyRect	:= 1) put: #rfbEncodingCopyRect;		at: (RfbEncodingRRE			:= 2) put: #rfbEncodingRRE;		at: (RfbEncodingCoRRE		:= 4) put: #rfbEncodingCoRRE;		at: (RfbEncodingHextile		:= 5) put: #rfbEncodingHextile;		"tight vnc"		at: (RfbEncodingZlib			:= 6) put: #rfbEncodingZlib;		at: (RfbEncodingTight		:= 7) put: #rfbEncodingTight;		at: (RfbEncodingZlibHex		:= 8) put: #rfbEncodingZlibHex;		"protocol version 3.7"		at: (RfbEncodingZRLE		:= 16) put: #rfbEncodingZRLE;		"special encodings"		at: (RfbEncodingXCursor		:= 16rFFFFFF10) put: #rfbEncodingXCursor;		at: (RfbEncodingRichCursor	:= 16rFFFFFF11) put: #rfbEncodingRichCursor;		at: (RfbEncodingPointerPos	:= 16rFFFFFF18) put: #rfbEncodingPointerPos;		at: (RfbEncodingLastRect	:= 16rFFFFFF20) put: #rfbEncodingLastRect.	(SpecialEncodings := IdentityDictionary new)			"allow for gaps"		at: 0	put: #rfbEncodingCompressLevel:;		at: 14	put: #rfbEncodingQualityLevel:.	SecurityTypeNone := 1.	SecurityTypeVNC := 2.	UseLastRect := 16rFFFF.	self initialiseKeyCodes! !!RFBSession class methodsFor: 'logging' stamp: 'ikp 3/19/2004 02:50'!logging	"Answer whether informational messages are logged or not."	^Logging! !!RFBSession class methodsFor: 'logging' stamp: 'ikp 3/8/2004 03:15'!logging: loggingFlag	"Set the flag that controls whether informational messages are logged or not."	Logging := loggingFlag! !!RFBSession class methodsFor: 'instance creation' stamp: 'ikp 3/19/2004 09:23'!withServer: rfbServer socket: aSocket reverse: reverseFlag	"Answer a new RFBSession for the given rfbServer, communicating with the remote viewer over aSocket."	^self new initServer: rfbServer socket: aSocket reverse: reverseFlag! !!RFBSession methodsFor: 'private' stamp: 'ikp 3/8/2004 04:13'!abort	"Something very bad happened.  Give up immediately.  Serious developer lossage."	self log: 'aborted'.	socket closeAndDestroy.! !!RFBSession methodsFor: 'authenticating' stamp: 'ikp 3/19/2004 11:08'!authenticateClient	"Authenticate the client according to our stored password.  The details of the exchange depend on the minor version."	protocolMinor <= 5 ifTrue: [^self authenticateClient3v3].	protocolMinor <= 7 ifTrue: [^self authenticateClient3v7].	self log: 'minor protocol version ', protocolMinor printString, ' not supported'.	socket close! !!RFBSession methodsFor: 'authenticating' stamp: 'ikp 3/20/2004 09:32'!authenticateClient3v3	"Authenticate the client according to our stored password using version 3.3 protocol.  If it is nil, tell the client to continue without authentication.  Otherwise insist on VNC-style 3DES challenge-response authentication."	server hasPassword		ifTrue:			[authChallenge := self randomBytes.			 socket sendData: (RFBMessage newVncAuth: authChallenge).			 state := #rfbAuthentication]		ifFalse:			[socket sendData: (RFBMessage newNoAuth).			 state := #rfbInitialisation]! !!RFBSession methodsFor: 'authenticating' stamp: 'ikp 3/20/2004 09:07'!authenticateClient3v7	"Authenticate the client according to our stored password using version 3.7 protocol.  If it is nil, tell the client to continue without authentication.  Otherwise insist on VNC-style 3DES challenge-response authentication."	socket sendData:		((RFBMessage new: 2)			at: 1 put: 1;							"Number of security types."			at: 2 put: (server hasPassword						ifTrue: [SecurityTypeVNC]						ifFalse: [SecurityTypeNone]);			yourself).	state := #rfbSecurityType! !!RFBSession methodsFor: 'display events' stamp: 'ikp 3/8/2004 03:49'!beep	"The Display has just beeped.  Tell the viewer to beep too."	self sendBell! !!RFBSession methodsFor: 'private' stamp: 'ikp 3/19/2004 10:30'!beginUpdate	"Just about to send a screen update message.  If we're logging memory usage, note initial conditions."	server enableMemoryLog ifFalse: [^self].	allocationCount := Smalltalk vmParameterAt: 5.	bytesLeft := Smalltalk garbageCollectMost; primBytesLeft.	updateTime := Time millisecondClockValue.! !!RFBSession methodsFor: 'encoding-corre' stamp: 'ikp 3/8/2004 03:50'!countRectsEncodingCoRRE: region	"Answer the number of update rectangles that will be generated for the given region using compressed RRE encoding."	| nRects |	nRects := 0.	region do: [:rect |		nRects := nRects			+ (((rect width - 1) // correMaxWidth + 1)				* ((rect height - 1) // correMaxHeight + 1))].	^nRects! !!RFBSession methodsFor: 'encoding-hextile' stamp: 'ikp 3/8/2004 04:14'!countRectsEncodingHextile: region	"Answer the number of update rectangles that will be generated for an update of the given region using hextile encoding."	^region size! !!RFBSession methodsFor: 'encoding-rre' stamp: 'ikp 3/8/2004 03:21'!countRectsEncodingRRE: region	"Answer the number of update rectangles that will be generated for the given region using RRE encoding."	^region size! !!RFBSession methodsFor: 'encoding-raw' stamp: 'ikp 3/8/2004 03:17'!countRectsEncodingRaw: region	"Answer the number of update rectangles that will be generated for the given region using raw encoding."	^region size! !!RFBSession methodsFor: 'encoding-zrle' stamp: 'ikp 3/15/2004 19:27'!countRectsEncodingZRLE: region	"Answer the number of update rectangles that will be generated for an update of the given region using ZRLE encoding."	^region size! !!RFBSession methodsFor: 'display events' stamp: 'ikp 3/8/2004 04:07'!currentCursor: newCursor	"Squeak just changed the cursor shape.  Note the new shape and schedule an update message, if the viewer is at all interested in these things."	enableCursorShapeUpdates & (clientCursor ~~ newCursor)		ifTrue:			[currentCursor := newCursor.			 updateSemaphore signal]! !!RFBSession methodsFor: 'client state' stamp: 'ikp 3/19/2004 10:28'!decodeButtons: mask modified: modifierMask	"Convert the RFB button mask into a Squeak button mask taking the current modifierMask into account for yellow/blue button equivalence.  Answer an Integer with the low 3 bits containing the Squeak button mask and bits 4 and higher containing a copy of modifierMask with any equivalence modifier(s) removed."	"Note #1: button1 + Ctrl = yellow and button1 + Cmnd = blue, however, some idiot at some time swapped them in the EventSensorConstants.  Grrr."	"Note #2: this is, depressingly, identical to a bunch of code I've written in every single display driver that exists for Unix Squeak.  Why can't EventSensor figure all of this stuff out?  Ho hum."	"#(1 2 4 8) collect: [:b | RFBSession new decodeButtons: b]"	| buttons modified |	buttons := 0.	modified := modifierMask.	#((1 2) (2 0) (4 -2)) do:		[:maskShift |		 buttons := buttons bitOr: ((mask bitAnd: maskShift first) bitShift: maskShift second)].	buttons == RedButtonBit		ifTrue:			[(modified anyMask: CtrlKeyBit)				ifTrue:					[buttons := BlueButtonBit.								"YELLOW button"					 modified := modified bitXor: CtrlKeyBit]			 	ifFalse:					[(modified anyMask: CommandKeyBit)						ifTrue:							[buttons := YellowButtonBit.						"BLUE button"							 modified := modified bitXor: CommandKeyBit]]].	^buttons bitOr: (modified bitShift: 3)! !!RFBSession methodsFor: 'client state' stamp: 'ikp 3/8/2004 03:36'!decodeKey: keysym	"Answer the MacRoman character code corresponding to the given X11 keysym.  Note: we don't attempt any of the clever stuff suggested in the RFB protocol specification related to dealing with bizarre modifier key behaviour on some keyboards."	keysym < 128 ifTrue: [^keysym].	(keysym bitShift: -8) == 16rFF ifTrue: [^KeyCodesFF at: (keysym bitAnd: 16rFF)].	^nil! !!RFBSession methodsFor: 'printing' stamp: 'ul 8/16/2012 17:09'!description	"Answer a description of the receiver's session."	^String streamContents: [:stream |		stream			nextPutAll: (socket peerName ifNil: [				NetNameResolver stringFromAddress: socket remoteAddress ]);			nextPutAll: ' (';			nextPutAll: (NetNameResolver stringFromAddress: socket remoteAddress);			nextPutAll: '), ';			nextPutAll: (interactive ifTrue: ['interactive'] ifFalse: ['view only']);			nextPutAll: ', prefers ';			nextPutAll: preferredEncoding.		server enableMemoryLog			ifTrue:				[stream					cr; tab;					nextPutAll: 'conserve memory: '; print: server conserveMemory;					nextPutAll: ', damage filter: '; print: damageFilter notNil;					nextPutAll: ', filter raw encoding: '; print: server enableRawFilter;					cr; tab;					print: updateCount; nextPutAll: ' updates in ';					print: totalTime; nextPutAll: 'ms (';					print: totalTime // updateCount; nextPutAll: 'ms per update)';					cr; tab;					nextPutAll: 'heap per update: ';					print: lowWaterMark; nextPutAll: ' min, ';					print: highWaterMark; nextPutAll: ' max, ';					print: meanSeaLevel // updateCount; nextPutAll: ' average'.				 meanSeaLevel := updateCount := 0.				 lowWaterMark := highWaterMark := nil]]! !!RFBSession methodsFor: 'private' stamp: 'ikp 2/19/2007 21:08'!desktopName	"Answer the name of the desktop, constructed from the image, host and platform names."	"RFBSession new desktopName"	^String streamContents: [:stream |		stream			nextPutAll: (FileDirectory default localNameFor: SmalltalkImage current imageName);			nextPut: $@;			nextPutAll: server localHostName;			nextPutAll: ' [';			nextPutAll: SmalltalkImage current platformName; space; nextPutAll: SmalltalkImage current osVersion;			nextPut: $].		interactive ifFalse: [stream nextPutAll: ' - view only']]! !!RFBSession methodsFor: 'private' stamp: 'ikp 3/19/2004 10:30'!endUpdate	"Just sent a screen update.  If we're logging memory usage, update the cumulative counters accordingly."	| bytesUsed |	server enableMemoryLog ifFalse: [^self].	totalTime := totalTime + (Time millisecondsSince: updateTime).	bytesUsed := bytesLeft - Smalltalk primBytesLeft.		"A vague approximation, at best..."	Smalltalk vmParameterAt: 5 put: allocationCount.	bytesUsed < 0 ifTrue: [Smalltalk beepPrimitive.  ^self].	updateCount := updateCount + 1.	meanSeaLevel := meanSeaLevel + bytesUsed.	lowWaterMark isNil		ifTrue: [lowWaterMark := highWaterMark := bytesUsed]		ifFalse:			[lowWaterMark := lowWaterMark min: bytesUsed.			 highWaterMark := highWaterMark max: bytesUsed]! !!RFBSession methodsFor: 'private' stamp: 'ikp 3/19/2004 05:38'!fragmentRegion: rectangleList	"The user has a really small computer with only a few Kbytes to spare.  Break the update region into smaller chunks so as to avoid swapping pages out to drum or magtape."	| partySnax count delta bottom |	partySnax := OrderedCollection new.	rectangleList do:		[:rect |		 rect area <= 16384			ifTrue: [partySnax add: rect]			ifFalse:				[count := rect area // 16384 + 1.				 delta := rect height // count max: 1.				 rect top to: rect bottom - 1 by: delta do:					[:y |					 bottom := y + delta min: rect bottom.					 partySnax add: ((rect left @ y) corner: (rect right @ bottom))]]].	^partySnax! !!RFBSession methodsFor: 'initialize-release' stamp: 'ul 8/13/2012 18:01'!initServer: rfbServer socket: aSocket reverse: reverseFlag	"RFBSession withServer: nil socket: 42"	server := rfbServer.	socket := aSocket.	state := #rfbProtocolVersion.	interactive := true.	reverseConnection := reverseFlag.	readyForSetColourMapEntries := false.	correMaxWidth := 48.	correMaxHeight := 48.	modifiedRegion := RFBRegion new.	requestedRegion := 0 @ 0 extent: 0 @ 0.	format := RFBPixelFormat serverFormat.	rfbStream := format rfbStream.	enableCursorShapeUpdates := false.	enableCursorPosUpdates := false.	enableLastRectEncoding := false.	zlibCompressLevel := 5.	modifiers := 0.	updateSemaphore := Semaphore new.	updateProcess := [self updateLoop] forkAt: server sessionPriority.	currentCursor := Cursor currentCursor.	clientCursor := nil.	mousePosition := nil.	clientPosition := -1 @ -1.	fixColourMapEntries := RFBFixColourMapEntries new.	framebufferUpdateRequest := RFBFramebufferUpdateRequest new.	framebufferUpdate := RFBFramebufferUpdate new.	updateRectHeader := RFBFramebufferUpdateRectHeader new.	keyEvent := RFBKeyEvent new.	pointerEvent := RFBPointerEvent new.	clientCutText := RFBClientCutText new.	rreHeader := RFBRREHeader new.	zrleHeader := RFBZRLEHeader new.	xCursorColoursHeader := RFBXCursorColoursHeader new.	damageFilter := server enableDamageFilter ifTrue: [RFBDamageFilter forDisplay].	incremental := true.	updateCount := 0.	meanSeaLevel := 0.	totalTime := 0.	self log: 'initialised'.	server isNil ifFalse: [server addSession: self]! !!RFBSession methodsFor: 'display events' stamp: 'ikp 3/8/2004 03:40'!invalidate: aRectangle	"Add aRectangle to the region modified since the last update message was sent.  Signal the updateSemaphore to nudge the update process into sending a framebuffer update message sometime in the near future."	modifiedRegion add: aRectangle.	updateSemaphore signal! !!RFBSession methodsFor: 'private' stamp: 'ar 11/10/2004 14:07'!log: aString	"Write aString to the server log."	^Logging ifTrue: [RFBServer log: '[', thisContext sender printString,'] ', aString] ifFalse: [aString]! !!RFBSession methodsFor: 'display events' stamp: 'ikp 3/8/2004 03:51'!mousePosition: aPoint	"The local pointer has moved.  If the viewer has registered an interest in cursor position updates, store the new location for inclusion in the next update message sent."	enableCursorPosUpdates & (clientPosition ~= aPoint)		ifTrue:			[mousePosition := aPoint.			 updateSemaphore signal]! !!RFBSession methodsFor: 'display events' stamp: 'ikp 3/19/2004 04:40'!newDepth: depth	"The Squeak Display has just changed depth.  Reinitialise the pixel format and screen damage filter (both of which depend on the Display depth) and ensure that the next update will not filter any damage from the screen (which Squeak is about to redraw)."	format setMaps.	damageFilter isNil ifFalse: [damageFilter := RFBDamageFilter forDisplay].	incremental := false.! !!RFBSession methodsFor: 'client state' stamp: 'ikp 3/19/2004 10:03'!processMetaKey: key down: down	"Update our idea of the modifier key state in the viewer."	| mod |	mod := ModifierMap at: key.	modifiers := down		ifTrue: [modifiers bitOr: mod]		ifFalse: [modifiers bitAnd: (mod bitXor: 16rFF)].! !!RFBSession methodsFor: 'authenticating' stamp: 'ikp 3/5/2004 09:05'!randomBytes	"RFBSession new randomBytes"	| random |	random := Random seed: (Time millisecondClockValue).	^((1 to: 16) collect: [:i | (random next * 256) truncated]) asByteArray! !!RFBSession methodsFor: 'initialize-release' stamp: 'ikp 3/19/2004 04:40'!release	"Release the session.  The main purpose of this is to ensure that neither the input nor the output process (or anything else) ever touch server or socket again."	updateProcess terminate.	process == Processor activeProcess ifFalse: [process terminate].	server isNil ifFalse: [server removeSession: self].	damageFilter isNil ifFalse: [damageFilter release].	server := nil.	socket := nil.	modifiedRegion := nil.	zlibStream := nil.	rfbStream := nil.	damageFilter := nil.	self log: 'released'.! !!RFBSession methodsFor: 'message dispatching' stamp: 'ikp 3/20/2004 09:33'!rfbAuthentication	"Read and process an incoming protocol authentication message."	| response |	response := socket receiveData: (RFBMessage new: 16).	interactive := server authenticateChallenge: authChallenge response: response.	interactive isNil		ifTrue:			[self log: 'authentication failed'.			 socket sendData: RFBMessage newVncAuthFailed.			 ^socket close].	socket sendData: RFBMessage newVncAuthOK.	state := #rfbInitialisation! !!RFBSession methodsFor: 'client messages' stamp: 'ul 8/16/2012 16:09'!rfbClientCutText	"Read and process a client cut text message from the viewer."	| msg text |	self log: 'received rfbClientCutText'.	msg := socket receive: clientCutText.	text := ByteString new: msg length.	socket receiveData: text.	text := text withSqueakLineEndings asText.	[ 		"Update the contents of the clipboard. See RFBServer class >> #clipboardContentChanged:source: how the second argument is used."		Clipboard default			clipboardText: text			notifyWith: #rfbClientCutText ]		ifError: [ "No full clipboard support in this image yet. We can still accept the text"			Clipboard default clipboardText: text ]! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:11'!rfbEncodingCoRRE	"Note the client's interest in receiving updates using compressed RRE encoding."	self setPreferredEncoding: 'CoRRE'! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:00'!rfbEncodingCompressLevel: level	"Register the client's interest in receiving update messages with the given level of zlib compression."	self log: 'rfbEncodingCompressLevel ' , level printString.	zlibCompressLevel := level.	self log: 'using compression level ' , level printString! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:04'!rfbEncodingCopyRect	"Record the client's interest in receiving updates using copy rect encoding.  Since we cannot obtain (from Morphic) the information needed to implement this, we ignore it."	self log: 'rfbEncodingCopyRect'.! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:01'!rfbEncodingHextile	"Record the client's interest in receiving updates in hextile encoding."	self setPreferredEncoding: 'Hextile'! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:15'!rfbEncodingLastRect	"Record the client's ability to deal with last rect encoding (which is a way to avoid having to count the number of rectangles to be sent in an update message in advance)."	self log: 'rfbEncodingLastRect'.	enableLastRectEncoding		ifFalse:			[self log: 'enabling LastRect protocol extension'.			 enableLastRectEncoding := true]! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/18/2004 03:56'!rfbEncodingPointerPos	"Register the viewer's interest in receiving pointer position update messages."	self log: 'rfbEncodingPointerPos'.	enableCursorPosUpdates		ifFalse:			[self log: 'enabling cursor position updates'.			 enableCursorPosUpdates := true]! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 03:52'!rfbEncodingQualityLevel: level	"Record the viewer's interest in receiving tight encoding at the given quality setting."	self log: 'rfbEncodingQualityLevel ' , level printString! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 04:01'!rfbEncodingRRE	"Record the client's interest in receiving framebuffer update messages in RRE encoding."	self setPreferredEncoding: 'RRE'! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 03:40'!rfbEncodingRaw	"Record the client's ability to receive rectangles in raw encoding."	self setPreferredEncoding: 'Raw'! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/18/2004 03:56'!rfbEncodingRichCursor	"Record the client's interest in receiving rich (full-colour) cursor shape updates."	self log: 'rfbEncodingRichCursor'.	enableCursorShapeUpdates		ifFalse:			[self log: 'enabling full-colour cursor updates'.			 enableCursorShapeUpdates := true.			 useRichCursorEncoding := true]! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/23/2004 12:50'!rfbEncodingTight	"Register the client's interest in receiving update messages using tight encoding."	self log: 'rfbEncodingTight'! !!RFBSession methodsFor: 'configuring' stamp: 'ul 7/20/2009 13:57'!rfbEncodingUnknown: encoding	"Write a message to the log indicating that an unknown encoding number has been received during the protocol handshake."	self log: 'ignoring unknown encoding: ' , encoding printStringHex.! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/18/2004 03:56'!rfbEncodingXCursor	"Record the client's ability to receive X11-style cursor shape update messages."	self log: 'rfbEncodingXCursor'.	self log: 'enabling X-style cursor updates'.	enableCursorShapeUpdates := true.	useRichCursorEncoding := false! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/24/2004 03:32'!rfbEncodingZRLE	"Record the client's interest in receiving updates in Zlib Run-Length Encoding."	server allowZRLE		ifTrue:			[self setPreferredEncoding: 'ZRLE'.			 zlibStream := RFBZLibWriteStream on: ByteArray new]		ifFalse:			[self log: 'ignoring request for ZRLE encoding']! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/23/2004 12:50'!rfbEncodingZlib	"Record the client's interest in receiving update messages using zlib encoding."	self log: 'rfbEncodingZlib'! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/23/2004 12:51'!rfbEncodingZlibHex	"Record the client's capability to receive ZLibHex encoded rectangles.  Note: This encoding is deprecated and is no longer described in the RFB protocol specification.  We ignore it."	self log: 'ignoring deprecated protocol ZlibHex'.	self unimplemented! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:03'!rfbFixColourMapEntries	"Read and process a fix colourmap entries message."	| msg nColours colours |	self log: 'received rfbFixColourMapEntries'.	msg := socket receive: fixColourMapEntries.	nColours := msg nColours.	colours := ByteArray new: 3 * 2 * nColours.	socket receiveData: colours.	self unimplemented! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:04'!rfbFramebufferUpdateRequest	"Read and process an incoming framebuffer update request."	| msg box |	msg := socket receive: framebufferUpdateRequest.	box := Rectangle origin: msg x @ msg y extent: msg w @ msg h."	self log: 'update region request ' , box printString."	requestedRegion := requestedRegion merge: box."	readyForSetColourMapEntries		ifFalse:			[readyForSetColourMapEntries _ true.			 format trueColour				ifFalse:					[self setClientColourMap: format from: 0 count: 0]]."	msg incremental		ifFalse:			[modifiedRegion add: box.			 incremental := false].	updateSemaphore signal.! !!RFBSession methodsFor: 'message dispatching' stamp: 'ikp 3/20/2004 10:58'!rfbInitialisation	"Receive and process an incoming protocol initialisation message."	| clientInitMessage serverInitMessage sharedFlag |	clientInitMessage := socket receiveData: (RFBMessage new: 1).	sharedFlag := (clientInitMessage byteAt: 1) ~~ 0.	self log: 'client shared: ' , sharedFlag printString.	interactive := interactive and: [server allowInteractive].	interactive ifFalse: [self log: 'client is view only'].	serverInitMessage := RFBServerInitialisation		extent: Display extent		format: RFBPixelFormat serverFormat		name: self desktopName.	socket sendData: serverInitMessage.	self log: socket printString, ' connected'.	server debugging ifTrue: [Transcript endEntry].	server enforcePriorityFor: self shared: sharedFlag.	state := #rfbNormal! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:04'!rfbKeyEvent	"Read and process an incoming key event message."	| msg evt key |	msg := socket receive: keyEvent.	interactive ifFalse: [^self].	(key := self decodeKey: msg key) isNil ifTrue: [^self].	key < 0 ifTrue: [^self processMetaKey: key negated down: msg down].	evt := (Array new: 8) atAllPut: 0.	evt		at: 1 put: EventTypeKeyboard;		at: 2 put: Time millisecondClockValue;		at: 3 put: key;		at: 4 put: (msg down ifTrue: [EventKeyDown] ifFalse: [EventKeyUp]);		at: 5 put: modifiers.	Sensor processEvent: evt.	msg down		ifTrue:			[evt at: 4 put: EventKeyChar.			 Sensor processEvent: evt]! !!RFBSession methodsFor: 'message dispatching' stamp: 'ikp 3/20/2004 08:59'!rfbNormal	"Receive and process the next normal protocol message."	| type |	type := (socket receiveData: (RFBMessage new: 1)) byteAt: 1.	(type < 0) | (type >= MessageTypes size)		ifTrue:			[self log: 'illegal message type ' , type printString , ' received'.			 self abort].	self perform: (MessageTypes at: 1 + type).! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:04'!rfbPointerEvent	"Receive and process an incoming pointer event message."	| message event buttons |	message := socket receive: pointerEvent.	interactive ifFalse: [^self].	event := (Array new: 8) atAllPut: 0.	buttons := self decodeButtons: message buttonMask modified: modifiers.	event		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: message x;		at: 4 put: message y;		at: 5 put: (buttons bitAnd: 7);		at: 6 put: (buttons bitShift: -3).	"Avoid sending a useless pointer update."	enableCursorPosUpdates ifTrue: [clientPosition := message x @ message y].	Sensor processEvent: event! !!RFBSession methodsFor: 'message dispatching' stamp: 'ikp 3/20/2004 08:59'!rfbProtocolVersion	"Read and process an incoming protocol version message.  Reject the viewer's connection attempt if it is too old for us to cope with."	| buf protocolMajor |	buf := socket receiveData: (String new: 12).	self log: buf.	protocolMajor := (buf copyFrom: 5 to: 7) asInteger.	protocolMinor := (buf copyFrom: 9 to: 11) asInteger.	self log: 'viewer using protocol ' , protocolMajor printString , '.' , protocolMinor printString.	protocolMajor == ProtocolMajor		ifFalse:			[self log: 'major version mismatch'.			 ^self sendConnectionFail:				'RFB protocol version mismatch - server ' ,				ProtocolMajor printString , '.' , ProtocolMinor printString ,				' client ' , protocolMajor printString , '.' , protocolMinor printString].	protocolMinor == ProtocolMinor		ifFalse: [self log: 'ignoring minor version mismatch'].	self authenticateClient! !!RFBSession methodsFor: 'message dispatching' stamp: 'ikp 3/21/2004 10:49'!rfbSecurityType	"Read and process an incoming security type message.  This must correspond to the presence of a password on the server."	| response type |	response := socket receiveData: (RFBMessage new: 1).	type := response byteAt: 1.	(type == SecurityTypeNone and: [server hasPassword])		ifTrue:			[self log: 'authentication failed'.			 socket sendData: RFBMessage newVncAuthFailed.			 ^socket close].	type == SecurityTypeNone		ifTrue:			[^state := #rfbInitialisation].	type == SecurityTypeVNC		ifTrue:			[socket sendData: (authChallenge := self randomBytes).			 ^state := #rfbAuthentication].	self log: 'unknown security type response: ' , type printString.	socket close! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:03'!rfbSetEncodings	"Receive and process a set encodings message from the viewer."	| msg enc number name nameArg |	preferredEncoding := nil.	msg := socket receiveNew: RFBSetEncodings.	enc := socket receiveData: (RFBMessage new: 4 * msg nEncodings).	0 to: msg nEncodings - 1 do: [:i |		number := enc unsignedLongAt: i * 4 + 1.		name := Encodings at: number ifAbsent: [nil].		name isNil			ifTrue:				[nameArg := self specialEncodingAt: number.				 self perform: nameArg first with: nameArg second]			ifFalse:				[self perform: name]].	preferredEncoding isNil ifTrue: [self setPreferredEncoding: 'Raw'].	(enableCursorPosUpdates and: [enableCursorShapeUpdates not])		ifTrue:			[self log: 'disabling cursor position updates'.			 enableCursorPosUpdates := false]! !!RFBSession methodsFor: 'client messages' stamp: 'ikp 3/20/2004 09:03'!rfbSetPixelFormat	"Read and process a set pixel format message from the viewer."	| msg |	self log: 'received rfbSetPixelFormat'.	msg := socket receiveNew: RFBSetPixelFormat.	format := msg pixelFormat.	rfbStream := format rfbStream.	self log: 'set pixel format: ' , format description.	format colourMap isNil		ifFalse:			[self log: 'colour map ' , format colourMap masks printString , ' ' , format colourMap shifts printString.			 format colourMap colors isNil				ifFalse:					[self log: 'colour table ' , format colourMap colors size printString]]! !!RFBSession methodsFor: 'server processes' stamp: 'ikp 3/20/2004 09:08'!runLoop	"Run the incoming half of the session.  Send the client a protocol version message, then set the session state to expect an incoming protocol version reply from the viewer.  Then loop forever reading and dispatching messages from the viewer.  See RFBSession>>runSafely:, which exists only when an error (hopefully 'connection closed' ;-) is signalled."	self log: 'running'.	state := #rfbProtocolVersion.	self log: 'send protocol version'.	socket sendData: ProtocolVersion.	socket runSafely:		[socket waitForData.		 self perform: state].	self log: 'run loop exiting'.	self release! !!RFBSession methodsFor: 'server messages' stamp: 'ikp 3/20/2004 09:08'!sendBell	"Send a message that will ring the terminal bell on the viewer's machine."	socket sendData: RFBBell new! !!RFBSession methodsFor: 'server messages' stamp: 'kb 10/15/2008 16:08'!sendClipboardText: aStringOrText	socket sendData: (RFBServerCutText text: aStringOrText)	! !!RFBSession methodsFor: 'server messages' stamp: 'ikp 3/20/2004 09:30'!sendConnectionFail: reason	"Send a connection failure message to the client, then terminate the session."	socket sendData: (RFBMessage newConnFailed: reason).	socket closeAndDestroy! !!RFBSession methodsFor: 'sending' stamp: 'ikp 3/20/2004 09:08'!sendCursorForm: cursorForm extent: extent bytesPerPixel: bytesPerPixel	"Send a cursorForm (a CursorWithMask) to the remote viewer as part of a cursor shape update message."	| w bits bytes byteRow wordRow |	w := extent x.	bits := cursorForm bits.	bytes := ByteArray new: extent x * extent y.	1 to: extent y do: [:y |		byteRow := y - 1 * w.		wordRow := y - 1 * 4.		1 to: w do: [:x | bytes at: byteRow + x put: (bits byteAt: wordRow + x)]].	socket sendData: bytes! !!RFBSession methodsFor: 'server messages' stamp: 'ikp 3/20/2004 09:09'!sendCursorPosition: aPoint	"Send a cursor position update message."	socket sendData: (updateRectHeader cursorPos: aPoint type: RfbEncodingPointerPos)! !!RFBSession methodsFor: 'server messages' stamp: 'ikp 3/8/2004 03:53'!sendCursorShape: newCursor	"Send a cursor shape update message to the viewer."	| cursorExtent |	cursorExtent := newCursor extent + (7@0) // (8@1).	self		sendData: (updateRectHeader						cursorHotSpot: newCursor offset negated						extent: newCursor extent						type: RfbEncodingXCursor);		sendData: (RFBXCursorColoursHeader standardColours);		sendCursorForm: newCursor extent: cursorExtent bytesPerPixel: 1;		sendCursorForm: newCursor maskForm extent: cursorExtent bytesPerPixel: 1! !!RFBSession methodsFor: 'sending' stamp: 'ikp 3/8/2004 04:06'!sendData: aByteArray	"Send the contents of aByteArray to the viewer."	^socket sendData: aByteArray! !!RFBSession methodsFor: 'sending' stamp: 'ikp 3/15/2004 17:54'!sendForm: form	"Even though #sendData: supports sending word data directly, we cannot use it because of a bug in the SocketPlugin logic.  (A partial write may not send an integral number of words, and there is no way to detect this inside the image: the plugin gives us back the number of bytes sent converted back into an integral number of words, which could be up to 3 bytes short of the amount of data actually sent.  Bummer, huh?)"	| bytesPerLine bytesPerScan byte buf |	bytesPerLine := form width * form bytesPerPixel.	bytesPerScan := bytesPerLine + 3 bitAnd: -4.	buf := ByteArray new: bytesPerScan * form height.	format swapBytesIfNeeded: form.	(RFBForm new hackBits: form bits) displayOn: (RFBForm new hackBits: buf).	bytesPerLine == bytesPerScan		ifTrue:			[socket sendData: buf]		ifFalse:			[byte := 1.			 1 to: form height do: [:y |				socket sendData: buf startingAt: byte count: bytesPerLine.				byte := byte + bytesPerScan]]! !!RFBSession methodsFor: 'server messages' stamp: 'ikp 3/20/2004 09:10'!sendFramebufferUpdate	"Send a framebuffer update message to the viewer using the viewer's preferred encoding, unless raw encoding results in fewer bytes transmitted.  (All viewers are required to implement raw encoding.)"	| updateRegion nRects sendCursor sendPosition |	self beginUpdate.	"Get the set of damaged rectangles as reported by Morphic."	updateRegion := (modifiedRegion removeAll						collect: [:rect | rect intersect: requestedRegion])				 		select: [:rect | rect hasPositiveExtent].	"Whittle them down to a much better approximation of reality."	(damageFilter notNil and: [preferredEncoding ~~ #rfbEncodingRaw								or: [server enableRawFilter]])		ifTrue:			[incremental				ifTrue: [updateRegion := damageFilter getDamageInRegion: updateRegion]				ifFalse: [damageFilter updateDamageInRegion: updateRegion]].	incremental := true.	"If we're conserving memory, break the updates into fun-size party snacks."	server conserveMemory		ifTrue: [updateRegion := self fragmentRegion: updateRegion].	"Calculate how many update rectangles we need to send in total."	nRects := updateRegion isEmpty				ifTrue: [0]				ifFalse: [self perform: countRects with: updateRegion].	sendCursor := enableCursorShapeUpdates and: [currentCursor notNil].	sendPosition := enableCursorPosUpdates and: [mousePosition notNil].	nRects == UseLastRect		ifFalse: [nRects := nRects							+ (sendCursor ifTrue: [1] ifFalse: [0])							+ (sendPosition ifTrue: [1] ifFalse: [0])].	"Send the updates."	nRects == 0		ifFalse:			[socket sendData: (framebufferUpdate nRects: nRects).			 updateRegion do: [:rect |				self perform: sendRect with: (format displayContents: rect)].			 sendCursor				ifTrue:					[clientCursor := currentCursor.					 currentCursor := nil.					 self sendCursorShape: clientCursor].			 sendPosition				ifTrue:					[clientPosition := mousePosition.					 mousePosition := nil.					 self sendCursorPosition: clientPosition].			 nRects == UseLastRect				ifTrue:					[socket sendData: (updateRectHeader type: RfbEncodingLastRect)]].	self endUpdate.	server conserveMemory ifTrue: [rfbStream := format rfbStream]! !!RFBSession methodsFor: 'encoding-corre' stamp: 'ikp 3/8/2004 03:56'!sendRectEncodingCoRRE: aForm	"Send a framebuffer update message covering the entire contents of aForm in compressed RRE encoding."	^self sendRectEncodingCoRRE: aForm in: aForm boundingBox! !!RFBSession methodsFor: 'encoding-corre' stamp: 'ikp 3/8/2004 03:44'!sendRectEncodingCoRRE: aForm in: bounds	"Send an update message covering the contents of aForm within the given bounds in compressed RRE encoding.  Note that this method descends recursively until bounds is no larger than 48x48."	| x y w h |	x := bounds left.	y := bounds top.	w := bounds width.	h := bounds height.	h > correMaxHeight		ifTrue:			[^self				sendRectEncodingCoRRE: aForm in: (bounds origin extent: w@correMaxHeight);				sendRectEncodingCoRRE: aForm in: (x@(y+correMaxHeight) extent: w@(h-correMaxHeight))].	w > correMaxWidth		ifTrue:			[^self				sendRectEncodingCoRRE: aForm in: (bounds origin extent: correMaxWidth@h);				sendRectEncodingCoRRE: aForm in: ((x+correMaxWidth)@y extent: ((w-correMaxWidth)@h))].	self sendSmallRectEncodingCoRRE: aForm in: bounds! !!RFBSession methodsFor: 'encoding-hextile' stamp: 'ikp 3/20/2004 09:10'!sendRectEncodingHextile: aForm	"Send a framebuffer update message for the entire contents of aForm in hextile encoding."	socket sendData: (updateRectHeader bounds: aForm bounds type: RfbEncodingHextile).	aForm hextileEncodeOn: rfbStream resetContents forClient: socket! !!RFBSession methodsFor: 'encoding-rre' stamp: 'ikp 3/20/2004 09:11'!sendRectEncodingRRE: aForm	"Send a single update rectangle in RRE encoding covering the entire contents of aForm."	| nSubrects |	nSubrects := aForm rreSubrectEncodeOn: rfbStream resetContents.	nSubrects < 0 ifTrue: [^self sendRectEncodingRaw: aForm].	socket		sendData: (updateRectHeader bounds: aForm bounds type: RfbEncodingRRE);		sendData: (rreHeader nSubrects: nSubrects);		sendStream: rfbStream! !!RFBSession methodsFor: 'encoding-raw' stamp: 'ikp 3/8/2004 03:23'!sendRectEncodingRaw: aForm	"Send an update rectangle for the entire contents of aForm in raw encoding."	^self sendRectEncodingRaw: aForm in: (aForm boundingBox translateBy: aForm offset)! !!RFBSession methodsFor: 'encoding-raw' stamp: 'ikp 3/8/2004 04:08'!sendRectEncodingRaw: aForm in: bounds	"Send a framebuffer update message for the contents of aForm within the given bounds using raw encoding."	self		sendData: (updateRectHeader bounds: bounds type: RfbEncodingRaw);		sendForm: aForm! !!RFBSession methodsFor: 'encoding-zrle' stamp: 'ikp 3/24/2004 03:53'!sendRectEncodingZRLE: aForm	"Send a framebuffer update message for the entire contents of aForm in ZRLE encoding."	| encodedData rawData |	aForm zrleEncodeOn: rfbStream resetContents.	rawData := rfbStream contents.	encodedData := zlibStream nextPutAll: rawData; synchronisedContents.	socket		sendData: (updateRectHeader bounds: aForm bounds type: RfbEncodingZRLE);		sendData: (zrleHeader length: encodedData size);		sendData: encodedData! !!RFBSession methodsFor: 'encoding-corre' stamp: 'ikp 3/20/2004 09:12'!sendSmallRectEncodingCoRRE: aForm in: bounds	"Send an update message for the contents of aForm within the given bounds.  Note that this is where the recursion in RFBForm>>sendRectEncodingCoRRE: terminates."	| nSubrects |	nSubrects := aForm correSubrectEncodeIn: bounds on: rfbStream resetContents.	nSubrects < 0		ifTrue:			[self				sendRectEncodingRaw: (aForm subForm: bounds)				in: (bounds translateBy: aForm offset)]		ifFalse:			[socket				sendData: (updateRectHeader							bounds: (bounds translateBy: aForm offset)							type: RfbEncodingCoRRE);				sendData: (rreHeader nSubrects: nSubrects);				sendStream: rfbStream]! !!RFBSession methodsFor: 'sending' stamp: 'ikp 3/20/2004 09:13'!sendStream: aStream	"Send the entire contents of aStream to the viewer."	^socket sendStream: aStream! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 03:49'!setPreferredEncoding: encodingName	"The client has just registered an interest in receiving updates in the encoding with the given name.  If this is the first encoding in the list of acceptable encodings, record it as the preferred encoding for the client."	preferredEncoding isNil		ifTrue:			[preferredEncoding := Symbol intern: 'rfbEncoding' , encodingName.			 sendRect := Symbol intern: 'sendRectEncoding' , encodingName , ':'.			 countRects := Symbol intern: 'countRectsEncoding' , encodingName , ':'.			 self log: 'using ' , encodingName , ' encoding']! !!RFBSession methodsFor: 'configuring' stamp: 'ikp 3/8/2004 03:48'!specialEncodingAt: encodingNumber	"Answer the special encoding represented by the given 32-bit encodingNumber."	| type name arg |	type := encodingNumber bitAnd: 16rFFFFFF00.	type = 16rFFFFFF00 ifFalse: [^Array with: #rfbEncodingUnknown: with: encodingNumber].	type := (encodingNumber bitAnd: 16rF0) bitShift: -4.	name := SpecialEncodings at: type ifAbsent: [^Array with: #rfbEncodingUnknown: with: encodingNumber].	arg := encodingNumber bitAnd: 16r0F.	^Array with: name with: arg! !!RFBSession methodsFor: 'controlling' stamp: 'ikp 3/8/2004 04:02'!start	"Start the server input process."	process := [self runLoop] forkAt: server sessionPriority.	self log: 'started ' , process printString.! !!RFBSession methodsFor: 'controlling' stamp: 'ikp 3/19/2004 02:12'!stop	"Close down the receiver's session."	socket closeAndDestroy.	Processor yield.	self log: 'stopped'.	self release! !!RFBSession methodsFor: 'private' stamp: 'ikp 4/29/2011 09:20'!unimplemented	"Make some noise when encountering an unimplemented feature.  Strictly developer lossage."	self log: 'unimplemented'.	Beeper beepPrimitive.	Transcript endEntry! !!RFBSession methodsFor: 'server processes' stamp: 'ikp 3/20/2004 08:21'!updateLoop	"Run the outgoing half of the connection.  Wait for a screen update to occur, send a corresponding framebuffer update message, rinse and repeat until clean.  Note the processor yield which is there to give the input loop chance to run (think: interrupt keycode) in the case of abusive screen updates."	socket runSafely:		[updateSemaphore wait.		 self updatePending			ifTrue:				[self sendFramebufferUpdate.				 Processor yield]].	self log: 'update loop exiting'.! !!RFBSession methodsFor: 'testing' stamp: 'ikp 3/8/2004 04:07'!updatePending	"Answer whether an update message is required.  Update messages can contain damage repair, cursor shape changes, or pointer position updates -- so allow for each of these situations while formulating the answer."	^mousePosition notNil & (mousePosition ~= clientPosition)		or:	[currentCursor notNil & (currentCursor ~~ clientCursor)		or:	[modifiedRegion isEmpty not]]! !!RFBMenuMorph methodsFor: 'construction' stamp: 'ul 7/9/2009 15:19'!add: aSymbolOrString action: selector help: helpString	"Add a new menu item with the given action selector and balloon helpString.  If aBlockOrString is a string then the item's label is fixed.  If aBlockOrString is a Block then the label will update from the result of invoking the block."	aSymbolOrString isSymbol		ifTrue: [ (self addUpdating: aSymbolOrString action: selector) lastItem ]		ifFalse: [ super add: aSymbolOrString action: selector ].	self balloonTextForLastItem: helpString! !!RFBMenuMorph methodsFor: 'construction' stamp: 'ikp 3/19/2004 04:31'!add: label get: getBlock set: setBlock help: helpString	"Add a new updating item with the given label and balloon helpString.  The getBlock provides a Boolean with which the <yes>/<no> prefix for the label is retrieved.  If the item is selected then setBlock is invoked."	(self addUpdating: #getLabel: target: setBlock selector: #value argumentList: EmptyArray)		wordingProvider: self		wordingSelector: #getLabel:;		wordingArgument: (Array with: getBlock with: label).	self balloonTextForLastItem: helpString! !!RFBMenuMorph methodsFor: 'private' stamp: 'ul 7/9/2009 15:20'!addUpdating: wordingSelector target: target selector: aSymbol argumentList: argList	^self		addUpdating: wordingSelector		enablementSelector: nil		target: target		selector: aSymbol		argumentList: argList! !!RFBMenuMorph methodsFor: 'private' stamp: 'ikp 3/19/2004 04:29'!getLabel: blockAndLabelArray	"The blockAndLabelArray contains a Block and a label String.  Answer a new label created by invoking the block, converting its (Boolean) result into a <yes>/<no> prefix, and prepending it to the label."	| block label prefix |	block := blockAndLabelArray first.	label := blockAndLabelArray second.	prefix := block value ifTrue: ['<yes>'] ifFalse: ['<no>'].	^prefix , label! !!RFBRegion methodsFor: 'accessing' stamp: 'ikp 3/8/2004 04:27'!add: aRectangle	"Add aRectangle to the region represented by the receiver."	aRectangle hasPositiveExtent ifTrue: [self nextPut: aRectangle]! !!RFBRegion methodsFor: 'accessing' stamp: 'ul 7/8/2011 22:41'!removeAll	"Answer an Array containing all the damage rectangles in the receiver, emptying the receiver in the process."	^Array new: self size streamContents: [ :stream |		self flushAllSuchThat: [ :each |			stream nextPut: each.			true ] ]! !!RFBRegion methodsFor: 'accessing' stamp: 'ikp 3/8/2004 04:28'!removeFirst	"Answer the first rectangle in the region represented by the receiver, removing it in the process."	^self isEmpty ifTrue: [0@0 corner: 0@0] ifFalse: [self next]! !!RFBEventSensor methodsFor: 'copying' stamp: 'ikp 3/7/2004 20:30'!copyFrom: other	"Initialise the state of the receiver based on some other EventSensor object."	1 to: other class instSize do: [:i | self instVarAt: i put: (other instVarAt: i)]! !!RFBEventSensor methodsFor: 'copying' stamp: 'ikp 3/7/2004 20:29'!copyTo: other	"Copy the state of the receiver into another EventSensor object."	1 to: other class instSize do: [:i | other instVarAt: i put: (self instVarAt: i)].	^other! !!RFBEventSensor methodsFor: 'cursor' stamp: 'ikp 3/7/2004 20:30'!currentCursor: newCursor	"Update the current cursor position.  Propagate the new cursor position to all remote viewers."	super currentCursor: newCursor.	rfbServer isNil ifFalse: [rfbServer currentCursor: newCursor]! !!RFBEventSensor methodsFor: 'initialise-release' stamp: 'ikp 3/7/2004 20:28'!initialize	"Initialize the receiver."	super initialize.	eventMutex := Semaphore forMutualExclusion! !!RFBEventSensor methodsFor: 'private' stamp: 'ikp 3/7/2004 20:29'!processMouseEvent: evt	"Process a mouse event caused by cursor motion.  Propagate the new mouse position to all remote viewers."	| prev |	prev := mousePosition.	super processMouseEvent: evt.	rfbServer notNil & (prev ~= mousePosition)		ifTrue: [rfbServer mousePosition: mousePosition]! !!RFBEventSensor methodsFor: 'accessing' stamp: 'ikp 3/7/2004 20:30'!rfbServer: server	"Set the receiver's RFBServer."	rfbServer := server! !"RFB"!Installer ss project: 'RFB';			install: ' RFB-ikp.8.mcz'.!RFBServer setFullPassword!RFBServer start.!----SNAPSHOT----{14 August 2015 . 12:46:23 am} Squeak5.0-15113.image priorSource: 20347!----STARTUP----{20 August 2015 . 2:49:56 am} as /tmp/Squeak-5.0-All-in-One/Squeak-5.0-All-in-One.app/Contents/Resources/Squeak5.0-15113.image!!RFBMenuMorph methodsFor: 'construction' stamp: 'pls 8/20/2015 20:59' prior: 34372339!add: label get: getBlock set: setBlock help: helpString	"Add a new updating item with the given label and balloon helpString.  The getBlock provides a Boolean with which the <yes>/<no> prefix for the label is retrieved.  If the item is selected then setBlock is invoked."	(self addUpdating: #getLabel: target: setBlock selector: #value argumentList: Array empty)		wordingProvider: self		wordingSelector: #getLabel:;		wordingArgument: (Array with: getBlock with: label).	self balloonTextForLastItem: helpString! !----SNAPSHOT----{20 August 2015 . 9:00:11 pm} Squeak5.0-15113.image priorSource: 821531!RFBServer log!----SNAPSHOT----{20 August 2015 . 9:02:50 pm} Squeak5.0-15113.image priorSource: 822373!